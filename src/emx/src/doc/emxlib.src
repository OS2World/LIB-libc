þc emxlib.src

þtext
===============================================================================
emxlib.doc        emx 0.9d     C LIBRARY REFERENCE                  21-Dec-1998
===============================================================================
                                     Copyright (c) 1990-1998 by Eberhard Mattes
þendtext

þtitle emx 0.9d C Library Reference

þformat bold emx emxbind emxload ld

þformat tty .a .o .com .exe cmd.exe command.com
þformat tty emx.dll emxlibc.dll emxlibcm.dll emxlibcs.dll
þformat tty emxwrap.dll emxio.dll makefile emx.exe
þformat tty sys.lib emx.a emx.lib emx2.a emx2.lib os2.a os2.lib
þformat tty binmode.o binmode.obj
þformat tty <a_out.h> <alloca.h> <ar.h> <assert.h> <conio.h> <ctype.h>
þformat tty <curses.h> <dirent.h> <dos.h> <errno.h> <fcntl.h> <float.h>
þformat tty <fnmatch.h> <ftw.h> <getopt.h> <glob.h> <graph.h> <grp.h>
þformat tty <ieee.h> <io.h> <limits.h> <malloc.h> <math.h> <memory.h>
þformat tty <os2.h> <os2emx.h> <os2thunk.h> <os2tk.h> <process.h> <pwd.h>
þformat tty <setjmp.h> <sgtty.h> <share.h> <signal.h> <stdarg.h> <stddef.h>
þformat tty <stdio.h> <stdlib.h> <string.h> <strings.h> <termcap.h>
þformat tty <termio.h> <termios.h> <time.h> <umalloc.h> <unistd.h> <varargs.h>
þformat tty <locale.h> <ulimit.h> <utime.h>
þformat tty <emx/bigint.h> <emx/float.h> <emx/io.h> <emx/locale.h> <emx/nls.h>
þformat tty <emx/pwd.h> <emx/startup.h> <emx/syscalls.h> <emx/thread.h>
þformat tty <emx/time.h> <emx/umalloc.h>
þformat tty <sys/builtin.h> <sys/dir.h> <sys/dirent.h>
þformat tty <sys/dirtree.h> <sys/ea.h> <sys/ead.h> <sys/emxload.h>
þformat tty <sys/fcntl.h> <sys/file.h> <sys/fmutex.h> <sys/hw.h> <sys/ioctl.h>
þformat tty <sys/ipc.h> <sys/kbdscan.h> <sys/moddef.h> <sys/msg.h> <sys/nls.h>
þformat tty <sys/param.h> <sys/process.h> <sys/ptrace.h> <sys/reg.h>
þformat tty <sys/rmutex.h>
þformat tty <sys/resource.h> <sys/select.h> <sys/signal.h> <sys/smutex.h>
þformat tty <sys/socket.h> <sys/so_ioctl.h> <sys/stat.h> <sys/statfs.h>
þformat tty <sys/termio.h> <sys/time.h> <sys/timeb.h> <sys/times.h>
þformat tty <sys/types.h> <sys/uflags.h> <sys/uio.h> <sys/user.h> <sys/utime.h>
þformat tty <sys/utsname.h> <sys/video.h> <sys/wait.h> <sys/winmgr.h>

þformat tty HPFS.IFS xf86sup.sys

þformat tty c_alias c_app c_dllnrt, c_dllrt c_dllso c_import c_static emx2
þformat tty emxio moddef

þformat tty -Zmt -Zmtd -Zmts -Zomf -Zsys -Zbsd-signals -Zsysv-signals
þformat tty -Zno-rte -Zso -Zcrtdll -Zbin-files -Zsmall-conv -pg
þformat tty -l -lg -lgcc -lc -g -lwrap -lemxio -ltmalloc -mprobe
þformat tty -lgraph -lvideo -lmoddef -lsocket -fpcc-struct-return
þformat tty -c -p -t -ac -acm -ai -am -aw

þformat tty #define void volatile wchar_t jmp_buf sigjmp_buf sigset_t glob_t

þformat tty _DT_TREE _DT_NOCPDIR _EMXLOAD_INDEFINITE
þformat tty MB_CUR_MAX MB_MAX_LEN
þformat tty O_RDONLY O_WRONLY O_RDWR O_NDELAY O_APPEND O_CREAT O_TRUNC O_EXCL
þformat tty O_BINARY O_TEXT O_NOINHERIT O_SYNC O_SIZE O_NONBLOCK
þformat tty SH_DENYNO SH_DENYRD SH_DENYWR SH_DENYRW
þformat tty F_OK R_OK W_OK X_OK
þformat tty P_WAIT P_NOWAIT P_OVERLAY P_DEBUG P_DETACH _MEMDIF_EQ
þformat tty P_SESSION P_PM P_DEFAULT P_FULLSCREEN P_WINDOWED P_MINIMIZE
þformat tty P_MAXIMIZE P_BACKGROUND P_FOREGROUND P_NOCLOSE P_NOSESSION
þformat tty P_QUOTE P_TILDE P_UNRELATED P_DEBUGDESC
þformat tty NULL USE_OS2_TOOLKIT_HEADERS MAXNAMLEN _MAX_DRIVE _MAX_FNAME
þformat tty  _MAX_EXT _MAX_DIR _MAX_PATH L_cuserid _PASSWORD_LEN MAXPATHLEN
þformat tty RAND_MAX BUFSIZ L_tmpnam P_tmpdir TMP_MAX
þformat tty HUGE_VAL HUGE_VALF HUGE_VALL CHAR_MAX
þformat tty LONG_MIN LONG_MAX ULONG_MAX
þformat tty LONG_LONG_MIN LONG_LONG_MAX ULONG_LONG_MAX
þformat tty EOF CLK_TCK HZ CLOCKS_PER_SEC
þformat tty FP_ZERO FP_SUBNORMAL FP_NORMAL FP_INFINITE FP_NAN DECIMAL_DIG
þformat tty GETOPT_ANY GETOPT_KEEP GETOPT_UNIX
þformat tty WNOHANG WUNTRACED
þformat tty ARG_MAX CHILD_MAX NGROUPS_MAX OPEN_MAX STREAM_MAX
þformat tty TZNAME_MAX LINK_MAX MAX_CANON MAX_INPUT NAME_MAX PATH_MAX
þformat tty PIPE_BUF
þformat tty _POSIX_JOB_CONTROL _POSIX_SAVED_IDS _POSIX_VERSION
þformat tty _POSIX_CHOWN_RESTRICTED _POSIX_NO_TRUNC _POSIX_VDISABLE
þformat tty _SC_ARG_MAX _SC_CHILD_MAX _SC_CLK_TCK _SC_NGROUPS_MAX
þformat tty _SC_OPEN_MAX _SC_STREAM_MAX _SC_TZNAME_MAX _SC_JOB_CONTROL
þformat tty _SC_SAVED_IDS _SC_VERSION
þformat tty _PC_LINK_MAX _PC_MAX_CANON _PC_MAX_INPUT _PC_NAME_MAX
þformat tty _PC_PATH_MAX _PC_PIPE_BUF _PC_CHOWN_RESTRICTED _PC_NO_TRUNC
þformat tty _PC_VDISABLE
þformat tty FNM_NOMATCH _FNM_MATCH _FNM_ERR
þformat tty FNM_NOESCAPE FNM_PATHNAME FNM_PERIOD _FNM_POSIX
þformat tty _FNM_OS2 _FNM_DOS _FNM_IGNORECASE _FNM_PATHPREFIX
þformat tty GLOB_APPEND GLOB_DOOFFS GLOB_ERR GLOB_MARK GLOB_NOESCAPE
þformat tty GLOB_NOCHECK GLOB_NOSORT GLOB_PERIOD
þformat tty GLOB_ABEND GLOB_NOMATCH GLOB_NOSPACE
þformat tty S_IREAD S_IWRITE S_IEXEC S_IFCHR S_ISCHR FD_SET FD_SETSIZE
þformat tty IDEFAULT IDELETE IGNCR ISTRIP INLCR ICANON ISIG IUCLC ICRNL
þformat tty ECHO ECHOK
þformat tty VINTR VQUIT VERASE VEOF VKILL VEOL VMIN VTIME VSUSP VSTOP VSTART
þformat tty TCIOFF TCION TCOOFF TCOON TCIFLUSH TCIOFLUSH TCOFLUSH
þformat tty TCSANOW TCSADRAIN TCSAFLUSH
þformat tty SIG_DFL SIG_IGN SIG_ERR SIG_ACK SIGABRT SIGALRM SIGBREAK SIGFPE
þformat tty SIGILL SIGINT SIGPIPE SIGSEGV SIGCHLD SIGCLD SIGKILL SIGTERM
þformat tty SIGQUIT SIGTRAP SIGEMT SIGBUS SIGSYS SIGUSR1 SIGUSR2 SIGHUP
þformat tty SIGPTRACENOTIFY SIGWINCH
þformat tty SA_NOCLDSTOP SA_SYSV SA_ACK SIG_BLOCK SIG_UNBLOCK SIG_SETMASK
þformat tty TCGETA TCSETA TCSETAF TCSETAW TCFLSH TCSBRK TCXONC
þformat tty FIONREAD FGETHTYPE
þformat tty F_GETFL F_SETFL F_GETFD F_SETFD F_DUPFD FD_CLOEXEC
þformat tty OS2_MODE DOS_MODE SEEK_SET SEEK_CUR SEEK_END HT_FILE
þformat tty EPERM ENOENT ESRCH EINTR EIO E2BIG ENOEXEC EBADF ECHILD
þformat tty EAGAIN ENOMEM EACCES EEXIST EXDEV ENOTDIR EISDIR EINVAL
þformat tty EMFILE ENOTTY ENOSPC ESPIPE EROFS EPIPE EDOM ERANGE ENOSYS
þformat tty ENAMETOOLONG EWOULDBLOCK
þformat tty LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY LC_NUMERIC LC_TIME
þformat tty G_OUTLINE G_FILL G_MODE_OFF G_MODE_EGA_C G_MODE_EGA_E
þformat tty G_MODE_VGA_H G_MODE_VGA_L G_SET_KEEP
þformat tty _HEAPBADBEGIN _HEAPBADNODE _HEAPEMPTY _HEAPOK _HEAPBADEND
þformat tty _BLOCK_CLEAN _HEAP_REGULAR _HEAP_TILED _HEAP_SHARED _HEAP_MIN_SIZE
þformat tty _RUNTIME_HEAP _FORCE _FREEENTRY _USEDENTRY
þformat tty FTW_D FTW_F FTW_NS FTW_DNR _IONBF _IOFBF _IOLBF
þformat tty PTRACE_TRACEME PTRACE_PEEKTEXT PTRACE_PEEKDATA PTRACE_PEEKUSER
þformat tty PTRACE_POKETEXT PTRACE_POKEDATA PTRACE_POKEUSER PTRACE_RESUME
þformat tty PTRACE_EXIT PTRACE_STEP PTRACE_SESSION PTRACE_NOTIFICATION
þformat tty PTRACE_CONT PTRACE_THAW PTRACE_FREEZE PTRACE_ATTACH PTRACE_DETACH
þformat tty PTRACE_GETPID PTRACE_GETTID PTRACE_PIDTID
þformat tty PTN_NONE PTN_THREAD_NEW PTN_THREAD_END PTN_MODULE_LOAD
þformat tty PTN_MODULE_FREE PTN_PROC_NEW
þformat tty PTNMOD_DLL PTNMOD_AOUT PTNPROC_FORK PTNPROC_AOUT
þformat tty MCW_EM MCW_IC MCW_RC MCW_PC EM_INVALID EM_DENORMAL EM_ZERODIVIDE
þformat tty EM_OVERFLOW EM_UNDERFLOW EM_INEXACT RC_NEAR RC_DOWN
þformat tty RC_UP RC_CHOP PC_24 PC_53 PC_64
þformat tty V_MONOCHROME V_COLOR_8 V_COLOR_12 BLINK INTENSITY
þformat tty V_SCROLL_UP V_SCROLL_DOWN V_SCROLL_CLEAR
þformat tty UL_GFILLIM UL_SFILLIM UL_GMEMLIM UL_NOFILES UL_OBJREST
þformat tty _UF_SIG_MODEL _UF_SIG_EMX _UF_SIG_SYSV _UF_SIG_BSD
þformat tty _UF_SBRK_MODEL _UF_SBRK_CONTIGUOUS _UF_SBRK_MONOTONOUS
þformat tty _UF_SBRK_ARBITRARY
þformat tty _UF_PTRACE_MODEL _UF_PTRACE_STANDARD _UF_PTRACE_NOTIFY
þformat tty _UF_PTRACE_MULTITHREAD
þformat tty _EAD_MERGE NDEBUG _FMC_SHARED _FMR_IGNINT _FMR_NOWAIT
þformat tty _MD_BASE _MD_CODE _MD_DATA _MD_DESCRIPTION _MD_EXETYPE _MD_EXPORTS
þformat tty _MD_HEAPSIZE _MD_IMPORTS _MD_LIBRARY _MD_NAME _MD_OLD _MD_PHYSICAL
þformat tty _MD_PROTMODE _MD_REALMODE _MD_SEGMENTS _MD_STACKSIZE _MD_STUB
þformat tty _MD_VIRTUAL
þformat tty _MD_eof _MD_dot _MD_at _MD_equal _MD_number _MD_word
þformat tty _MD_quote _MD_ioerror _MD_missingquote _MD_parseerror
þformat tty _MDE_IO_ERROR _MDE_MISSING_QUOTE _MDE_EMPTY _MDE_NAME_EXPECTED
þformat tty _MDE_STRING_EXPECTED _MDE_NUMBER_EXPECTED _MDE_DEVICE_EXPECTED
þformat tty _MDE_EQUAL_EXPECTED _MDE_DOT_EXPECTED _MDE_STRING_TOO_LONG
þformat tty _MDE_INVALID_ORDINAL _MDE_INVALID_STMT
þformat tty _MDEP_ORDINAL _MDEP_RESIDENTNAME _MDEP_NONAME _MDEP_NODATA
þformat tty _MDEP_PWORDS _MDIP_ORDINAL _MDIT_DEFAULT _MDIT_INSTANCE
þformat tty _MDIT_GLOBAL _MDS_IOPL _MDS_MULTIPLE _MDS_SHARED _MDT_DEFAULT
þformat tty _MDT_WINDOWAPI _MDT_WINDOWCOMPAT _MDT_NOTWINDOWCOMPAT
þformat tty _MDX_OS2 _MDX_WINDOWS

þformat tty c_lflag c_oflag c_cflag c_cc c_line st_dev st_rdev st_ino umask
þformat tty dstflag millitm time_t errno quot rem tms_utime
þformat tty tm_hour tm_mday tm_min tm_mon tm_sec tm_year tm_wday
þformat tty tm_yday tm_isdst gl_pathc gl_pathv gl_offs
þformat tty sa_handler sa_mask sa_flags

þformat tty getch() getche()
þformat tty __open() DosAllocMem DosAllocSharedMem DosCreateThread DosFreeMem
þformat tty DosGetMessage DosGetNamedSharedMem DosGetSharedMem
þformat tty DosGiveSharedMem DosQueryMessageCP DosExit
þformat tty DosExecPgm DosSleep DosStartSession DosExitList DosOpen DosRead
þformat tty DosResetBuffer
þformat tty HMTX
þformat tty ERROR_INVALID_HANDLE ERROR_INTERRUPT ERROR_TOO_MANY_HANDLES
þformat tty ERROR_MUTEX_OWNED ERROR_ACCESS_DENIED ERROR_FILE_EXISTS

þformat tty _ea _ead fd_set ino_t wm_handle _dt_tree _far16ptr _dt_node
þformat tty FEA2LIST FEALIST PFEA2LIST PFEALIST REGS
þformat tty optarg opterr optind optopt optswchar optmode
þformat tty _nls_tolower_tab _nls_toupper_tab _nls_ctype_tab
þformat tty sys_errlist sys_nerr _emx_rev environ g_xsize g_ysize g_colors
þformat tty _osmajor _osminor _osmode tzname stdin stdout stderr
þformat tty _fmutex _rmutex _smutex Heap_t _HEAPSTATS

þformat tty BASE CODE DATA DESCRIPTION EXETYPE EXPORTS HEAPSIZE IMPORTS
þformat tty LIBRARY NAME OLD PROTMODE REALMODE SEGMENTS STACKSIZE STUB
þformat tty PHYSICAL VIRTUAL DEVICE
þformat tty WINDOWS RESIDENTNAME NODATA NONAME MAXVAL NEWFILES NONE

þformat abbrev etc.

þif text
þh= Table of Contents
þtoc
þendif

þh1 Introduction to the emx C Library Reference
þipf
:font facename=Helv size=24x14.:hp2.emx 0.9d C Library Reference
:ehp2.
:p.
:font facename=Helv size=16x10.      Copyright (c) 1990-1998 by Eberhard Mattes
:font facename=default size=0x0.
:p.
þendipf

þipfminitoc

þh2 Preliminary notes

þitemize
þitem

  `C90' is short for ISO 9899-1990, the ANSI/ISO standard for the C
  programming language

þitem

  `C9X' is short for the upcoming version of ISO 9899

þitem

  Not all functions declared in the headers are implemented.

þitem

  By default, text mode is used for files.  See þhpt{fread()} and
  þhpt{fwrite()} for details.  The default can be globally changed to
  binary mode by linking with binmode.o or binmode.obj
  (þhpt{-Zbin-files} option of GCC).

þitem

  See the description of þhpt{g_mode()} for general information about
  the graphics library.

þitem

  See the description of þhpt{v_init()} for general information about
  the video library.

þitem

  See the description of þhpt{wm_init()} for general information about
  the window manager functions.

þenditemize


þh2 Libraries

  The following emx libraries are provided:

þlist
þitem þtt{st/c}

    The single-thread C library.  This library includes the ISO C
    library functions, Unix extensions and emx extensions.  Only
    functions are included which are common to all types of
    applications and DLLs.  See also c_app, c_dllnrt, c_dllrt, and
    c_dllso.

þitem þtt{mt/c}

    The multithread C library.  See library þtt{st/c}.  This library
    is used instead of library þtt{st/c} if the þhpt{-Zmt} or
    þhpt{-Zmts} option is specified.

þitem c_alias

    Aliases for non-ISO-C symbols.  This library maps, for
    instance, þtt{eof()} to þtt{_eof()}.  The static and dynamic C
    libraries contain these symbols with one underscore prepended to
    the names.  In consequence, redefining a non-ISO-C library
    function should be possible even if the C library uses the
    function internally.  (c_alias has not been merged into the
    static, dynamic, and import libraries due to restrictions in
    LINK386, þbf{ar}, and þhpt{emxomfar}.)

þitem þtt{st/c_app}

    This library is used in addition to þtt{st/c} for building a
    single-thread statically linked application.

þitem þtt{st/c_app_p}

    Like library þtt{st/c_app}, with profiling hooks.  This library is
    used instead of library þtt{st/c_app} if the -pg option is
    specified.

þitem þtt{mt/c_app}

    This library is used in addition to þtt{st/c} for building a
    multithread statically linked application.

þitem þtt{c_dllrt}

    This library is used in addition to þtt{st/c} for building a
    DLL without runtime environment.

þitem þtt{st/c_dllrt}

    This library is used in addition to þtt{st/c} for building a
    single-thread custom C runtime DLL.

þitem þtt{mt/c_dllrt}

    This library is used in addition to þtt{mt/c} for building a
    multithread custom C runtime DLL.

þitem þtt{st/c_dllso}

    This library is used in addition to þtt{mt/c} for building a
    single-thread stand-alone DLL.  Such a DLL has its own runtime
    environment.

þitem þtt{mt/c_dllso}

    This library is used in addition to þtt{mt/c} for building a
    multithread stand-alone DLL.  Such a DLL has its own runtime
    environment.

þitem þtt{st/c_import}

    Import library for emxlibcs.dll.  This library is used instead of
    libraries þtt{c}, c_app, and þtt{gcc} if the þhpt{-Zcrtdll} option
    without the þhpt{-Zmt} option is specified.

þitem þtt{mt/c_import}

    Import library for emxlibcm.dll.  This library is used instead of
    libraries þtt{c}, c_app, and þtt{gcc} if the þhpt{-Zcrtdll} and
    þhpt{-Zmt} options (or þhpt{-Zmtd}) are specified.

þitem þtt{st/c_p}

    The single-thread C library, with profiling hooks.  See library
    þtt{st/c}.  This library is used instead of library þtt{st/c} if
    the -pg option is specified.

þitem c_static

    Code which must be statically linked when linking the C library
    dynamically.  This library is searched if the þhpt{-Zcrtdll}
    option of GCC is specified.

þitem þtt{st/emx}

    System call interface to emx for single-thread programs.  For
    instance, this library translates the __open() system call to
    system call 0x2b of emx.  When using this library, emx.dll is
    required under OS/2.  This library is always required for DOS
    programs.

þitem þtt{mt/emx}

    System call interface to emx for multithread programs.  For
    instance, this library translates the __open() system call to
    system call 0x2b of emx.  When using this library, emx.dll is
    required.

þitem emx2

    Import library for emx.dll.  This library is used by libraries
    emx.a, emx.lib, os2.a, and os2.lib (unless sys.lib is used, see
    þhpt{-Zsys}).

þitem emxio

    Import library for emxio.dll.  When using hardware port I/O
    functions such as þhpt{_outp8()} with non-standard libraries, you
    may have to use this library.  With the standard emx libraries,
    -lemxio is not required.  -lemxio must not be used if the program
    should also run under DOS.

þitem þtt{end.lib}

    Library defining the þtt{edata}, þtt{end}, and þtt{etext} symbols.
    ld automatically defines these symbols, therefore there is no
    þtt{end.a} library.  GCC uses þtt{-lend} if -Zomf is given on the
    command line.

þitem þtt{g}

    Dummy debugging library.  GCC uses -lg if -g is given on the
    command line.

þitem þtt{gcc}

    Compiler helper functions for GCC.  The functions of library
    þtt{gcc} are duplicated in emxlibcm.dll and emxlibcs.dll.  As
    library þtt{gcc} requires functions from library þtt{c} and
    library þtt{c} requires functions from library þtt{gcc}, -lgcc
    must be given twice on the command line of the Unix-style linker:
    -lgcc -lc -lgcc.

þitem þtt{gcc_p}

    Compiler helper functions for GCC, with profiling hooks.  See
    library þtt{gcc}.  This library is used instead of library
    þtt{gcc} if the -pg option is specified.

þitem þtt{graph}

    Graphics library

þitem þtt{m}

    Dummy math library.  This library is provided for makefile
    compatibility; it isn't required as the math functions are
    contained in library þtt{c}.

þitem þtt{st/malloc1}

    Old malloc() library of emx 0.9b and older, single-thread.  This
    library is provided as fall back in case the new malloc()
    implementation turns out not to work properly.

þitem þtt{mt/malloc1}

    Old malloc() library of emx 0.9b and older, multithread.  This
    library is provided as fall back in case the new malloc()
    implementation turns out not to work properly.

þitem moddef

    Functions for reading module definition files.  See
    þhpt{_md_open()} for details.  This library can be used for
    single-thread programs and multithread programs.

þitem þtt{omflib}

    Functions for reading and creating OMF (Object Module Formats)
    libraries, that is, þtt{.lib} files.

þitem þtt{os2}

    Import library for OS/2 API.  This library is not a pure import
    library, it also contains static code for DosGetMessage and
    DosQueryMessageCP and for the 32-bit wrappers.  emx2.a, emx2.lib,
    or sys.lib is required by the 32-bit wrappers.

þitem þtt{os2_p}

    Profiling hooks and import definitions for OS/2 API.  See library
    þtt{os2}.  This library is used instead of library þtt{os2} if the
    -pg option is specified.

þitem þtt{socket}

    Socket library.

þitem þtt{st/sys}

    System call emulation library for single-thread programs.  This
    library is used instead of emx.a or emx.lib for creating
    stand-alone OS/2 applications (þhpt{-Zsys}).  It is provided in
    OMF style only (þtt{st/sys.lib}).

þitem þtt{mt/sys}

    Multithread version of þtt{st/sys} (see above).  This library is
    provided in OMF style only (þtt{mt/sys.lib}).  It is used instead
    of þtt{st/sys.lib} if the þhpt{-Zmt} option is specified.

þitem þtt{tmalloc}

    Implement þhpt{_tmalloc()} etc. on top of malloc() etc.  This
    library is required if you replace the emx implementation of
    malloc() with an implementation of malloc() (GNU malloc, for
    instance) that has not _tmalloc() built in.

þitem þtt{video}

    Video library.  This library contains the functions declared in
    <sys/video.h> and <sys/winmgr.h>.

þitem þtt{wrap}

    Import library for emxwrap.dll.  Use this library (-lwrap) to
    reduce the size of your executable file when using 16-bit OS/2 API
    functions.  If you don't use -lwrap, the wrapper functions are
    taken from library þtt{os2}.

þendlist

þh- The following dynamic link libraries are provided:

þlist

þitem emx.dll

    This is the emx run-time support.  The import library for emx.dll
    is emx2.

þitem emxio.dll

    Access to hardware ports.  The import library for emxio.dll is
    emxio.

þitem emxlibc.dll

    Forwarder DLL.  This DLL is provided to maintain compatibility of
    existing applications using emxlibc.dll.  Entry points are
    forwarded to emxlibcm.dll.

þitem emxlibcm.dll

    Multithread emx C library.  Contains all functions of the
    libraries þtt{mt/c}, þtt{mt/c_dllrt}, and þtt{gcc}.  For
    compatibility with existing programs, emxlibcm.dll contains dummy
    functions for port I/O, though these didn't work in emxlibc.dll of
    emx 0.8e.  The import library for emxlibcm.dll is
    þtt{mt/c_import}.

þitem emxlibcs.dll

    Single-thread emx C library.  Contains all functions of the
    libraries þtt{st/c}, þtt{st/c_dllrt}, and þtt{gcc}.  The import
    library for emxlibcs.dll is þtt{st/c_import}.

þitem emxwrap.dll

    32-bit wrappers for 16-bit OS/2 API functions.  This DLL uses
    emx.dll.  The import library for emxwrap.dll is þtt{wrap}.  The
    functions contained in emxwrap.dll are also available for static
    linking in library þtt{os2}.

þendlist


þh2 Headers

  This section briefly describes the headers.

þlist

þitem <a_out.h>

    Contains definitions for the a.out file format (.o and executable
    files).

þitem <alloca.h>

    Makes the þhpt{alloca()} built-in function available.

þitem <ar.h>

    Contains definitions for the archive file format (.a files).

þitem <assert.h>

    Implements assertions for debugging (C90): þhpt{assert()}.

þitem <conio.h>

    Defines getch() and getche() for porting MS-DOS programs.

þitem <ctype.h>

    Character classification macros and functions.  Letter case
    conversion.  If you include this header, you get the macro
    (and inline) versions of the routines.  Otherwise, you get the
    function versions.

    C90 functions and macros: þhpt{isalnum()}, þhpt{isalpha()},
    þhpt{iscntrl()}, þhpt{isdigit()}, þhpt{isgraph()},
    þhpt{islower()}, þhpt{isprint()}, þhpt{ispunct()},
    þhpt{isspace()}, þhpt{isupper()}, þhpt{isxdigit()},
    þhpt{tolower()}, þhpt{toupper()}.

    Additional functions and macros: þhpt{isascii()},
    þhpt{_tolower()}, þhpt{_toupper()}.

þitem <curses.h>

    Declarations and definitions of the BSD curses screen library.

þitem <dirent.h>

    Functions for reading directories.

    POSIX.1 functions: þhpt{closedir()}, þhpt{opendir()},
    þhpt{readdir()}, þhpt{rewinddir()}.

    Additional functions: þhpt{seekdir()}, þhpt{telldir()}.

þitem <dos.h>

    Declares the þhpt{_int86()} function and associated structures.

þitem <errno.h>

    Declares the þhpt{errno} object and defines error code constants
    (C90).

þitem <fcntl.h>

    Defines file mode constants such as O_RDONLY and other constants.
    Declares the þhpt{fcntl()} and þhpt{flock()} functions.  Includes
    <sys/fcntl.h>.

þitem <float.h>

    Floating point constants and functions for controlling the math
    coprocessor (C90).

    Non-standard functions: þhpt{_clear87()}, þhpt{_control87()},
    þhpt{_fpreset()}, þhpt{_status87()}.

þitem <fnmatch.h>

    Declares the þhpt{fnmatch()} function and defines constants for
    fnmatch() (POSIX.2).

þitem <ftw.h>

    File tree walk: þhpt{ftw()}.  Apply a function to all files in a
    directory tree.

þitem <getopt.h>

    Declares þhpt{getopt()} for parsing command line options
    (POSIX.2).

þitem <glob.h>

    Declares the þhpt{glob()} and þhpt{globfree()} functions and
    defines the glob_t type and constants for glob() (POSIX.2).

þitem <graph.h>

    Declares the emx graphics library functions and defines associated
    constants.

    Functions: þhpt{g_box()}, þhpt{g_clear()}, þhpt{g_clip()},
    þhpt{g_ellipse()}, þhpt{g_get()}, þhpt{g_hline()}, þhpt{g_line()},
    þhpt{g_lock()}, þhpt{g_mode()}, þhpt{g_modeset()},
    þhpt{g_polygon()}, þhpt{g_set()}, þhpt{g_triangle()},
    þhpt{g_unlock()}, þhpt{g_unlockall()}, þhpt{g_vgapal()},
    þhpt{g_vline()}, þhpt{g_waitv()}, þhpt{g_wmode()}.

þitem <grp.h>

    Declares the þtt{getgrgid()} and þtt{getgrnam()} functions and
    defines þtt{struct group} (POSIX.1).

þitem <ieee.h>

    Constants describing the IEEE floating point format used under emx.

þitem <io.h>

    Declares low-level I/O functions.

    Functions: þhpt{access()}, þhpt{chmod()}, þhpt{chsize()},
    þhpt{close()}, þhpt{creat()}, þhpt{_crlf()}, þhpt{dup()},
    þhpt{dup2()}, þhpt{eof()}, þhpt{filelength()}, þhpt{fstat()},
    þhpt{fsync()}, þhpt{ftruncate()}, þhpt{_imphandle()},
    þhpt{ioctl()}, þhpt{isatty()}, þhpt{_isterm()}, þhpt{lseek()},
    þhpt{mkstemp()}, þhpt{mktemp()}, þhpt{open()}, þhpt{pipe()},
    þhpt{read()}, þhpt{remove()}, þhpt{rename()}, þhpt{_seek_hdr()},
    þhpt{select()}, þhpt{setmode()}, þhpt{sopen()}, þhpt{stat()},
    þhpt{tell()}, þhpt{truncate()}, þhpt{umask()}, þhpt{unlink()},
    þhpt{write()}.

þitem <limits.h>

    Data type limit constants (C90).

þitem <locale.h>

    Functions and constants for localization.

    C90 functions: þhpt{localeconv()}, þhpt{setlocale()}.

þitem <malloc.h>

    Declares functions for dynamic memory allocation.  For
    portability, use <stdlib.h> instead of <malloc.h>.

    C90 functions (note that <malloc.h> is not a C90 header):
    þhpt{calloc()}, þhpt{free()}, þhpt{malloc()}, þhpt{realloc()}.

    Functions for allocating tiled memory: þhpt{_tcalloc()},
    þhpt{_tfree()}, þhpt{_tmalloc()}, þhpt{_trealloc()}.

    Additional non-standard functions: þhpt{_expand()},
    þhpt{_heapchk()}, þhpt{_heapmin()}, þhpt{_heapset()},
    þhpt{_msize()}.

þitem <math.h>

    Declares floating-point functions.

    C90 functions: þhpt{acos()}, þhpt{asin()}, þhpt{atan()},
    þhpt{atan2()}, þhpt{ceil()}, þhpt{cos()}, þhpt{cosh()},
    þhpt{exp()}, þhpt{fabs()}, þhpt{floor()}, þhpt{fmod()},
    þhpt{frexp()}, þhpt{ldexp()}, þhpt{log()}, þhpt{log10()},
    þhpt{modf()}, þhpt{pow()}, þhpt{sin()}, þhpt{sinh()},
    þhpt{sqrt()}, þhpt{tan()}, þhpt{tanh()}.

    Functions proposed for C9X: þhpt{acosl()}, þhpt{asinl()},
    þhpt{atanl()}, þhpt{atan2l()}, þhpt{ceill()}, þhpt{copysign()},
    þhpt{copysignf()}, þhpt{copysignl()}, þhpt{cosl()}, þhpt{coshl()},
    þhpt{expl()}, þhpt{fabsl()}, þhpt{floorl()}, þhpt{fmodl()},
    þhpt{frexpl()}, þhpt{hypot()}, þhpt{hypotl()}, þhpt{ldexpl()},
    þhpt{logl()}, þhpt{log10l()}, þhpt{modfl()}, þhpt{nextafter()},
    þhpt{nextafterf()}, þhpt{nextafterl()}, þhpt{powl()},
    þhpt{rint()}, þhpt{rintl()}, þhpt{sinl()}, þhpt{sinhl()},
    þhpt{sqrtl()}, þhpt{tanl()}, þhpt{tanhl()}, þhpt{trunc()},
    þhpt{truncl()}.

    Macros proposed for C9X: þhpt{fpclassify()}, þhpt{isfinite()},
    þhpt{isnan()}, þhpt{isnormal()}, þhpt{signbit()}.

    Other functions: þhpt{atof()}, þhpt{_atofl()}, þhpt{cbrt()},
    þhpt{_cbrtl()}.

þitem <memory.h>

    Declares functions dealing with blocks of memory.  New programs
    should use <string.h> instead.

    Functions: þhpt{memccpy()}, þhpt{memchr()}, þhpt{memcmp()},
    þhpt{_memcount()}, þhpt{memcpy()}, þhpt{_memdif()},
    þhpt{memicmp()}, þhpt{memmove()}, þhpt{_memrchr()},
    þhpt{memset()}, þhpt{_memswap()}.

þitem <os2.h>

    Include this header to get all or part of the OS/2 constants,
    macros and functions.  Includes either <os2emx.h> or <os2tk.h>.
    Either change <os2.h> or #define USE_OS2_TOOLKIT_HEADERS in your
    source file to use the header files of the Programmer's Toolkit
    for OS/2 2.x (an IBM product).

þitem <os2emx.h>

    A subset of the OS/2 definitions and declarations.  This header
    file is included by <os2.h> unless you choose to use the header
    files of the Programmer's Toolkit for OS/2 2.x (an IBM product).

þitem <os2thunk.h>

    Thunking support, included by <os2.h>.  You don't have to include
    this header in your programs unless you want to create thunks
    without including <os2.h>.

þitem <os2tk.h>

    Makes the header files of the Developer's Toolkit for OS/2 2.x
    usable for emx and GCC.

þitem <process.h>

    Process management.  Includes <sys/process.h>.

    Functions: þhpt{abort()}, þhpt{atexit()}, þhpt{execl()},
    þhpt{execle()}, þhpt{execlp()}, þhpt{execlpe()}, þhpt{execv()},
    þhpt{execve()}, þhpt{execvp()}, þhpt{execvpe()}, þhpt{exit()},
    þhpt{_exit()}, þhpt{fork()}, þhpt{getpid()}, þhpt{getppid()},
    þhpt{spawnl()}, þhpt{spawnle()}, þhpt{spawnlp()},
    þhpt{spawnlpe()}, þhpt{spawnv()}, þhpt{spawnve()},
    þhpt{spawnvp()}, þhpt{spawnvpe()}, þhpt{system()}, þhpt{wait()},
    hpt{waitpid()}.

þitem <pwd.h>

    Password management.

    POSIX.1 functions: þhpt{getpwnam()}, þhpt{getpwuid()}.

    Additional functions: þhpt{endpwent()}, þhpt{getpass()},
    þhpt{_getpass1()}, þhpt{_getpass2()}, þhpt{getpwent()},
    þhpt{setpwent()}.

þitem <setjmp.h>

    Non-local jumps.  Defines jmp_buf and sigjmp_buf.

    C90 functions: þhpt{longjmp()}, þhpt{setjmp()}.

    POSIX.1 functions: þhpt{siglongjmp()}, þhpt{sigsetjmp()}.

þitem <sgtty.h>

    Empty file.  emx doesn't have a BSD-style general terminal interface.

þitem <share.h>

    Constants for file sharing.

þitem <signal.h>

    Signal processing.  Includes <sys/signal.h>.

    C90 functions: þhpt{signal()}, þhpt{raise()}.

    POSIX.1 functions: þhpt{kill()}, þhpt{pause()}, þhpt{sigaction()},
    þhpt{sigaddset()}, þhpt{sigdelset()}, þhpt{sigemptyset()},
    þhpt{sigfillset()}, þhpt{sigismember()}, þhpt{sigpending()},
    þhpt{sigprocmask()}, þhpt{sigsuspend()}.

þitem <stdarg.h>

    Macros to implement functions with variable number of arguments --
    ISO C version.

    C90 macros: þhpt{va_start()}, þhpt{va_arg()}, þhpt{va_end()}.

þitem <stddef.h>

    Various definitions.

    C90 macros: þhpt{offsetof()}.

    Other macros: þhpt{_threadid}.

þitem <stdio.h>

    Stream I/O library.

    C90 functions: þhpt{clearerr()}, þhpt{fclose()},
    þhpt{feof()}, þhpt{ferror()}, þhpt{fflush()}, þhpt{fgetc()},
    þhpt{fgetpos()}, þhpt{fgets()}, þhpt{fopen()}, þhpt{fprintf()},
    þhpt{fputc()}, þhpt{fputs()}, þhpt{fread()}, þhpt{freopen()},
    þhpt{fscanf()}, þhpt{fseek()}, þhpt{fsetpos()}, þhpt{ftell()},
    þhpt{fwrite()}, þhpt{getc()}, þhpt{getchar()}, þhpt{gets()},
    þhpt{perror()}, þhpt{printf()}, þhpt{putc()}, þhpt{putchar()},
    þhpt{puts()}, þhpt{remove()}, þhpt{rename()}, þhpt{rewind()},
    þhpt{scanf()}, þhpt{setbuf()}, þhpt{setvbuf()}, þhpt{sprintf()},
    þhpt{sscanf()}, þhpt{tmpfile()}, þhpt{tmpnam()}, þhpt{ungetc()},
    þhpt{vfprintf()}, þhpt{vprintf()}, þhpt{vsprintf()}.

    POSIX.1 functions: þhpt{fdopen()}, þhpt{fileno()}.

    POSIX.2 functions: þhpt{pclose()}, þhpt{popen()}.

    Additional functions: þhpt{cuserid()}, þhpt{_fassign()},
    þhpt{fcloseall()}, þhpt{fgetchar()}, þhpt{flushall()},
    þhpt{fputchar()}, þhpt{_fseek_hdr()}, þhpt{_fsetmode()},
    þhpt{_fsopen()}, þhpt{getw()}, þhpt{_mfclose()}, þhpt{_mfopen()},
    þhpt{putw()}, þhpt{setbuffer()}, þhpt{snprintf()},
    þhpt{tempnam()}, þhpt{vfscanf()}, þhpt{vscanf()},
    þhpt{vsnprintf()}, þhpt{vsscanf()}.

þitem <stdlib.h>

    Various library functions and global variables.  Includes <malloc.h>.

    C90 string conversion functons: þhpt{atof()}, þhpt{atoi()},
    þhpt{atol()}, þhpt{strtod()}, þhpt{strtol()}, þhpt{strtoul()}.

    C90 functions for generating pseudo-random sequences:
    þhpt{rand()}, þhpt{srand()}.

    C90 memory management functions: þhpt{calloc()}, þhpt{free()},
    þhpt{malloc()}, þhpt{realloc()}.

    C90 functions for searching and sorting: þhpt{bsearch()},
    þhpt{qsort()}.

    C90 integer arithmetic functions: þhpt{abs()}, þhpt{div()},
    þhpt{labs()}, þhpt{ldiv()}.

    C90 multibyte character functions: þhpt{mblen()},
    þhpt{mbstowcs()}, þhpt{mbtowc()}, þhpt{wcstombs()},
    þhpt{wctomb()}.

    Other C90 functions: þhpt{abort()}, þhpt{atexit()}, þhpt{exit()},
    þhpt{getenv()}, þhpt{system()}.

    String conversion functions proposed for C9X: þhpt{strtof()},
    þhpt{strtold()}.

    Additional string conversion functions (to and from strings):
    þhpt{_atofl()}, þhpt{_atoll()}, þhpt{gcvt()}, þhpt{_itoa()},
    þhpt{_lltoa()}, þhpt{_ltoa()}, þhpt{_strtoll()},
    þhpt{_strtoull()}, þhpt{_ulltoa()}, þhpt{_ultoa()}.

    Additional functions for generating pseudo-random sequences:
    þtt{initstate()}, þtt{random()}, þtt{setstate()}, þtt{srandom()}.

    Additional memory management functions: þhpt{brk()},
    þhpt{_expand()}, þhpt{_heapchk()}, þhpt{_heapmin()},
    þhpt{_heapset()}, þhpt{_msize()}, þhpt{sbrk()}.

    Additional functions for allocating tiled memory:
    þhpt{_tcalloc()}, þhpt{_tfree()}, þhpt{_tmalloc()},
    þhpt{_trealloc()}.

    Additional functions for searching and sorting: þtt{heapsort()}.

    Additional integer arithmetic functions: þhpt{_lldiv()},
    þhpt{_uldiv()}, þhpt{_ulldiv()}.

    Additional functions for managing directories and disk drives:
    þhpt{chdir()}, þhpt{_chdir2()}, þhpt{_chdrive()},
    þhpt{_filesys()}, þhpt{getcwd()}, þhpt{_getcwd1()},
    þhpt{_getcwd2()}, þhpt{_getvol()}, þhpt{getwd()}, þhpt{mkdir()},
    þhpt{rmdir()}.

    Additional functions for processing file names: þhpt{_abspath()},
    þhpt{_defext()}, þhpt{_fncmp()}, þhpt{_fnexplode()},
    þhpt{_fnexplodefree()}, þhpt{_fngetdrive()}, þhpt{_fnisabs()},
    þhpt{_fnisrel()}, þhpt{_fnlwr()}, þhpt{_fnlwr2()},
    þhpt{_fnslashify()}, þhpt{_fullpath()}, þhpt{_getdrive()},
    þhpt{_getext()}, þhpt{_getext2()}, þhpt{_getname()},
    þhpt{_makepath()}, þhpt{_path()}, þhpt{_remext()},
    þhpt{_rfnlwr()}, þhpt{_sfnlwr()}, þhpt{_splitpath()}.

    Additional functions for multithread programs:
    þhpt{_beginthread()}, þhpt{_endthread()}, þhpt{_gettid()},
    þhpt{_threadstore()}.

    Additional functions for managing the command line:
    þhpt{_envargs()}, þhpt{_response()}, þhpt{_wildcard()}.

    Miscellaneous additional functions: þhpt{alarm()}, þhpt{_core()},
    þhpt{_execname()}, þhpt{_exit()}, þhpt{getpagesize()},
    þhpt{_getsockhandle()}, þhpt{perror()}, þhpt{putenv()},
    þhpt{_read_kbd()}, þhpt{_scrsize()}, þhpt{_searchenv()},
    þhpt{_setsyserrno()}, þhpt{sleep()}, þhpt{_sleep2()},
    þhpt{_splitargs()}, þhpt{swab()}, þhpt{_swchar()},
    þhpt{_syserrno()}, þhpt{ulimit()}.

þitem <string.h>

    This header declares functions for processing null-terminated
    strings and for processing arrays of characters and objects
    treated as arrays of characters.

    C90 functions for processing null-terminated strings:
    þhpt{strcat()}, þhpt{strchr()}, þhpt{strcmp()}, þhpt{strcoll()},
    þhpt{strcpy()}, þhpt{strcspn()}, þhpt{strerror()}, þhpt{strlen()},
    þhpt{strncat()}, þhpt{strncmp()}, þhpt{strncpy()},
    þhpt{strpbrk()}, þhpt{strrchr()}, þhpt{strspn()}, þhpt{strstr()},
    þhpt{strtok()}, þhpt{strxfrm()}.

    C90 functions for processing arrays of characters:
    þhpt{memchr()}, þhpt{memcmp()}, þhpt{memcpy()}, þhpt{memmove()},
    þhpt{memset()}.

    Non-standard functions for processing null-terminated strings:
    þhpt{strdup()}, þhpt{stricmp()}, þhpt{strlwr()}, þhpt{_strncpy()},
    þhpt{strnicmp()}, þhpt{strnset()}, þhpt{strrev()}, þtt{strsep()},
    þhpt{strset()}, þhpt{strupr()}.

    Non-standard functions for processing arrays of characters:
    þhpt{memccpy()}, þhpt{_memcount()}, þhpt{_memdif()},
    þhpt{memicmp()}, þhpt{_memrchr()}, þhpt{_memswap()}.

þitem <strings.h>

    This header defines the BSD string and memory functions and
    includes <string.h>.

    BSD functions: þhpt{bcmp()}, þhpt{bcopy()}, þhpt{bzero()},
    þhpt{ffs()}, þhpt{index()}, þhpt{rindex()}.

þitem <termcap.h>

    Terminal data base (FSF).

þitem <termio.h>

    Defines þtt{struct termio} and constants for the þhpt{general
    terminal interface} (System V variant).  Includes <sys/termio.h>.

þitem <termios.h>

    Declares functions and defines þtt{struct termios} and constants
    for the þhpt{general terminal interface} (POSIX.1 variant).

    POSIX.1 functions: þhpt{cfgetispeed()}, þhpt{cfgetospeed()},
    þhpt{cfsetispeed()}, þhpt{cfsetospeed()}, þhpt{tcdrain()},
    þhpt{tcflow()}, þhpt{tcflush()}, þhpt{tcgetattr()},
    þhpt{tcsendbreak()}, þhpt{tcsetattr()}.

þitem <time.h>

    Functions and structures for converting time values between
    various formats.

    C90 functions: þhpt{asctime()}, þhpt{ctime()}, þhpt{clock()},
    þhpt{difftime()}, þhpt{gmtime()}, þhpt{localtime()},
    þhpt{mktime()}, þhpt{strftime()}, þhpt{time()}.

    POSIX.1 functions: þhpt{tzset()}.

    Additional functions: þhpt{strptime()}.

þitem <ulimit.h>

    Declares the þhpt{ulimit()} function and defines constants for
    ulimit().

þitem <umalloc.h>

    Declares heap-specific functions for dynamic memory allocation.
    See þhpt{_ucreate2()} for details.

    Functions for allocating memory: þhpt{_ucalloc()},
    þhpt{_umalloc()}.

    Functions for allocating tiled memory: þhpt{_utcalloc()},
    þhpt{_utmalloc()}.

    Functions for maintaining heaps: þhpt{_theapmin()},
    þhpt{_uaddmem()}, þhpt{_uclose()}, þhpt{_ucreate()}
    þhpt{_ucreate2()}, þhpt{_udefault()}, þhpt{_udestroy()},
    þhpt{_uheapchk()}, þhpt{_uheapmin()}, þhpt{_uheapset()},
    þhpt{_uopen()}, þhpt{_utdefault()}.

    Functions for getting information about blocks and heaps:
    þhpt{_mheap()}, þhpt{_uheap_type()}, þhpt{_uheap_walk()},
    þhpt{_uheap_walk2()}, þhpt{_ustats()}.

    Functions declared in <malloc.h> which can also be used on blocks
    allocated by heap-specific functions: þhpt{_expand()},
    þhpt{free()}, þhpt{_msize()}, þhpt{realloc()}.

þitem <unistd.h>

    Various POSIX.1-related definitions and declarations.

    POSIX.1 functions: þhpt{access()}, þhpt{alarm()}, þhpt{chdir()},
    þhpt{close()}, þhpt{cuserid()}, þhpt{dup()}, þhpt{dup2()},
    þhpt{execl()}, þhpt{execle()}, þhpt{execlp()}, þhpt{execv()},
    þhpt{execve()}, þhpt{execvp()}, þhpt{_exit()}, þhpt{fork()},
    þhpt{fpathconf()}, þhpt{getcwd()}, þtt{getegid()}, þtt{geteuid()},
    þtt{getgid()}, þtt{getgroups()}, þtt{getlogin()}, þtt{getpgrp()},
    þhpt{getpid()}, þhpt{getppid()}, þtt{getuid()}, þhpt{isatty()},
    þhpt{lseek()}, þhpt{pathconf()}, þhpt{pause()}, þhpt{pipe()},
    þhpt{read()}, þhpt{rmdir()}, þtt{setgid()}, þtt{setpgid()},
    þtt{setsid()}, þtt{setuid()}, þhpt{sleep()}, þhpt{sysconf()},
    þtt{tcgetpgrp()}, þtt{tcsetpgrp()}, þhpt{ttyname()},
    þhpt{unlink()}, þhpt{write()}.

    POSIX.2 functions: þhpt{getopt()}.

    Additional functions: þhpt{brk()}, þhpt{getpass()},
    þhpt{_getpass1()}, þhpt{_getpass2()}, þhpt{mkstemp()},
    þhpt{mktemp()}, þhpt{profil()}, þhpt{sbrk()}.

þitem <utime.h>

    Declares þhpt{utime()} and defines þtt{struct utimbuf}.  Includes
    <sys/utime.h>.

þitem <varargs.h>

    Functions with variable number of arguments -- traditional Unix
    version.  New programs should use <stdarg.h> instead of
    <varargs.h>, therefore the macros of <varargs.h> are not
    documented here.

þitem <emx/bigint.h>

    Internal header file for the implementation of decimal to binary
    and binary to decimal conversions of floating point numbers.
    Application programs should never include this header -- it's used
    for library modules only.

þitem <emx/float.h>

    Internal header file for the implementation of floating point
    math.  Application programs should never include this header --
    it's used for library modules only.

þitem <emx/io.h>

    Internal header file for the implementation of low-level I/O and
    stream I/O.  Application programs should never include this header
    -- it's used for library modules only.

þitem <emx/nls.h>

    Internal header file for the implementation of some functions of
    <sys/nls.h>.  Application programs should never include this header --
    it's used for library modules only.

þitem <emx/pwd.h>

    Internal header file for the implementation of some functions of
    <pwd.h>.  Application programs should never include this header --
    it's used for library modules only.

þitem <emx/startup.h>

    Internal header file for the implementation of startup and cleanup
    code.  Application programs should never include this header --
    it's used for library modules only.

þitem <emx/syscalls.h>

    Declare emx syscall functions and defines constants and types for
    emx syscalls.  Application programs should never include this
    header -- it's used for library modules only.

þitem <emx/thread.h>

    Internal header file for the implementation of thread-local
    variables used by library functions.  Application programs should
    never include this header -- it's used for library modules only.

þitem <emx/time.h>

    Internal header file for the implementation of time-related
    library functions.  Application programs should never include this
    header -- it's used for library modules only.

þitem <emx/umalloc.h>

    Internal header file for the implementation of malloc().
    Application programs should never include this header -- it's used
    for library modules only.

þitem <sys/builtin.h>

    Defines inline assembly functions for some low-level tasks.
    Several of these functions are provided for compatibility with
    functions declared in the þtt{<builtin.h>} header of IBM's Visual
    Age C++ 3.0 compiler (VAC++).

    Functions for RAM semaphores: þhpt{__cxchg()}, þhpt{__lxchg()},
    þhpt{__sxchg()}.

    Functions for disabling and enabling interrupts:
    þhpt{__disable()}, þhpt{__enable()}.

    Functions for bit operations: þhpt{_crotl()}, þhpt{_crotr()},
    þhpt{__fls()}, þhpt{_lrotl()}, þhpt{_lrotr()}, þhpt{_srotl()},
    þhpt{_srotr()}.

þitem <sys/dir.h>

    Prerequisite header: <sys/types.h>You should use <dirent.h>
    instead of <sys/dir.h>.

    Functions: þhpt{closedir()}, þhpt{readdir()}, þhpt{rewinddir()},
    þhpt{opendir()}, þhpt{seekdir()}, þhpt{telldir()}.

þitem <sys/dirent.h>

    Defines þtt{struct dirent} and associated constants.  This header
    file is used by <dirent.h>, you don't have to include <sys/dirent.h>
    yourself.

þitem <sys/dirtree.h>

    Declares the emx directory tree functions and defines associated
    constants and types.

    Functions: þhpt{_dt_free()}, þhpt{_dt_read()}, þhpt{_dt_sort()},
    þhpt{_dt_split()}.

þitem <sys/ea.h>

    Defines þtt{struct _ea} and declares the emx functions for
    low-level extended attributes handling.  See also <sys/ead.h> --
    don't confuse these two different approaches to extended
    attributes.

    Functions: þhpt{_ea_free()}, þhpt{_ea_get()}, þhpt{_ea_put()},
    þhpt{_ea_remove()}.

þitem <sys/ead.h>

    Declares the _ead type and the emx functions for high-level
    extended attributes handling via `EA descriptors'.  See also also
    <sys/ea.h> -- don't confuse these two different approaches to
    extended attributes.

    Functions: þhpt{_ead_add()}, þhpt{_ead_clear()},
    þhpt{_ead_copy()}, þhpt{_ead_count()}, þhpt{_ead_create()},
    þhpt{_ead_delete()}, þhpt{_ead_destroy()},
    þhpt{_ead_fea2list_size()}, þhpt{_ead_fea2list_to_fealist()},
    þhpt{_ead_fealist_to_fea2list()}, þhpt{_ead_find()},
    þhpt{_ead_get_fea2list()}, þhpt{_ead_get_flags()},
    þhpt{_ead_get_name()}, þhpt{_ead_get_value()},
    þhpt{_ead_name_len()}, þhpt{_ead_read()}, þhpt{_ead_replace()},
    þhpt{_ead_sort()}, þhpt{_ead_use_fea2list()},
    þhpt{_ead_value_size()}, þhpt{_ead_write()}.

þitem <sys/emxload.h>

    Declares functions for keeping programs in memory with
    þtt{emxload.exe}.

    Functions: þhpt{_emxload_env()}, þhpt{_emxload_this()},
    þhpt{_emxload_prog()}, þhpt{_emxload_unload()},
    þhpt{_emxload_list_start()}, þhpt{_emxload_list_get()},
    þhpt{_emxload_connect()}, þhpt{_emxload_disconnect()},
    þhpt{_emxload_stop()}.

þitem <sys/fcntl.h>

    Defines file mode constants such as O_RDONLY and other constants.
    Declares the þhpt{fcntl()} and þhpt{flock()} functions.  You
    should include <fcntl.h> instead.

þitem <sys/file.h>

    This header is provided for compatibility with Unix systems
    -- it includes <sys/fcntl.h>.

þitem <sys/fmutex.h>

    Prerequisite header: <sys/builtin.h>

    This header contains definitions and declarations for _fmutex
    semaphores.  _fmutex semaphores are fast RAM semaphores which
    control access to a resources shared by threads or processes.  See
    `þhpt{_fmutex semaphores}' for details.

    Functions: þhpt{_fmutex_available()},
    þhpt{_fmutex_checked_close()}, þhpt{_fmutex_checked_create()},
    þhpt{_fmutex_checked_open()}, þhpt{_fmutex_checked_release()},
    þhpt{_fmutex_checked_request()}, þhpt{_fmutex_close()},
    þhpt{_fmutex_create()}, þhpt{_fmutex_dummy()},
    þhpt{_fmutex_open()}, þhpt{_fmutex_release()},
    þhpt{_fmutex_request()}.

þitem <sys/hw.h>

    Declares the emx port access and memory access functions.

    Function: þhpt{_inp8()}, þhpt{_inp16()}, þhpt{_inp32()},
    þhpt{_inps8()}, þhpt{_inps16()}, þhpt{_inps32()},
    þhpt{_memaccess()}, þhpt{_outp8()}, þhpt{_outp16()},
    þhpt{_outp32()}, þhpt{_outps8()}, þhpt{_outps16()},
    þhpt{_outps32()}, þtt{_outpt()}, þhpt{_outps8dac()},
    þhpt{_portaccess()}, þhpt{_wait0()}, þhpt{_wait01()},
    þhpt{_wait1()}, þhpt{_wait10()}.

þitem <sys/ioctl.h>

    Declares the þhpt{ioctl()} function and defines various constants
    to be used with ioctl().  This header includes <sys/so_ioctl.h> if
    a TCP/IP-related header such as <sys/socket.h> has been included
    before <sys/ioctl.h>.

þitem <sys/ipc.h>

    This header contains some definitions for System V IPC
    facilities.  However, these are not yet implemented in emx.

þitem <sys/kbdscan.h>

    Defines keyboard scan codes.

þitem <sys/moddef.h>

    Declares types and functions for reading module definition files.

    Functions: þhpt{_md_close()}, þhpt{_md_errmsg()},
    þhpt{_md_get_linenumber()}, þhpt{_md_get_number()},
    þhpt{_md_get_string()}, þhpt{_md_get_token()},
    þhpt{_md_next_token()}, þhpt{_md_open()}, þhpt{_md_parse()},
    þhpt{_md_use_file()}.

þitem <sys/msg.h>

    This header contains some definitions for System V message
    queues.  However, these are not yet implemented in emx.

þitem <sys/nls.h>

    Declares the emx national-language support functions and macros.

    Functions: þhpt{_nls_init()}, þhpt{_nls_strlwr()},
    þhpt{_nls_strupr()}.

    Macros: þhpt{_nls_tolower()}, þhpt{_nls_toupper()},
    þhpt{_nls_is_dbcs_lead()}.

þitem <sys/param.h>

    Defines constants such as MAXNAMLEN which describe system
    parameters.

þitem <sys/process.h>

    Process handling.  Application programs should include <process.h>
    instead.  See <process.h> for details.

þitem <sys/ptrace.h>

    Declares the þhpt{ptrace()} function and defines associated
    constants.

þitem <sys/reg.h>

    Defines register offset constants.  These are usually used with
    þhpt{ptrace()} and for reading core dump files.

þitem <sys/resource.h>

    This header is empty.

þitem <sys/rmutex.h>

    Prerequisite headers: <sys/builtin.h>, <sys/fmutex.h>

    This header contains definitions and declarations for _rmutex
    semaphores.  _rmutex semaphores are registered _fmutex semaphores.
    See `þhpt{_fmutex semaphores}' for details.

    Functions: þhpt{_rmutex_available()},
    þhpt{_rmutex_checked_close()}, þhpt{_rmutex_checked_create()},
    þhpt{_rmutex_checked_open()}, þhpt{_rmutex_checked_release()},
    þhpt{_rmutex_checked_request()}, þhpt{_rmutex_close()},
    þhpt{_rmutex_create()}, þhpt{_rmutex_dummy()},
    þhpt{_rmutex_open()}, þhpt{_rmutex_release()},
    þhpt{_rmutex_request()}.

þitem <sys/select.h>

    Defines the fd_set type and macros (FD_SET etc.) for þhpt{select()}.

þitem <sys/signal.h>

    Functions and constants for signal processing.  Application
    programs should include <signal.h> instead.

þitem <sys/smutex.h>

    Prerequisite header: <sys/builtin.h>

    This header contains definitions and declarations for _smutex
    semaphores.  _smutex semaphores are very simple RAM semaphores
    which control access to a resources shared by threads or
    processes.  See `þhpt{_smutex semaphores}' for details.

    Functions: þhpt{_smutex_available()}, þhpt{_smutex_release()},
    þhpt{_smutex_request()}.

þitem <sys/socket.h>

    Definitions and declarations related to sockets.

þitem <sys/so_ioctl.h>

    Socket-specific definitions for ioctl().  This header is
    automatically included by <sys/ioctl.h> if a TCP/IP-related header
    such as <sys/socket.h> has been included before <sys/ioctl.h>.

þitem <sys/stat.h>

    Prerequisite header: <sys/types.h>

    Defines þtt{struct stat} for þhpt{stat()} and þhpt{fstat()}.
    Defines S_IREAD, S_IWRITE and S_IEXEC for þhpt{open()}.  Defines
    S_IFCHR etc. constants and S_ISCHR etc. macros for checking file
    types.  Declares the stat() and fstat() functions.

þitem <sys/statfs.h>

    Declares þtt{struct statfs} -- which is not yet supported by emx.

þitem <sys/termio.h>

    Defines þtt{struct termio} and constants for the þhpt{general
    terminal interface} (System V variant).

þitem <sys/time.h>

    Declares þhpt{utimes()}, þhpt{gettimeofday()} and
    þhpt{settimeofday()}.

þitem <sys/timeb.h>

    Declares þhpt{ftime()} and defines þtt{struct timeb}.

þitem <sys/times.h>

    Prerequisite header: <time.h>

    Declares þhpt{times()} and defines þtt{struct tms}.

þitem <sys/types.h>

    Defines various types such as ino_t for <sys/stat.h>.  Defines the
    fd_set type and macros (FD_SET etc.) for þhpt{select()}.

þitem <sys/uio.h>

    Declares þtt{struct iovec} and the þtt{readv()} and þtt{writev()}
    functions.

þitem <sys/uflags.h>

    Declares the þhpt{_uflags()} function and constants for _uflags().

þitem <sys/user.h>

    Declares þtt{struct user} which is used by þhpt{ptrace()} and in
    core dump files.  See also <sys/reg.h> and <sys/ptrace.h>.

þitem <sys/utime.h>

    Declares þhpt{utime()} and defines þtt{struct utimbuf}.  You
    should include <utime.h> instead.

þitem <sys/utsname.h>

    Declares þhpt{uname()} and defines þtt{struct utsname}.

þitem <sys/video.h>

    Declares the emx video library functions and defines associated
    constants.

    Functions: þhpt{v_attrib()}, þhpt{v_backsp()}, þhpt{v_clear()},
    þhpt{v_clreol()}, þhpt{v_ctype()}, þhpt{v_delline()},
    þhpt{v_dimen()}, þhpt{v_fclose()}, þhpt{v_fopen()},
    þhpt{v_getattr()}, þhpt{v_getctype()}, þhpt{v_getline()},
    þhpt{v_getxy()}, þhpt{v_gotoxy()}, þhpt{v_hardware()},
    þhpt{v_hidecursor()}, þhpt{v_init()}, þhpt{v_insline()},
    þhpt{v_putc()}, þhpt{v_putline()}, þhpt{v_putm()},
    þhpt{v_putmask()}, þhpt{v_putn()}, þhpt{v_puts()},
    þhpt{v_scroll()}, þhpt{v_scrollup()}, þhpt{v_printf()},
    þhpt{v_vprintf()}.

þitem <sys/wait.h>

    Declares þhpt{wait()} and þhpt{waitpid()}.  Defines constants and
    macros for using these functions.

þitem <sys/winmgr.h>

    Declares the emx window manager library functions and the
    wm_handle type.  Defines window manager constants.

    Functions for mangaging windows: þhpt{wm_border()},
    þhpt{wm_bottom()}, þhpt{wm_close()}, þhpt{wm_close_all()},
    þhpt{wm_create()}, þhpt{wm_delete()}, þhpt{wm_dimen()},
    þhpt{wm_down()}, þhpt{wm_exit()}, þhpt{wm_find()},
    þhpt{wm_get_pos()}, þhpt{wm_init()}, þhpt{wm_move()},
    þhpt{wm_open()}, þhpt{wm_top()}, þhpt{wm_up()}, þhpt{wm_update()}.

    Functions for managing the cursor: þhpt{wm_chide()},
    þhpt{wm_ctype()}, þhpt{wm_cursor()}, þhpt{wm_cvis()},
    þhpt{wm_get_cursor()}, þhpt{wm_getx()}, þhpt{wm_getxy()},
    þhpt{wm_gety()}, þhpt{wm_gotoxy()}.

    Functions for scrolling: þhpt{wm_del_char()}, þhpt{wm_del_line()},
    þhpt{wm_ins_char()}, þhpt{wm_ins_line()}, þhpt{wm_scroll()},

    Functions for output to a window: þhpt{wm_attrib()},
    þhpt{wm_attrib_all()}, þhpt{wm_backsp()}, þhpt{wm_clear()},
    þhpt{wm_clr_eol()}, þhpt{wm_fclose()}, þhpt{wm_fopen()},
    þhpt{wm_get_attrib()}, þhpt{wm_printf()}, þhpt{wm_puta_at()},
    þhpt{wm_putc()}, þhpt{wm_putc_at()}, þhpt{wm_putca()},
    þhpt{wm_putca_at()}, þhpt{wm_puts()}, þhpt{wm_puts_at()},
    þhpt{wm_putsa()}, þhpt{wm_putsa_at()}, þhpt{wm_vprintf()},
    þhpt{wm_wrap()}.

þendlist

þh1 Dynamic memory allocation

  Dynamic memory allocation means allocation of objects at runtime
  where the lifetime of the objects is independent of the nesting of
  blocks and functions.

þipfminitoc

þh2 Allocating blocks

  The þhpt{malloc()} function is used to dynamically allocate an
  object.  You pass the size of the object to malloc() and malloc will
  return a pointer to a block of memory allocated from a heap.  The
  contents of the block are indeterminate.  If you need a block of
  memory initialized to zeros, use the þhpt{calloc()} function.
  calloc() takes two arguments: the number of objects and the size of
  one object.  The size of the block is the product of the two
  numbers.  Using calloc() can be more efficient than calling malloc()
  and zeroing the block with memset() because calloc() can avoid
  zeroing the block if it knows that it already is zeroed.

þh2 Deallocating (freeing) blocks

  When you no longer need the object, you can deallocate it by passing
  a pointer to the object to the þhpt{free()} function.  After
  deallocating a block, you must no longer use the block.  (Strictly,
  you are even no longer allowed to use the pointer to the block.)
  The memory block can be reused later by malloc() etc. for other
  dynamically allocated objects.

þh2 Resizing blocks

  The size of blocks allocated with malloc() etc. can be changed with
  the þhpt{realloc()} function.  Quite often, the size of a block
  cannot be changed in place, that is, the block must be moved to
  another location in the heap.  Therefore, realloc() returns a
  pointer to the new location of block, which might happen to be equal
  to the old one.

  The þhpt{_expand()} function attempts to resize a block in place,
  that is, without moving it.  In most cases, blocks cannot be resized
  in place.  If resizing the block fails, _expand() does not move the
  block to another location.

þh2 ISO 9899 standard

  Whenever possible, you should use only calloc(), free(), malloc(),
  and realloc() for dynamic memory allocation.  All other functions
  described here are not defined by the ISO standard for the C
  programming language.

þh2 Tiled memory

  16-bit OS/2 API functions have special requirements for the
  alignment of objects.  A `tiled' object is an object which meets
  these requirements.  The þhpt{_tmalloc()} function dynamically
  allocates a tiled object from the tiled default heap.  The
  þhpt{_tcalloc()} function allocates a tiled object initialized to
  zeros.  The þhpt{_trealloc()} function resizes a tiled object -- the
  object will remain tiled.  The þhpt{_tfree()} function deallocates a
  tiled object allocated with _tmalloc() or _tcalloc().

þh2 Multiple heaps

  The emx C library maintains a runtime heap, from which malloc()
  allocates by default and a tiled runtime heap, from which _tmalloc()
  allocates by default.  (These two runtime heaps happen to be
  identical in the current implementation, so there's in fact only one
  runtime heap.)

  However, you can create your own heaps in addition to the runtime
  heaps.  The interface to multiple heaps is more or less compatible
  to the one of IBM's Visual Age C++ compiler.  Definitions and
  declarations for using multiple heaps are in the <umalloc.h> header.

  To create a heap, you have to reserve a memory area for the heap.
  This memory area can be statically allocated, obtained with
  þhpt{sbrk()}, obtained with DosAllocMem, or even allocated from
  another heap.  The þhpt{_ucreate()} function creates a heap in the
  memory area you provide and returns a pointer to the new heap.
  Before using the new heap, you have to open the heap by calling
  þhpt{_uopen()}.

  To allocate from a specific heap, call þhpt{_umalloc()} instead of
  malloc(), passing a pointer to the heap as first argument.
  þhpt{_ucalloc()} allocates a zero-initialized block from the hea
  pointed to by the first argument.

  You can use realloc() to resize a block of any heap -- realloc()
  automatically determines from which heap the block has been
  allocated and will keep the block in that heap.  You can use free()
  to deallocate a block from any heap -- free() automatically
  determines from which heap the block has been allocated.

  If you no longer need a heap, you can close it with þhpt{_uclose()}
  and then destroy it with þhpt{_udestroy()}.  You are responsible for
  deallocating the memory area in which the heap was created; if you
  allocated the memory area with DosAllocMem, deallocate it with
  DosFreeMem.

  Note that only memory obtained with brk() and sbrk() is dumped into
  the core file.  Heaps in memory objects allocated with DosAllocMem
  are not visible when performing post-mortem debugging.

þh2 Tiled heaps

  The þhpt{_utmalloc()} function allocates a tiled object from a heap
  which is not tiled.  Objects allocated with þhpt{_utmalloc()} can be
  resized with realloc() and can be dealllocated with free().
  þhpt{_utcalloc()} allocates a tiled object initialized to zeros.
  Note that allocating tiled objects from a regular (untiled) heap may
  increase fragmentation of the heap.

  You can create a tiled heap by passing the _HEAP_TILED flag to
  _ucreate().  All objects allocated from a tiled heap are tiled
  objects.  Again, realloc() and free() can be used instead of
  _trealloc() and _tfree(), respectively.

þh2 Default heaps

  The main thread and each thread created with þhpt{_beginthread()}
  has its own two pointers to its two default heaps (regular and
  tiled), that is, different threads can have different default heaps.
  Do not confuse the default heaps of a thread with the runtime heaps;
  the runtime heaps are special heaps maintained by the C library.
  Initially, each thread has the runtime heap as its default heap and
  the tiled runtime heap as its tiled default heap.  (Note that the
  two runtime heaps happen to be identical in the current
  implementation, that is, the two heap pointers of a thread initially
  point to the same heap, the runtime heap.)

  For each thread, you can select a default heap with the
  þhpt{_udefault()} function which takes a pointer to the heap to be
  used.  After selecting a default heap for a thread, all malloc()
  calls in that thread will allocate memory from the selected heap.
  You can switch back to the runtime heap by passing _RUNTIME_HEAP to
  _udefault(); _RUNTIME_HEAP is a pointer to the runtime heap.

  For each thread, you can select a tiled default heap with the
  þhpt{_utdefault()} function which takes a pointer to the heap to be
  used.  After selecting a tiled default heap for a thread, all
  _tmalloc() calls in that thread will allocate memory from the
  selected heap.

  If a tiled heap is selected as default heap with _udefault(),
  malloc() always allocates tiled objects.

þh2 Shared heaps

  Heaps created with _ucreate() can be shared between processes.  To
  create a shared heap, allocate shared memory with DosAllocSharedMem
  and pass the _HEAP_SHARED flag to _ucreate().  Each process (except
  the process which created the shared memory object) which wants to
  access such a shared heap must first obtain access to the shared
  memory allocated with DosAllocSharedMem.  This is done with
  DosGetNamedSharedMem, DosGetSharedMem, or DosGiveSharedMem.  Then,
  each process, including the process which created the heap, must
  obtain access to the heap.  This is done with _uopen().  _udefault()
  can be used to use a shared heap as default heap.

  If a shared heap is no longer needed by a process, that process
  should close the heap with _uclose() and relinquish access to the
  shared memory object with DosFreeMem.  After all processes,
  including the process which created the heap, have closed the heap
  with _uclose(), the heap can be destroyed with _udestroy().

þh2 Checking heaps

  Heap corruption is a quite common problem of C programs.  To track
  down such errors, you can periodically call the þhpt{_heapchk()}
  function to check the default heap and the tiled default heap of the
  current thread for consistency.  The þhpt{_uheapchk()} function
  checks a specific heap.

  Sometimes, programs erroneously depend on the contents of
  dynamically allocated blocks.  To debug these problems, you can call
  þhpt{_heapset()} to fill all bytes of all free blocks of the default
  heap and the tiled default heap with a certain value.
  þhpt{_uheapset()} does the same thing for a specific heap.

  The þhpt{_heap_walk()} function calls a user-supplied function for
  each block of the default heap and the tiled default heap, passing
  the address, size, and status (used or free) of one block per call.
  This can be used to identify memory leaks.  The þhpt{_uheap_walk()}
  function does the same thing for a specific heap.

þh2 Other heap-related functions

  The þhpt{_heapmin()} function attempts to minimize the size of the
  default heap by deallocating memory areas which are not used for any
  blocks.  The þhpt{_theapmin()} function attempts to minimize the
  tiled default heap.  The þhpt{_uheapmin()} function attempts to
  minimize a specific heap.

  You can add memory to a heap by calling the þhpt{_uaddmem()}
  function.  For instance, the memory area passed to _uaddmem() can be
  allocated with DosAllocMem.

  The þhpt{_msize()} function returns the size of the block pointed to
  by its argument.  The þhpt{_mheap()} function returns a pointer to
  the heap containing the block pointed to by its argument.  For both
  functions, the pointer must point to a used object of a heap.

  The þhpt{_ustats()} function reports the amount of memory used for a
  heap, the total number of allocated bytes, the size of the biggest
  free block, etc.

þh2 Why multiple heaps?

  Using multiple heaps has several advantages:

þitemize

  If you need a lot of objects of the same size, you can reduce
  fragmentation of memory by creating a separate heap for those
  objects.  Using separate heaps for untiled and tiled objects also
  reduces fragmentation.

þitem

  By having different heaps for different threads, access to the heaps
  does not have to be serialized, making the application more
  efficient, especially on machines with multiple CPUs.  Moreover, the
  probability of one thread corrupting another thread's objects is
  reduced if objects are allocated in different heaps for different
  threads.

þitem

  You can deallocate all objects of a heap at once, by destroying the
  heap.  Though this is not good programming practice, you can use
  this scheme if you can't keep track of all the pointers.

þitem

  You can create heaps shared by multiple processes.

þenditemize

þh2 Non-contiguous heaps

  The malloc() implementation of the emx C library supports
  non-contiguous memory.  A heap can consist of several non-contiguous
  segments.

  Currently, there are some restrictions when using a non-contiguous
  heap.  See sbrk() for details.


þh2 Replacing malloc()

  You can replace the emx implementation of malloc() with an alternate
  implementation of malloc() such as GNU malloc.  This is done by
  linking with that alternate malloc() library.  Additionally, you
  have to link with the þtt{tmalloc} library which implements
  _tmalloc() etc. on top of malloc().  Example:

þexample
gcc -o program.exe src1.c src2.c -lvideo -ltmalloc gmalloc.a
þendexample

  If the linker complains about malloc() being multiply defined, you
  probably forgot to link with the þtt{tmalloc} library.  (There is a
  hack in the emx C library which tries to provoke this behavior to
  guard against forgetting to link with the þtt{tmalloc} library.)

  You must not replace the emx implementation of malloc() if you are
  using a C runtime DLL (emxlibcs.dll, for instance) unless you
  replace malloc() in that library.  The application and all DLLs
  (with the exception of stand-alone DLLs) must use the same
  implementation of malloc().


þh1 General terminal interface
þlabel General terminal interface
þlabel general terminal interface

  Both the System V and POSIX.1 terminal interfaces are supported by
  emx.

  Currently, only the keyboard device is supported.  The file
  descriptor used by the terminal interface must refer to the
  keyboard.  Moreover, the file descriptor must currently be 0 under
  DOS.

  Both terminal interfaces are not supported with the system call
  library sys.lib (þhpt{-Zsys}).

  The main implementation-specific difference between the two
  interfaces is the usage of the IDEFAULT bit of the c_lflag member of
  þtt{struct termio} and þtt{struct termios} for diabling the general
  terminal interface.  The POSIX.1 terminal interface does not use the
  IDEFAULT bit.

þipfminitoc

þh2 System V terminal interface

  The System V terminal interface uses the TCGETA, TCSETA, TCSETAF,
  TCSETAW, TCFLSH, TCSBRK, and TCXONC requests of þhpt{ioctl()} for
  controlling terminals.  The TCGETA, TCSETA, TCSETAF, and TCSETAW
  requests employ the following structure defined in <sys/termio.h>:

þexample
struct termio
{
  unsigned int  c_iflag;      /* input modes */
  unsigned int  c_oflag;      /* output modes */
  unsigned int  c_cflag;      /* control modes */
  unsigned int  c_lflag;      /* local modes */
  unsigned int  c_line;       /* unused */
  unsigned char c_cc[NCC];    /* control characters etc. */
};
þendexample

  If c_lflag includes IDEFAULT, the default operating system input
  method is used (including line editing).  Input is always done line
  by line.  All other fields of the þtt{termio} structure are ignored
  in this case.

  If c_lflag does not include IDEFAULT, UNIX-like input processing is
  performed.

  All bits of c_oflag, c_cflag, and c_line are currently ignored.


þh2 POSIX.1 terminal interface

  The POSIX.1 terminal interface uses þhpt{cfgetispeed()},
  þhpt{cfgetospeed()}, þhpt{cfsetispeed()}, þhpt{cfsetospeed()},
  þhpt{tcdrain()}, þhpt{tcflow()}, þhpt{tcflush()}, þhpt{tcgetattr()},
  þhpt{tcsendbreak()}, and þhpt{tcsetattr()}.

  The tcgetattr() and tcsetattr() functions employ the following
  structure defined in <termios.h>:

þexample
struct termios
{
  tcflag_t c_iflag;           /* input modes */
  tcflag_t c_oflag;           /* output modes */
  tcflag_t c_cflag;           /* control modes */
  tcflag_t c_lflag;           /* local modes */
  cc_t c_cc[NCCS];            /* control characters etc. */
  int c_reserved[4];          /* currently unused */
};
þendexample

  The POSIX.1 terminal interface is enabled by calling tcsetattr().
  Before the first invocation of tcsetattr(), the default operating
  system input method is used (including line editing).

  All bits of c_oflag, and c_cflag are currently ignored.


þh2 Terminal parameters

  This description applies to both the System V and the POSIX.1
  terminal interfaces, unless otherwise indicated.

  The following bits of c_iflag are used by emx in the following
  sequence:

þdescription

þitem IDELETE

  Backspace key generates DEL character (emx extension)

þitem ISTRIP

  Clear bit 7 of all input characters

þitem INLCR

  Translate linefeed into carriage return

þitem IGNCR

  Ignore carriage return

þitem ICRNL

  Translate carriage return into linefeed

þitem IUCLC

  Convert upper case letters (A-Z) into lower case (a-z)

þenddescription

  If IDELETE is set, the two meanings of the backspace key (the one
  above the Return key) are swapped: Backspace generates DEL and
  Ctrl-Backspace generates Ctrl-H.  If IDELETE is not set, Backspace
  generates Ctrl-H and Ctrl-Backspace generates DEL.  The IDELETE bit
  applies only to the backspace key and does not affect other methods
  of entering Ctrl-H or DEL.

  The following bits of c_lflag are used by emx:

þdescription
þitem IDEFAULT

  Disable special processing for the terminal interface (emx
  extension, this bit is always clear for the POSIX.1 terminal
  interface).  If this bit is set, the default operating system input
  method is used (including line editing).  For the System V
  terminal interface, this bit is initially set

þitem ISIG

  Enable signal processing (see VINTR and VQUIT)

þitem ICANON

  Read input line by line, enable line editing

þitem ECHO

  Echo input

þitem ECHOK

  Echo CR/LF after VKILL

þenddescription

  The c_cc array contains control characters.  If an element of c_cc
  is set to zero (for the System V terminal interface) or
  _POSIX_VDISABLE (for the POSIX.1 terminal interface), no character
  will trigger the action associated with that element.

þdescription
þitem VINTR

  Generate SIGINT (in thread 1) if ISIG is set in c_iflag

þitem VQUIT

  Generate SIGQUIT (in thread 1) if ISIG is set in c_iflag

þenddescription

  The following characters are used if ICANON is set:

þdescription
þitem VERASE

  Delete one character to the left (default: Ctrl-H)

þitem VKILL

  Deletes the entire input line (default: Ctrl-U)

þitem VEOF

  Indicates end of file (default: Ctrl-D)

þitem VEOL

  Indicates end of line (default: none)

þitem VSUSP

  Stop process (POSIX.1, ignored by emx)

þitem VSTOP

  Suspend output (POSIX.1, ignored by emx)

þitem VSTART

  Resume output (POSIX.1, ignored by emx)

þenddescription

  The VERASE, VKILL and VEOF characters can be escaped by preceding
  them with a backslash.  End of file at the beginning of a line is
  usually interpreted as end of input.

  The following elements are used if ICANON is not set:

þdescription
þitem VMIN

  Minimum number of characters to be read (default: 6)

þitem VTIME

  Time-Out in 0.1 seconds (default: 1)

þenddescription

  Note that VMIN and VTIME are not equal to VEOF and VEOL,
  respectively.  Unix uses the VEOF field for both VEOF and VMIN, the
  VEOL field for both VEOL and VTIME.  emx uses separate fields for
  the four values.

  There are four cases for VMIN and VTIME (that is, þtt{c_cc[VMIN]}
  and þtt{c_cc[VTIME]}):

þlist

þitem þtt{VMIN = 0, VTIME = 0}

  Return all the characters stored in the input buffer.  If there are
  no characters in the buffer, read() returns immediately.  read()
  doesn't wait for input.

þitem þtt{VMIN = 0, VTIME > 0}

  Return after at least one character has been received or after
  waiting for VTIME * 0.1 seconds, whichever happens first.  In the
  latter case, read() will return 0.

þitem þtt{VMIN > 0, VTIME = 0}

  Return after at least VMIN characters have been received.

þitem þtt{VMIN > 0, VTIME > 0}

  Return after at least VMIN characters have been received or if no
  characters have been received for VMIN * 0.1 seconds after receipt
  of a character (the time-out applies after at least one character
  has been received and is reset after each character).

þendlist

  In all cases, read() will return as many characters as are available
  in the input buffer, up to the number of characters requested in the
  read() call.

  If O_NONBLOCK (alias O_NDELAY) has been set for the file descriptor
  with þhpt{fcntl()}, read() will always immediately return.  If there
  is not enough data available with respect to VMIN, read() will
  immediately return -1 and set errno to EAGAIN.

  If the general terminal interface is enabled, the text/binary mode
  of the handle is ignored: the conversions are controlled by c_iflag,
  including CR-to-LF conversion and the end-of-file character.

  If ICANON is not set, function keys are returned as two characters.
  The first one is a null (þtt{'\0'}) character, the second one is the
  scan code.  See <sys/kbdscan.h> for scan codes.


þh1 Signal processing
þlabel signal processing


  Signals are conditions that may be reported synchronously or
  asynchronously during program execution.  Each signal is associated
  with a signal action, which specifies what action to perform when
  the signal occurs.

þipfminitoc

þh2 Signal actions

  Each signal is associated with one of the following actions:

þdescription
þitem SIG_DFL

  Default signal action.  The action depends on the signal, see the
  table below.

þitem SIG_IGN

  Ignore the signal.

þitem signal-catching function

  Upon receipt of the signal, a signal-catching function (also known
  as signal handler) is called.  The signal number is passed as the
  only argument to the signal-catching function.  Before the
  signal-catching funcion is called, the signal is blocked or the
  signal action is reset to SIG_DFL, depending on the signal
  processing model.

þenddescription

  The signal action can be changed with the þhpt{signal()} and
  þhpt{sigaction()} functions.  The signal action for SIGKILL is
  SIG_DFL and cannot be changed.  Signal actions are private to each
  thread of multithread programs.

  If a signal which isn't ignored (that is, SIG_DFL or handler
  installed) occurs while calling read() with the þhpt{general
  terminal interface} enabled, -1 will be returned by read() and errno
  will be set to EINTR.  The buffer will flushed.

  For all signals, the initial signal handler is SIG_DFL (unless
  SIG_IGN is inherited from the parent process), sa_mask is 0, and
  sa_flags is SA_ACK.  Initially, all signals are not blocked.

  Only certain library functions can be called by a signal-catching
  function.  All other library functions are considered to be unsafe.
  Calling an unsafe function in a signal-catching function which
  interrupted an unsafe function causes undefined behavior.

þc TODO: List of reentrant functions

þc _exit() access() alarm() cfgetispeed() cfgetospeed() cfsetispeed()
þc cfsetospeed() chdir() chmod() chown() close() creat() dup2() dup()
þc execle() execve() fcntl() fork() fstat() getegid() geteuid()
þc getgid() getgroups() getpgrp() getpid() getppid() getuid() kill()
þc link() lseek() mkdir() mkfifo() open() pathconf() pause() pipe()
þc read() rename() rmdir() setgid() setpgid() setsid() setuid() sigaction()
þc sigaddset() sigdelset() sigemptyset() sigfillset() sigismember()
þc sigpending() sigprocmask() sigsuspend() sleep() stat() sysconf()
þc tcdrain() tcflow() tcflush() tcgetattr() tcgetpgrp() tcsendbreak()
þc tcsetattr() tcsetpgrp() time() times() umask() uname() unlink()
þc utime() wait() waitpid() write()

þh2 Blocking signals

  Signals can be blocked with the þhpt{sigprocmask()} function.  If a
  signal is generated while it is blocked, it won't be delivered until
  unblocked, that is, the generated signal will be pending while the
  signal is blocked.  As soon as the signal is unblocked, the pending
  signal will be delivered.  At most one signal of each kind can be
  pending, that is, if a signal is generated twice while it is
  blocked, it will be delivered only once as soon as it will be
  unblocked.  However, SIGCHLD will be stay pending until termination
  status for all terminated child processes has been fetched with
  wait() or waitpid().  The action taken on delivery is determined by
  the signal action in effect when the signal is delivered, not when
  the signal is generated.  If a signal like SIGILL is caused by an
  exception while it is blocked, the default action will be taken.


þh2 Signal processing models

  The following signal processing models are available:

þdescription
þitem emx
  On entry to a signal handler, the signal is blocked.  To unblock
  (acknowledge) the signal,
þexample
signal (signo, SIG_ACK);
þendexample
  must be called (by the signal handler, usually), otherwise that
  signal cannot be delivered again.  For compatibility with existing
  emx programs, this model is the default.

þitem System V
  On entry to a signal handler, the action for the signal is set to
  SIG_DFL.  The signal handler has to be reinstalled with sigaction()
  or signal().  Note that there is a timing window; for instance, the
  process will be terminated if two SIGINT signals occur in quick
  succession.

þitem BSD and POSIX.1
  On entry to a signal handler, the signal is blocked.  It will be
  unblocked automatically when the signal handler returns.
þenddescription

  With the system call library sys.lib (þhpt{-Zsys}), only the
  `emx' signal processing model is available with signal(); however,
  sigaction() is fully supported.

  When using þhpt{signal()} to install a signal handler, the signal
  processing model for that signal is by default `emx'.  To use the
  `System V' model for signal(), link with þtt{sigsysv.o} by using the
  -Zsysv-signals option of GCC.  To use the `BSD' model for signal(),
  link with þtt{sigbsd.o} by using the -Zbsd-signals option of GCC.
  -Zsysv-signals and -Zbsd-signals cannot be used with -Zsys.

  When using þhpt{sigaction()} to install a signal handler, the signal
  processing model for that signal is `BSD', which conforms to
  POSIX.1.  The `emx' model can be selected by setting the SA_ACK bit of
  the sa_flags member of þtt{struct sigaction}.  The `System V' model
  can be selected by setting the SA_SYSV bit of the sa_flags member of
  þtt{struct sigaction}.

þh2 Available signals

  The following signals are defined by emx:

þexample
Signal   ³  SIG_DFL  ³ Standard ³ Description
ÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
SIGHUP   ³ terminate ³ POSIX.1  ³ Hangup
SIGINT   ³ terminate ³ C90      ³ Interrupt (Ctrl-C or Ctrl-Break)
SIGQUIT  ³   core    ³ POSIX.1  ³ Quit
SIGILL   ³   core    ³ C90      ³ Illegal instruction
SIGTRAP  ³   core    ³          ³ Single step (debugging)
SIGABRT  ³   core    ³ C90      ³ abort ()
SIGEMT   ³   core    ³          ³ EMT instruction
SIGFPE   ³   core    ³ C90      ³ Floating point exception
SIGKILL  ³ terminate ³ POSIX.1  ³ Kill process, cannot be caught or ignored
SIGBUS   ³   core    ³          ³ Bus error
SIGSEGV  ³   core    ³ C90      ³ Segmentation violation
SIGSYS   ³   core    ³          ³ Invalid argument to system call
SIGPIPE  ³ terminate ³ POSIX.1  ³ Broken pipe
SIGALRM  ³ terminate ³ POSIX.1  ³ Alarm lock
SIGTERM  ³ terminate ³ C90      ³ Termination, process killed
SIGUSR1  ³  ignore   ³ POSIX.1  ³ User-defined signal #1
SIGUSR2  ³  ignore   ³ POSIX.1  ³ User-defined signal #2
SIGCHLD  ³  ignore   ³ POSIX.1  ³ Death of a child process
SIGCLD   ³  ignore   ³ SysV     ³ Synonym for SIGCHLD
SIGBREAK ³ terminate ³          ³ Break (Ctrl-Break)
SIGWINCH ³  ignore   ³          ³ Window size changed
þendexample

    The SIG_DFL column gives the default action for the signals, that
    is, when the signal action is SIG_DFL:

þdescription
þitem terminate

    Terminate the process with return code 3.

þitem core

    Dump core and terminate the process.  A file whose name is
    `þtt{core}' will be written in the current working directory.  A
    `þtt{core}' file contains a memory dump and the values of the
    registers at the time the signal was delivered.  It can be used
    for post-mortem debugging.  If LINK386 was used for linking, no
    core dump file will be written.

þitem ignore

    The signal is ignored, the process will be continued at the place
    it was interrupted.

þenddescription

þh2 Catching signals

  You can use þhpt{sigaction()} or þhpt{signal()} to set signal
  handlers for all signals but SIGKILL.

  If a signal handler returns, further processing depends on how the
  signal was generated.  If the signal was generated by raise() or
  kill(), processing will continue where it was interrupted.  If the
  signal was generated by an exception (this applies to signals
  SIGILL, SIGSEGV, SIGFPE), core will be dumped and the process will
  be terminated with return code 3.

  If LINK386 was used for linking, no core dump file will be written.

  In the `emx' signal model, the signal handler should call

þexample
signal (signal_number, SIG_ACK);
þendexample

  before returning to unblock the signal.  In the `System V' signal
  model, the signal handler should reinstall itself as soon as
  possible.  However, for SIGCHLD and SIGCLD, wait() or waitpid() must
  be called before reinstalling the signal handler.

  In the `BSD' and `POSIX.1' signal models, the signal handler need
  not unblock the signal as the signal mask which was active before
  calling the signal handler is reinstalled after the signal handler
  returns.

  A signal handler usually looks like this in the `emx' signal model:

þexample
void handler (int signo)
{
  /* Do the work here, the signal is blocked */
  signal (signo, SIG_ACK);
}
þendexample

  A signal handler usually looks like this in the `System V' signal
  model:

þexample
void handler (int signo)
{
  /* Call wait() or waitpid() here for SIGCHLD aka SIGCLD */
  signal (signo, handler);
  /* Do other work here (the signal is not blocked!) */
}
þendexample

  A signal handler usually looks like this in the `BSD' and `POSIX.1'
  signal models:

þexample
void handler (int signo)
{
  /* Do the work here, the signal is blocked */
}
þendexample

  Do not use floating point math in a signal handler if the signal
  handler will return to the interrupted code.  File I/O in the signal
  handler is also dangerous because a file I/O function could have
  been interrupted by the signal.

  Only one signal of any type may be pending.  However, SIGCHLD will
  be stay pending until termination status for all terminated child
  processes has been fetched with wait() or waitpid().

þh2 Signals generated by the system

  The following signals can be generated by the system:

þdescription
þitem SIGINT
  Ctrl-C typed by user (or VINTR, see `þhpt{General terminal interface}')
þitem SIGQUIT
  VQUIT character entered (see `þhpt{General terminal interface}')
þitem SIGILL
  Illegal instruction
þitem SIGFPE
  Floating point exception or division by zero
þitem SIGSEGV
  Segmentation violation
þitem SIGPIPE
  An attempt is made to write to a pipe or named pipe that is not
  open for reading by any process
þitem SIGALRM
  alarm() timer expired
þitem SIGTERM
  Process termination request
þitem SIGCHLD
  Termination status for a child process is available
þitem SIGBREAK
  Ctrl-Break typed by user
þenddescription

  Note that SIGWINCH is not generated by the system.

  The signals SIGINT, SIGQUIT, SIGALRM, SIGTERM, SIGCHLD and SIGBREAK
  are generated in the main thread (thread 1).

  The signals SIGILL, SIGFPE and SIGSEGV are generated in the thread
  which caused the exception. If generated by an exception, these
  signals are delivered even if blocked and SIG_IGN is treated like
  SIG_DFL (however, under OS/2, the core dump will be suppressed by
  SIG_IGN).

þh3 SIGINT and SIGBREAK

  If you want to trap Ctrl-C and Ctrl-Break, register a signal handler
  for both SIGINT and SIGBREAK.  Note that typing Ctrl-Break generates
  SIGINT unless termio is used under OS/2 with the IDEFAULT bit reset.
  With a future release of emx, Ctrl-Break may generate SIGBREAK in
  all cases.  Under DOS, SIGINT generated by Ctrl-Break is delivered on
  return from the next system call or on return to protected mode from
  the next hardware interrupt, whichever comes first; SIGINT generated
  by Ctrl-C is delivered on return from the next system call which
  uses a DOS call which checks for Ctrl-C.  Under OS/2, SIGINT is
  generated and delivered asynchronously.

þh3 SIGFPE

  By default, all floating point exceptions are masked: The
  coprocessor will perform a default action (replace the result with
  a NaN, for instance) and continue without generating SIGFPE.  Use
  þhpt{_control87()} to enable floating point exceptions.  However,
  SIGFPE is not reliable.  Under DOS, SIGFPE is not supported for
  machines not compatible enough with the industry standard.

þh3 SIGTERM

  SIGTERM is implemented only under OS/2.  It is sent to a process if
  the user or another process requests the termination of the process.
  Continuing the process by calling longjmp() is not a good idea.

þh3 SIGCHLD

  SIGCHLD will be generated again if there is termination status
  available for a child process on return from the signal handler for
  SIGCHLD or when unblocking SIGCHLD or when, for the `System V'
  signal processing model, installing a signal handler for SIGCHLD.
  That is, the signal handler must call wait() or waitpid() before
  returning or unblocking the signal to avoid infinite invocation of
  the signal handler.

  Note that SIGCHLD and SIGCLD are synonyms; both names refer to the
  same signal.

  In contrast to System V, emx currently treats SIG_DFL and SIG_IGN
  identically for SIGCHLD, that is, child processes are turned into
  zombies when they terminate even if the action for SIGCHLD is
  SIG_IGN.  Moreover, the behavior of wait() and waitpid() is not
  affected by the action for SIGCHLD.

  With the system call library sys.lib (þhpt{-Zsys}), SIGCHLD is
  not generated by the system.

þh3 SIGTRAP

  In addition to the signals which can be generated by the system, the
  SIGTRAP signal can be returned by þhpt{wait()} when using
  þhpt{ptrace()}.  SIGTRAP is returned after single-stepping one
  instruction.

þh2 Sending signals to other processes

  Due to OS/2 restrictions, only SIGINT and SIGBREAK can be sent to
  arbitrary child processes.  A process can send the other signals
  only to itself, see þhpt{raise()}, or to other emx programs (which
  use emx.dll under OS/2) being immediate children of the process.

þh2 Inheriting signal handlers

  Programs which use emx.dll or emx.exe inherit the signal actions of
  the parent process if the parent process also uses emx.dll or
  emx.exe: Signals set to SIG_IGN in the parent process will be set to
  SIG_IGN in the child process, signals set to SIG_DFL in the parent
  process will be set to SIG_DFL in the child process, signals caught
  in the child process will be set to SIG_DFL in the child process.

  Programs which don't use emx.dll or emx.exe or have not been started
  by a program which uses emx.dll or emx.exe will have all signal
  actions set to SIG_DFL initially.

  Processes created by fork() inherit all signal settings (including
  sa_mask and sa_flags) of their parent process.


þh1 Sockets

  emx includes support for sockets of IBM TCP/IP for OS/2 (including
  the Internet Access Kit of OS/2 3.0).  The headers files are derived
  from NetBSD and are packaged in þtt{bsddev.zip}.  Some manual pages
  are packaged in þtt{bsddoc.zip}.

  To use IBM TCP/IP 4.0, you must compile your applications with
  þtt{-DTCPIPV4}.  Programs which use þtt{<net/if.h>} are compatible
  either with TCP/IP 4.0 or older versions, not both.

  Use the -lsocket option to link with the socket library.  Note that
  -lsocket, like all -l option, should be given þem{after} the source
  files:

þexample
gcc mymain.c mysub.c -lsocket
þendexample

  emx tries to provide seamless support for sockets, like Unix systems
  do.  This approach is quite different from the one taken by IBM's
  TCP/IP for OS/2 Toolkit.

  Sockets are not supported with the system call library sys.lib
  (þhpt{-Zsys}).

  The header <sys/so_ioctl.h>, which includes TCP/IP-specific
  definitions for ioctl(), is included by <sys/ioctl.h> only if a
  TCP/IP-related header such as <sys/socket.h> has been
  included before <sys/ioctl.h>.  If you don't want to reorder the
  þtt{#include} directives, define the symbol þtt{_EMX_TCPIP} before
  including <sys/ioctl.h>, or include <sys/so_ioctl.h> directly
  (however, the last alternative is not recommended).

þipfminitoc

þh2 Porting Unix applications

  When porting Unix applications, please note the following
  restrictions:

þitemize
þitem
  Socket handles are not inherited across þhpt{exec*()} and
  þhpt{spawn*()}.  (Note that a process created by þhpt{fork()}
  inherits the socket handles of its parent process.)  Inheriting
  socket handles is planned for a future release of emx.

þitem
  The size of messages is restricted to 32767 bytes (this is a
  limitation of IBM TCP/IP for OS/2).

þitem
  Initially, sockets are in binary mode.  Use þhpt{setmode()} to
  switch to text mode.  Text mode applies to read() and write(), only.
  þtt{recv()} and þtt{send()} always use binary mode.

þitem
  The functions þtt{recvmsg()}, þtt{sendmsg()}, and
  þtt{socketpair()} are not implemented.

þenditemize

þh2 Porting OS/2 applications

  When porting OS/2 applications written for IBM's TCP/IP for OS/2
  Toolkit, please note the following differences:

þitemize
þitem
  Socket handles and file handles share a common handle space which is
  managed by emx.dll.  To obtain the internal socket handle (used by
  IBM TCP/IP for OS/2) associated with a handle, use the
  þhpt{_getsockhandle()} function.

þitem
  þtt{sock_init()} is not required and not implemented.

þitem
  Use þhpt{close()} instead of þtt{soclose()}.

þitem
  You can use þhpt{read()} and þhpt{write()} on sockets.

þitem
  The þhpt{select()} function uses BSD semantics (except for the
  return value) and works for sockets and some other types of file
  handles.

þitem
  Use þhpt{errno} instead of þtt{sock_errno()}, and þhpt{perror()}
  instead of þtt{psock_errno()}.

þitem
  þhpt{ioctl()} of emx takes three arguments whereas the ioctl()
  function of the IBM TCP/IP for OS/2 Toolkit takes four arguments.

þitem
  The functions þtt{recvmsg()}, þtt{sendmsg()}, and
  þtt{socketpair()} are not implemented.

þenditemize


þh1 Floating-point math

  Applications which need to conform to IEEE 754 to obtain the same
  results across architectures should call þhpt{_control87()} to
  change the precision to a mantissa size of 53 bits:

þexample
_control87 (PC_53, MCW_PC);
þendexample

  The default precision is 64 bits.

  By default, all floating-point exceptions are masked off.  You can
  use þtt{_control87()} to enable floating-point exceptions.  SIGFPE
  will be raised if an unmasked floating-point exception occurs.

  Decimal to binary conversions (scanf(), strtod(), ...) and binary to
  decimal conversions (gcvt(), printf(), ...) by default conform to
  IEEE 754.  Conversion from decimal to binary does not round
  correctly if the decimal number has more than DECIMAL_DIG
  significant digits.  Currently, conversion always rounds to
  nearest/even, no matter what rounding mode is selected.

  The IEEE 754 conversion routines are slow and big.  To use the
  faster and smaller, but inaccurate, conversion routines, use the
  -Zsmall-conv option of GCC.  This saves about 14KB for programs
  which use binary to decimal conversions, about 11KB for programs
  which use decimal to binary conversions, and about 15KB for programs
  which use both.

þh1 Mutex semaphores

  In addition to OS/2's mutex semaphores (HMTX), the emx runtime
  library offers three types of mutex semaphores: _fmutex semaphores,
  _rmutex semaphores, and _smutex semaphores.

  A mutex semaphore has two states: available and owned.  At most one
  thread can own a mutex semaphore.  If a thread request ownership of
  a mutex semaphore which is already owned, the thread will be
  suspended until the semaphores becomes available.  When ownership of
  a mutex semaphore is relinquished, exactly one of the threads
  waiting for the semaphore will become the new owner and will resume
  execution.

  For all three types of emx semaphores, ownership of a semaphore is
  not tied to a thread, that is, it's not a thread which owns the
  semaphore.  This is in contrast to OS/2's mutex semaphores.
  Deadlock will occur if ownership of a semaphore is requested twice
  for the same semaphore by the same thread without relinquishing
  ownership of the semaphore between the two request.  This fact is
  important to keep in mind in presence of signals.  Signal handlers
  must not request semaphores which can be owned by the interrupted
  code.  You might want to block signals before requesting ownership
  of an emx semaphore.

þipfminitoc

þh2 _fmutex semaphores
þlabel _fmutex semaphores

  _fmutex semaphores are fast RAM semaphores which control access to a
  resource shared by threads or processes.  _fmutex semaphores must be
  created with þhpt{_fmutex_create()}. The þhpt{_fmutex_request()}
  function is used to request ownership of an _fmutex semaphore: If
  the semaphore is available, it will be set to owned and
  _fmutex_request() will return immediately.  If the semaphore is
  owned, _fmutex_request() will block while the semaphore is owned.
  When the semaphore becomes available, one of the threads blocking in
  _fmutex_request() will unblock and become the owner of the
  semaphore.  Ownership of an _fmutex semaphore is relinquished with
  þhpt{_fmutex_release()}.  If another thread blocks in
  _fmutex_request(), _fmutex_release() will unblock one of the
  blocking threads.

  þhpt{_fmutex_open()} obtains access to a shared _fmutex semaphore
  created by another process.  All threads of the process which called
  _fmutex_create() have access to the semaphore without calling
  _fmutex_open().  þhpt{_fmutex_close()} closes an _fmutex semaphore.
  Destroying _fmutex objects without calling _fmutex_close() will
  cause a semaphore leak.  þhpt{_fmutex_available()} returns the
  status of an _fmutex semaphore without blocking and without changing
  the state of the semaphore.

  Unlike _rmutex semaphores, _fmutex semaphores are not inherited by
  child processes created with fork().  In most cases, _fmutex
  semaphores cannot be used by programs which use fork().

þh2 _rmutex semaphores
þlabel _rmutex semaphores

  _rmutex semaphores are fast RAM semaphores like _fmutex semaphores.
  However, the runtime library keeps track of _rmutex semaphores (the
  `þtt{r}' is for `registered'); in consequence, _rmutex semaphores
  are inherited by child processes created with fork().  However, this
  applies only to non-shared _rmutex semaphores; shared _rmutex
  semaphores (created with the _FMC_SHARED flag) behave like _fmutex
  semaphores.  Copying and assigning _rmutex semaphores is not
  allowed.  An _rmutex object must not go out of scope or be
  deallocated while the _rmutex semaphore is open; you must close the
  semaphore before destroying the object!  _rmutex semaphores must be
  created with þhpt{_rmutex_create()}.

þh2 _smutex semaphores
þlabel _smutex semaphores

  _smutex semaphores are very simple RAM semaphores which control
  access to a resource shared by threads or processes.  These
  semaphores need not be created and destroyed, _smutex objects just
  have to be initialized to zero.  _smutex semaphores are implemented
  with looping and DosSleep.  Therefore, they should be used only if a
  collision is very unlikely, for instance, during initializing.  In
  all other cases, _fmutex, _rmutex, or HMTX semaphores should be
  used.

  An _smutex semaphore is available if object of type _smutex is
  (explicitely or implicitely initialized to) zero.  The
  þhpt{_smutex_request()} function is used to request ownership of an
  _smutex semaphore: If the semaphore is available, it will be set to
  owned and _smutex_request() will return immediately.  If the
  semaphore is owned, _smutex_request() will not return while the
  semaphore is owned.  When the semaphore becomes available, one of
  the threads blocking in _smutex_request() will unblock sooner or
  later and will become the owner of the semaphore.  Ownership of an
  _smutex semaphore is relinquished with þhpt{_smutex_release()}.
  þhpt{_smutex_available()} returns the status of an _smutex semaphore
  without blocking and without changing the state of the semaphore.
  An _smutex semaphore can be used by multiple processes if the
  _smutex object is in shared memory.


þh1 Function reference
þi1 Functions

  The functions are listed almost alphabetically.
þif text
  The origin of most of the functions is shown in [brackets] at the
  end of the first line.  Functions which are not available or are
  limited with the system call library (-Zsys, sys.lib) are marked
  * in [brackets].
þelse
  Functions which are not available or are limited with the system
  call library (þhpt{-Zsys}, sys.lib) are marked * in the `Compatibility'
  section.
þendif


þfunction abort()
þcompat C90 POSIX.1
þheaders
#include <stdlib.h>
þendheaders

þprototype
void abort (void);
þendprototype

    abort() causes abnormal termination of the process, unless the
    signal SIGABRT is caught, and not blocked, and the signal handler
    does not return.  If SIGABRT is blocked, the signal handler won't
    be called.

    If abort() causes termination of the process, open streams and
    file handles will be closed prior to termination of the process.
    The process is terminated by calling þtt{raise (SIGABRT)} with the
    signal action associated with SIGABRT being set to SIG_DFL.

þreturnvalue

    abort() does not return.

þimplementation

    The default action for SIGABRT is to display the message

þexample
Abnormal program termination
þendexample

    and dump core (for post mortem debugging) and terminate the
    process with return code 3.

þseealso exit() _exit() raise() sigaction() signal()


þfunction abs()
þcompat C90
þheaders
#include <stdlib.h>     /* use this */
#include <math.h>       /* or this */
þendheaders

þparam N
þprototype
int abs (int N);
þendprototype

    Return the absolute value of N: If N is negative, -þpa{N} is
    returned.  Otherwise, N is returned.

þreturnvalue

    abs() returns the absolute value of its argument.

þimplementation

    In-line code is generated for this function.

þseealso fabs() labs()


þfunction _abspath()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam DST SRC SIZE
þprototype
int _abspath (char *DST, const char *SRC, int SIZE);
þendprototype

    Construct an absolute path name for the file name or directory
    name pointed to by SRC.  The absolute path name is written to the
    array pointed to by DST.  It is assumed that there are SIZE bytes
    available at DST, this includes the terminating null character.
    If there is an error, -1 is returned.  If _abspath() succeeds, 0
    is returned.  If SIZE is too small, errno is set to ERANGE and -1
    is returned.  DST can be identical to SRC.  Backslashes are
    translated into forward slashes.  The absolute path name is not
    translated to lower case.  If the string pointed to by SRC ends
    with a slash or backslash, the string pointed to by DST will end
    with a slash.

    In contrast to _fullpath(), _abspath() works with non-existing
    paths: it accesses the appropriate drive only for finding out the
    current working directory if necessary.

    _abspath() properly handles DBCS characters.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso _fnisabs() _fnisrel() _fullpath() _nls_init()


þfunction access()
þcompat UNIX
þheaders
#include <io.h>
þendheaders

þparam NAME MODE
þprototype
int access (const char *NAME, int MODE);
þendprototype

    Check whether MODE access is allowed for the file or directory
    whose name is in the string pointed to NAME.  If MODE is F_OK (0),
    access() checks only for existence of the file or directory.  If
    MODE is W_OK (2), access() checks for write permission.  If MODE
    is R_OK (4), access() checks for read permission (always granted
    under DOS and OS/2 if the file exists).  If MODE is þtt{R_OK|W_OK}
    (6), access() checks for read and write permission.

þreturnvalue

    access() returns 0 if the file or directory is accessible in mode
    MODE.  Otherwise, access() set errno and returns -1.

þerrors

þdescription

þitem EACCES

    Access to the file or directory is not permitted

þitem ENAMETOOLONG

    The file or directory name is too long

þitem ENOENT

    The file or directory does not exist

þenddescription

þrestrictions

    access() does not work with devices (errno is set to ENOENT).
    X_OK is ignored.

þseealso open() stat()


þfunction alarm()
þcompat UNIX *
þheaders
#include <stdlib.h>
þendheaders

þparam SEC
þprototype
unsigned alarm (unsigned SEC);
þendprototype

    Cause SIGALRM to be generated after SEC seconds have expired.
    alarm() returns immediately after setting the alarm clock.  There
    is only one alarm clock; when calling alarm() while the alarm
    clock is running the time will be reset to the new value.  If SEC
    is zero, the alarm clock will be stopped.

þreturnvalue

    alarm() returns the number of seconds remaining on the alarm clock
    before setting the new value.

þimplementation

    In a multithread process, there is a single alarm clock which
    can be set from all the threads.  SIGALRM is always generated and
    delivered in the main thread (thread 1).

þrestrictions

    alarm() is not available with the system call library sys.lib
    (þhpt{-Zsys}).

    Under DOS, SIGALRM is not delivered until return from DOS if the
    timer expired during a DOS call.

þseealso raise() sigaction() signal() sleep() _sleep2()


þfunction alloca()
þheaders
#include <alloca.h>
þendheaders

þparam N
þprototype
void *alloca (size_t N);
þendprototype

    Allocate N bytes from the current stack frame.  The memory space
    allocated by alloca() will be freed on exit from the current
    function.  Do not pass the pointer returned by alloca() to free().

þreturnvalue

    alloca() returns a pointer to a block of memory in the stack.

þrestrictions

    This note applies only if you need stack probes (þhpt{-mprobe}
    option of GCC):

    If alloca() with constant argument occurs in the first statement
    of a function with less than 4096 bytes of local data or if two
    calls to alloca() with constant arguments occur twice in a row
    without accessing the memory pointed to by the return value of the
    first call, you have to change your code to make GCC generate
    correct stack probes.  This can be done by storing a dummy value
    to the return value of alloca().  Example:

þexample
p = alloca (0xf00);
{char *fix=alloca (0); *fix = 0;}
q = alloca (0xf00);
þendexample

þseealso malloc() _tmalloc()

þsamplecode
void test (void)
{
  char local[0xf00], *p;

  {char *fix=alloca (0); *fix = 0;}
  p = alloca (0xf00);
  /*...*/
}
þendsamplecode


þfunction asctime()
þcompat C90
þheaders
#include <time.h>
þendheaders

þparam T
þprototype
char *asctime (const struct tm *T);
þendprototype

    Convert the time and date in the structure pointed to by T to a
    string.  A pointer to the string is returned.  There is only one
    memory location for the ctime() and asctime() results, a call to
    ctime() or asctime() overwrites the result of a previous calls to
    ctime() or asctime().  As localtime() is called by ctime(), the
    memory location shared by localtime(), gmtime(), and mktime() is
    overwritten.  The string looks like

þexample
"Sun Mar  2 07:59:18 1992\n"
þendexample

    with a terminating null character.  All fields have fixed width.

þreturnvalue

    asctime() returns a pointer to a string containing the textual
    representation of its argument.

þseealso ctime() gmtime() localtime() mktime()


þfunction acos() asin() atan() atan2() acosl() asinl() atanl() atan2l()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X Y
þprototype
double acos (double X);
double asin (double X);
double atan (double X);
double atan2 (double Y, double X);

long double acosl (long double X);
long double asinl (long double X);
long double atanl (long double X);
long double atan2l (long double Y, long double X);
þendprototype

    asin(), acos(), and atan() compute the arc sine, arc cosine and
    arc tangent of X, respectively.  atan2() computes the arctangent
    of þpa{Y}/þpa{X}, using the signs of Y and X to determine the
    quadrant.  If X is outside [-1,1], asin() and acos() return a NaN
    and set errno to EDOM.

    acosl(), asinl(), atanl() and atan2l() use the þtt{long double}
    format.

þreturnvalue

    acos(), asin(), atan() and atan2() return the arc sine, arc cosine
    or arc tangent, respectively, of their argument.  These functions
    return a NaN on error.

þseealso cos() sin() tan()


þfunction assert()
þcompat C90
þheaders
#include <assert.h>
þendheaders

þparam EXP FILE LINE
þprototype
void assert (int EXP);
þendprototype

    If the preprocessor macro NDEBUG is defined at the time <assert.h>
    is included, assert() does nothing.  Otherwise, if EXP is zero,
    the message

þtypewriter
    Assertion failed: þpa{EXP}, file þpa{FILE}, line þpa{LINE}
þendtypewriter

    is displayed and the program is aborted by calling abort().  EXP,
    FILE and LINE are replaced with EXP (as text), the source file
    name and the source line number, respectively.  If EXP is
    non-zero, nothing is done.

þseealso abort()


þfunction atexit()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam FUNC
þprototype
int atexit (void (*FUNC)(void));
þendprototype

    The function FUNC will be called when the process is terminated.
    The last function installed by calling atexit() will be called
    first.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þimplementation

    Up to 32 functions can be installed.

þseealso abort() exit() _exit()


þfunction atof() atoi() atol() _atofl() _atoll()
þcompat C90
þheaders
#include <stdlib.h>
#include <math.h>  /* alternate include file for atof() */
þendheaders

þparam STRING
þprototype
double atof (const char *STRING);
int atoi (const char *STRING);
long atol (const char *STRING);

long double _atofl (const char *STRING);
long long _atoll (const char *STRING);
þendprototype

    Convert the textual, decimal representation of a number in the
    string pointed to by STRING to a number.  Leading whitespace is
    ignored.  If the string cannot be converted, 0 (or 0.0) is
    returned.  The value of errno is not reliable.

    The decimal point character of the current locale is used by
    atof() and _atofl().

    _atofl() uses the þtt{long double} format and is not an ISO C
    function.  _atoll() uses the þtt{long long} format and is not an
    ISO C function.

þreturnvalue

    These functions return their argument as number.  They return 0
    (or 0.0) on error.

þseealso _ltoa() scanf() setlocale() strtod() strtol()


þfunction bcmp()
þcompat BSD
þheaders
#include <strings.h>
þendheaders

þparam BUFFER1 BUFFER2 N
þprototype
int bcmp (const void *BUFFER1, const void *BUFFER2, size_t N);
þendprototype

    Compare the first N bytes at BUFFER1 to the first N bytes at
    BUFFER2.  If the two buffers are identical (or if N is zero), 0 is
    returned.  Otherwise, a non-zero value is returned.

þreturnvalue
þdescription
þitem 0
    the buffers are identical
þitem non-0
    the buffers are different
þenddescription

þseealso memcmp()


þfunction bcopy()
þcompat BSD
þheaders
#include <strings.h>
þendheaders

þparam SRC DST N
þprototype
void bcopy (const void *SRC, void *DST, size_t N);
þendprototype

    Copy memory.  Copy N bytes from SRC to DST.

þimplementation

    The two regions may overlap.

þseealso memcpy() memmove()


þfunction _beginthread()
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þparam START ARG STACK STACK_SIZE ARG_LIST
þprototype
int _beginthread (void (*START)(void *ARG), void *STACK, unsigned STACK_SIZE,
                  void *ARG_LIST);
þendprototype

    Start a thread.  START is the start address (a function).
    ARG_LIST will be passed in the ARG parameter of the START
    function.  STACK is ignored, using NULL is recommended.
    STACK_SIZE is the size of the stack for the new thread.  When the
    START function returns, the thread is terminated by an automatic
    call to _endthread().  A thread can also terminate itself by
    calling _endthread().  If successful, _beginthread() returns the
    thread ID.  On error, _beginthread() sets errno and returns -1.
    The stack allocated for the new thread is completely committed,
    that is, stack probes are not required.

    _beginthread() is preferred over DosCreateThread because it
    initializes the C library.

þreturnvalue

    _beginthread() returns the thread ID of the new thread.  It
    returns -1 on error.

þrestrictions

    _beginthread() is available in the multithread libraries only
    (-Zmt, -Zmts, or -Zmtd).

þhints

     STACK_SIZE should be at least 32768.  Specifying a big stack size
     doesn't hurt.

þseealso _endthread() _gettid() _threadid _threadstore()


þfunction brk()
þcompat UNIX
þheaders
#include <stdlib.h>
þendheaders

þparam ADDR
þprototype
void *brk (void *ADDR);
þendprototype

    Change the end address of the data segment to ADDR.  On success,
    brk() returns 0, cast as pointer.  Otherwise, -1 cast as pointer
    is returned and errno set to ENOMEM.  Please don't use brk() --
    use malloc() instead for memory allocation.

    brk() never allocates non-contiguous memory; in consequence,
    allocation with brk() is limited by the size of the memory object
    of the heap.  On the other hand, sbrk() may add memory objects to
    the heap if non-contiguous allocation has been enabled with
    _uflags().  Setting back the memory limit into a gap produced
    non-contiguous allocation by sbrk() is not possible.  However,
    brk() can be used to deallocate memory objects allocated by
    sbrk().

þreturnvalue
þlist
þitem þtt{(void *)0}
    success
þitem þtt{(void *)-1}
    error
þendlist

þseealso malloc() sbrk() _uflags() ulimit()


þfunction bsearch()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam KEY BASE NUM WIDTH COMPARE ELEMENT
þprototype
void *bsearch (const void *KEY, const void *BASE, size_t NUM, size_t WIDTH,
               int (*COMPARE)(const void *KEY, const void *ELEMENT));
þendprototype

    Perform a binary search on the sorted array BASE to find KEY.  The
    array has NUM elements of size WIDTH bytes each.  bsearch() calls
    COMPARE to compare an array element pointed to by ELEMENT with
    KEY.  COMPARE should return 0 if KEY and ELEMENT are equal; a
    negative value, if KEY is smaller than ELEMENT; a positive value
    if KEY is greater than ELEMENT with respect to the sorting order
    of BASE.  If there are multiple occurrences of KEY in BASE,
    bsearch() returns a pointer to any one of the entries.  If the
    array pointed to by BASE is not sorted, bsearch() does not work.

þreturnvalue

    bsearch() returns a pointer to an occurrence of KEY in
    the array.  If KEY is not found, bsearch() returns NULL.

þseealso qsort()


þfunction bzero()
þcompat BSD
þheaders
#include <strings.h>
þendheaders

þparam BUFFER N
þprototype
void bzero (void *BUFFER, size_t N);
þendprototype

    Set N bytes at BUFFER to 0.

þseealso calloc() memset()


þfunction calloc()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam ELEMENTS SIZE
þprototype
void *calloc (size_t ELEMENTS, size_t SIZE);
þendprototype

    Allocate a block of memory big enough for holding ELEMENTS
    elements of SIZE bytes each.  calloc() fills the block with zeros.
    If there is an error, calloc() returns NULL.

þimplementation

    calloc() allocates from the default heap of the current thread.
    If at least one argument is zero, calloc() returns a non-NULL
    pointer if there's enough space left in the heap for a block of
    the minimum size.

þreturnvalue

    calloc() returns a pointer to a newly allocated block of memory.
    On error, calloc() returns NULL.

þseealso free() malloc() _msize() _tcalloc() _ucalloc() _udefault()


þfunction cbrt() _cbrtl()
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
double cbrt (double X);
long double _cbrtl (long double X);
þendprototype

    Compute the cube root of X.  This is done by calling
    pow() and adjusting the sign.

    _cbrtl() uses the þtt{long double} format and is an þbf{emx}-specific
    function.

þreturnvalue

    cbrt() returns the cube root of its argument.

þseealso pow() sqrt()


þfunction ceil() ceill()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
double ceil (double X);
long double ceill (long double X);
þendprototype

    Compute the smallest integer that is greater than or equal to X
    (round up).

    ceill() uses the þtt{long double} format.

þreturnvalue

    ceil() returns as floating-point number the smallest integer that
    is greater than or equal to X.

þseealso floor() rint() trunc()


þfunction cfgetispeed() cfgetospeed()
þcompat POSIX.1 *
þheaders
#include <termios.h>
þendheaders

þparam PTERMIOS
þprototype
speed_t cfgetispeed (const struct termios *ptermios);
speed_t cfgetospeed (const struct termios *ptermios);
þendprototype

    cfgetispeed() returns the input bit rate stored in the structure
    pointed to by PTERMIOS.

    cfgetospeed() returns the output bit rate stored in the structure
    pointed to by PTERMIOS.

    See `þhpt{General terminal interface}' for details.

þreturnvalue

    cfgetispeed() and cfgetospeed() return a bit rate.  Bit rates are
    represented by the symbols þtt{B0} through þtt{B38400}.

þrestrictions

    Asynchronous lines are not yet supported.

þseealso cfsetispeed() cfsetospeed() tcgetattr() tcsetattr()


þfunction cfsetispeed() cfsetospeed()
þcompat POSIX.1 *
þheaders
#include <termios.h>
þendheaders

þparam PTERMIOS SPEED
þprototype
int cfsetispeed (struct termios *ptermios, speed_t speed);
int cfsetospeed (struct termios *ptermios, speed_t speed);
þendprototype

    cfsetispeed() and cfsetospeed() set the input bit rate and output
    bit rate, respectively, in the structure pointed to by PTERMIOS
    from the value of SPEED.  Bit rates are represented by the symbols
    þtt{B0} through þtt{B38400}.

    See `þhpt{General terminal interface}' for details.

þreturnvalue

    cfsetispeed() and cfsetospeed() return 0 if successful.
    Otherwise, cfsetispeed() and cfsetospeed() set errno and return
    -1.

þerrors
þdescription
þitem EINVAL
  The bit rate SPEED is not valid.
þenddescription

þrestrictions

    Asynchronous lines are not yet supported.

þseealso cfgetispeed() cfgetospeed() tcgetattr() tcsetattr()


þfunction chdir()
þcompat UNIX
þheaders
#include <stdlib.h>
þendheaders

þparam NAME
þprototype
int chdir (const char *NAME);
þendprototype

    Change to directory whose name is in the string pointed to by
    NAME.  If the name contains a drive letter, the working directory
    on that drive is changed, but the selected drive does not change.

    chdir() properly handles DBCS characters.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þrestrictions

    Under DOS, the current working directory is not a property of a
    process, it is a system-wide property.  That may change in a future
    release of emx.  þtt{chdir ("..")} fails if the current working
    directory is the root directory.

þseealso _chdir2() getcwd() _nls_init()


þfunction _chdir2()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam NAME
þprototype
int _chdir2 (const char *NAME);
þendprototype

    Change to the directory whose name is in the string pointed to by
    NAME.  If the name contains a drive letter, that drive is selected
    before changing to the directory.  If the name contains a drive
    letter, the directory can be omitted:

    _chdir2() properly handles DBCS characters.

þexample
_chdir2 ("c:")
þendexample

    is equivalent to

þexample
_chdrive ('C')
þendexample

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þrestrictions

    Under DOS, the current working directory and the default drive is
    not a property of a process, it's a system-wide property.  That
    may change in a future release of emx.  þtt{_chdir ("..")} fails
    if the current working directory is the root directory.


þseealso chdir() getcwd() _nls_init()


þfunction _chdrive()
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þparam DRIVE
þprototype
int _chdrive (char DRIVE);
þendprototype

    Make the disk drive DRIVE the default drive.  DRIVE must be in
    þtt{'A'} through þtt{'Z'} or in þtt{'a'} through þtt{'z'}.

þreturnvalue

    _chdrive() always returns 0, even if the drive does not exist.

þseealso _chdir2() _getdrive()


þfunction chmod()
þcompat UNIX
þheaders
#include <io.h>
#include <sys/stat.h>
þendheaders

þparam NAME PMODE
þprototype
int chmod (const char *NAME, int PMODE);
þendprototype

    Change permission settings of the file whose name is in the string
    pointed to by NAME to PMODE.  There is only one permission bit
    under OS/2 and DOS, the read-only attribute.  The read-only bit is
    set if S_IWRITE is not included in PMODE.  Either specify
    þtt{S_IREAD|S_IWRITE} or þtt{S_IREAD} for PMODE.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þrestrictions

    Only the S_IWRITE bit of PMODE is used.

þseealso creat() open() stat() umask()


þfunction chsize()
þcompat PC
þheaders
#include <io.h>
þendheaders

þparam HANDLE SIZE
þprototype
int chsize (int HANDLE, long SIZE);
þendprototype

    Change the length of the file associated with HANDLE to SIZE
    bytes.  The position of the file pointer is undefined after
    calling this function.  If SIZE is greater than the current length
    of the file, bytes of zeros are appended.  HANDLE must be open for
    writing.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso ftruncate() lseek()


þfunction _clear87()
þcompat PC
þheaders
#include <float.h>
þendheaders

þprototype
unsigned _clear87 (void);
þendprototype

    Clear the coprocessor status word.

þreturnvalue

    _clear87() returns the previous value of the status word.

þseealso _control87() _fpreset() _status87()


þfunction clearerr()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
void clearerr (FILE *STREAM);
þendprototype

    Clear the error and end-of-file indicators of STREAM.

þseealso ferror() feof()


þfunction clock()
þcompat C90
þheaders
#include <time.h>
þendheaders

þprototype
clock_t clock (void);
þendprototype

    clock() returns the amount of processor time (timer ticks) used by
    the calling process since the process has been started.  There are
    CLOCKS_PER_SEC timer ticks per second.

þreturnvalue

    clock() returns the number of timer ticks used by the process.

þrestrictions

    clock() returns the time elapsed, not the CPU time.

þseealso time()


þfunction close()
þcompat UNIX
þheaders
#include <io.h>
þendheaders

þparam HANDLE
þprototype
int close (int HANDLE);
þendprototype

    Close the file associated with the handle HANDLE.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso dup() open()


þfunction _control87()
þcompat PC
þheaders
#include <float.h>
þendheaders

þparam NEW_CW MASK
þprototype
unsigned _control87 (unsigned NEW_CW, unsigned MASK);
þendprototype

    Set the coprocessor control word.  Bits of the control word set in
    MASK are replaced with the matching bits of NEW_CW:

þexample
cw = ((cw & ~mask) | (new_cw & mask));
þendexample

    If MASK is 0, the control word is not changed.  MASK should be one
    of the following symbols:
þdescription
þitem MCW_EM
  Exception masks
þitem MCW_IC
  Infinity control (ignored by the 387 and later)
þitem MCW_RC
  Rounding control
þitem MCW_PC
  Precision control
þenddescription
  To pass multiple values in NEW_CW, use the þtt{|} operator to
  combine the symbols described below.

  If MASK includes MCW_EM, any combination of the following symbols,
  including none (0), can be used in NEW_CW.  If one of these symbol
  is included, the corresponding exception is masked off, that is, the
  coprocessor will take a corrective action and continue.  If an
  exception is not masked off, SIGFPE will be generated by that
  exception.
þdescription
þitem EM_INVALID
  Invalid operation (corrective action: return a NaN)
þitem EM_DENORMAL
  Denormalized operand (corrective action: use
  gradual underflow)
þitem EM_ZERODIVIDE
  Division by zero (corrective action: return infinity)
þitem EM_OVERFLOW
  Overflow (corrective action: return infinity)
þitem EM_UNDERFLOW
  Underflow (corrective action: return a denormal or zero)
þitem EM_INEXACT
  Precision lost (corrective action: ignore)
þenddescription
  By default, all floating-point exceptions are masked off.

  If MASK includes MCW_RC, exactly one of the following symbols should
  be used in NEW_CW:
þdescription
þitem RC_NEAR
  Round to nearest or even (default)
þitem RC_DOWN
  Round down toward -infinity
þitem RC_UP
  Round up toward infinity
þitem RC_CHOP
  Chop by truncating toward zero
þenddescription

  If MASK includes MCW_PC, exactly one of the following symbols should
  be used in NEW_CW:
þdescription
þitem PC_24
  24-bit mantissa
þitem PC_53
  53-bit mantissa
þitem PC_64
  64-bit mantissa (default)
þenddescription
  Only addition, subtraction, multiplication, division, and sqrt() are
  affected by the precision-control bits.  Note that IEEE 754 requires
  PC_53, which is not the default setting.

þreturnvalue

    _control87() returns the previous value of the control word.

þseealso _clear87() _fpreset()

þsamplecode
_control87 (PC_53, MCW_PC);     /* Round to 64-bit double */
þendsamplecode


þfunction copysign() copysignf() copysignl()
þcompat C9X
þheaders
#include <math.h>
þendheaders

þparam X Y
þprototype
double copysign (double X, double Y);
float copysignf (float X, float Y);
long double copysignl (long double X, long double Y);
þendprototype

    Return a value with the magnitude of X and the sign bit of Y.

þreturnvalue

    copysign() returns a value with the magnitude of X and the sign
    bit of Y.


þseealso fpclassify() nextafter() signbit()


þfunction _core()
þcompat emx *
þheaders
#include <stdlib.h>
þendheaders

þparam HANDLE
þprototype
int _core (int HANDLE);
þendprototype

    Write a core dump to the file associated with HANDLE.  HANDLE must
    be open for writing.  The core dump file can be used later for
    debugging or for creating another .exe file which includes the
    data as saved when _core() was called.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þrestrictions

    _core() works only in programs linked with ld.  It does not work
    in programs linked with LINK386.  _core() is not available with
    the system call library sys.lib (þhpt{-Zsys}).

þseealso close() open() raise() sigaction() signal()


þfunction cos() sin() tan() cosl() sinl() tanl()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
double cos (double X);
double sin (double X);
double tan (double X);

long double cosl (long double X);
long double sinl (long double X);
long double tanl (long double X);
þendprototype

    cos(), sin(), and tan() compute the sine, cosine and tangent of X,
    respectively.

    cosl(), sinl() and tanl() use the þtt{long double} format.

þreturnvalue

    The cos(), sin() and tan() functions return the cosine, sine and
    tangent, respectively, of their argument.

þimplementation

    If the absolute value of X is greater than or equal to 2^63,
    sin(), sinl(), tan(), and tanl() return 0.0, cos() and cosl()
    return 1.0.

þseealso acos() asin() atan()


þfunction cosh() sinh() tanh() coshl() sinhl() tanhl()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
double cosh (double X);
double sinh (double X);
double tanh (double X);

long double coshl (long double X);
long double sinhl (long double X);
long double tanhl (long double X);
þendprototype

    cosh(), sinh(), and tanh() compute the hyperbolic cosine,
    hyperbolic sine and hyperbolic tangent of X, respectively.  On
    overflow, +INF or -INF is returned and errno set to ERANGE.

    coshl(), sinhl() and tanhl() use the þtt{long double} format.

þreturnvalue

    The cosh(), sinh() and tanh() functions return the hyperbolic
    cosine, hyperbolic sine and hyperbolic tangent, respectively, of
    their argument.  These functions return NaN on error.

þseealso exp()


þfunction creat()
þcompat UNIX
þheaders
#include <io.h>
#include <sys/stat.h>
þendheaders

þparam NAME PMODE
þprototype
int creat (const char *NAME, int PMODE);
þendprototype

    Create a file whose name is in the string pointed to by NAME with
    permission settings PMODE.  This is equivalent to

þtypewriter
  open (þpa{name}, O_WRONLY|O_TRUNC|O_CREAT, þpa{pmode})
þendtypewriter

þreturnvalue

    creat() returns a file handle of the new file.  On error, creat()
    sets errno and returns -1.

þseealso open()


þfunction _crlf()
þcompat emx
þheaders
#include <io.h>
þendheaders

þparam BUF SIZE NEW_SIZE
þprototype
int _crlf (char *BUF, size_t SIZE, size_t *NEW_SIZE);
þendprototype

    Translate CR/LF pairs to newline characters.  The conversion is
    done in-place in the array of SIZE characters pointed to by BUF.
    The new size is stored to *NEW_SIZE.

þreturnvalue

    _crlf() returns 1 if the buffer ends with a CR.  Otherwise,
    _crlf() returns 0.

þseealso fread() _fsetmode() read() setmode()


þfunction _crotl() _crotr()
þcompat VAC++
þheaders
#include <sys/builtin.h>
þendheaders

þparam VALUE SHIFT
þprototype
unsigned char _crotl (unsigned char VALUE, int SHIFT);
unsigned char _crotr (unsigned char VALUE, int SHIFT);
þendprototype

    _crotl() returns VALUE (8 bits) rotated left by SHIFT bits.  If
    SHIFT is 1, bit 6 is returned as bit 7, bit 5 is returned as bit
    6, and so on, bit 0 is returned as bit 1, and bit 7 is returned as
    bit 0.

    _crotr() returns VALUE (8 bits) rotated right by SHIFT bits.  If
    SHIFT is 1, bit 1 is returned as bit 0, bit 2 is returned as bit
    1, and so on, bit 7 is returned as bit 6, and bit 0 is returned as
    bit 7.

    SHIFT should be 0 through 7.

    These functions are implemented as inline functions.

þseealso _lrotl() _lrotr() _srotl() _srotr()


þfunction _CRT_init() _CRT_term()
þcompat OS/2

þprototype
int _CRT_init (void);
void _CRT_term (void);
þendprototype

    These two functions are provided for being called from
    _DLL_InitTerm(), the DLL initialization and termination function.

    _CRT_init() initializes the C run-time library if it has not yet
    been initialized.

    _CRT_term() terminates the C run-time library if it has not yet
    been terminated.

þreturnvalue

    _CRT_init() returns

þdescription
þitem 0
    if successful
þitem -1
    on error
þenddescription

þseealso _DLL_InitTerm() __ctordtorInit() __ctordtorTerm()

þsamplefile /emx/test/testdll1.c


þfunction ctime()
þcompat C90
þheaders
#include <time.h>
þendheaders

þparam T
þprototype
char *ctime (const time_t *T);
þendprototype

    Convert the number of seconds elapsed since 00:00:00 1-Jan-1970
    Coordinated Universal Time (UTC, GMT) in the variable pointed to
    by T to a string representing that moment for the local timezone.
    A pointer to the string is returned.  There is only one memory
    location for the ctime() and asctime() results, a call to ctime()
    or asctime() overwrites the result of a previous calls to ctime()
    or asctime().  As localtime() is called by ctime(), the memory
    location shared by localtime(), gmtime(), and mktime() is
    overwritten.  The string looks like

þexample
"Sun Mar  2 07:59:18 1992\n"
þendexample

    with a terminating null character.  All fields have fixed width.

þreturnvalue

    ctime() returns a pointer to a string containing the textual
    representation of its argument.

þseealso asctime() gmtime() localtime() mktime()


þfunction __ctordtorInit() __ctordtorTerm()
þcompat OS/2

þprototype
void __ctordtorInit (void);
void __ctordtorTerm (void);
þendprototype

    These two functions are provided for being called from
    _DLL_InitTerm(), the DLL initialization and termination function.

    __ctordtorInit() invokes the constructors for the static objects
    of the DLL.  You should call __ctordtorInit() after calling
    _CRT_init().

    __ctordtorTerm() invokes the destructors for the static objects of
    the DLL.  You should call __ctordtorTerm() before calling
    _CRT_term().

þseealso _CRT_init() _CRT_term() _DLL_InitTerm()


þfunction cuserid()
þcompat UNIX
þheaders
#include <stdio.h>              /* prototype and L_cuserid constant */
#include <unistd.h>             /* prototype */
þendheaders


þparam BUFFER
þprototype
char *cuserid (char *BUFFER);
þendprototype

    Return the login name of the owner of current process.  If BUFFER
    is NULL, a pointer to a statically allocated buffer is returned.
    Otherwise, the login name is copied to the array pointed to by
    BUFFER.  The array must be big enough to hold L_cuserid
    characters.  If there is an error, NULL is returned.

þimplementation

    The emx implementation of cuserid() takes the login name from the
    USER environment variable.  If that environment variable is not
    defined, the login name is þtt{"root"}.

þreturnvalue

    cuserid() returns BUFFER if BUFFER is not a null pointer.
    cuserid() returns a pointer to a statically allocated buffer if
    BUFFER is NULL.  cuserid() returns NULL on error.

þseealso getpwent()


þfunction __cxchg() __lxchg() __sxchg() 
þcompat VAC++
þheaders
#include <sys/builtin.h>
þendheaders

þparam P V
þprototype
signed char __cxchg (volatile signed char *p, signed char v);
int         __lxchg (volatile int *p,         int v);
short       __sxchg (volatile short *p,       short v);
þendprototype

    These functions atomically store V in the object pointed to by P
    and return the previous value of that object.  As this operation
    is done atomically, these functions can be used for implementing
    semaphores.  In fact, __cxchg() is used for implementing _fmutex
    and _smutex semaphores.

    These functions are implemented as inline functions.

þreturnvalue

    These functions return the previous value of the object pointed to
    by P.

þseealso _fmutex_request() _smutex_request()


þfunction _defext()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam DST EXT
þprototype
void _defext (char *DST, const char *EXT);
þendprototype

    Add the default extension EXT to the file name pointed to by DST.
    If the file name part of the string pointed to by DST contains an
    extension (including the empty extension), nothing will be done.
    Otherwise, a dot and the string pointed to by EXT will be
    appended.

    _defext() properly handles DBCS characters.

þseealso _getext() _nls_init() _remext() _splitpath()


þfunction difftime()
þcompat C90
þheaders
#include <time.h>
þendheaders

þparam T1 T0
þprototype
double difftime (time_t T1, time_t T0);
þendprototype

    Compute the difference (in seconds) between two time values.

þreturnvalue

    difftime() returns the difference (in seconds) þpa{T1}-þpa{T0}
    between T0 and T1.


þfunction __disable() __enable()
þcompat VAC++
þheaders
#include <sys/builtin.h>
þendheaders

þprototype
void __disable (void);
void __enable (void);
þendprototype

    __disable() disables interrupts, __enable() enables interrupts.
    Note that these functions cause an access violation unless dirty
    tricks are used (see xf86sup.sys).

    These functions are implemented as inline functions.


þfunction div() ldiv()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam NUM DEN
þprototype
div_t div (int NUM, int DEN);
ldiv_t ldiv (long NUM, long DEN);
þendprototype

    Perform an integer division, dividing NUM by DEN.  The quotient
    and the remainder are returned in the quot and rem fields,
    respectively.

    The following table shows the signs of quot and rem depending on
    the signs of NUM and DEN:

þexample
NUM DEN ³ quot rem
ÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ
 +   +  ³  +    +
 +   -  ³  -    +
 -   +  ³  -    -
 -   -  ³  +    -
þendexample

    þbf{Note:} Do not use the -fpcc-struct-return option of GCC.

þreturnvalue

    div() and ldiv() return a structure which contains the quotient
    and the remainder in the quot and rem fields, respectively.

þseealso _lldiv() _uldiv() _ulldiv()


þfunction _DLL_InitTerm()
þcompat OS/2

þparam MOD_HANDLE FLAG
þprototype
unsigned long _DLL_InitTerm (unsigned long MOD_HANDLE, unsigned long FLAG);
þendprototype

    _DLL_InitTerm() is the library initialization and termination
    function for dynamic link libraries.  It is called by the
    operating system to initialize the library (if FLAG is zero) or to
    terminate the library (if FLAG is one).  MOD_HANDLE is the module
    handle of the dynamic link library.

    For all types of DLLs, the default _DLL_InitTerm() function calls
    __ctordtorInit() and __ctordtorTerm().  _CRT_init() is called for
    all types of DLLs except for DLLs without runtime environment
    (-Zno-rte).  _CRT_term() is called for stand-alone DLLs (-Zso) and
    for custom C runtime DLLs.

    If you write your own _DLL_InitTerm() to perform additional
    actions, don't forget to call _CRT_init() -- if required -- to
    initialize the runtime environment and to call __ctordtorInit()
    (after calling _CRT_init()) to invoke the static constructors of
    the DLL.  On termination (FLAG is one), you should call
    _CRT_term() in DLLs which include a C runtime environment .  To
    invoke the static destructors of the DLL, call __ctordtorTerm()
    before calling _CRT_term().

    If the DLL shares the heap with the program (for instance, if both
    use emxlibcs.dll) and if _DLL_InitTerm() uses the heap (by calling
    sbrk(), malloc(), etc.), fork() will always fail for that program.

þreturnvalue

    _DLL_InitTerm() should return 1 to indicate success.  On failure,
    _DLL_InitTerm() should return 0.

þseealso _CRT_init() _CRT_term() __ctordtorInit() __ctordtorTerm() fork()

þsamplecode
/* This is the default _DLL_InitTerm() function for
   stand-alone dynamic link libraries. */

int _CRT_init (void);
void _CRT_term (void);
void __ctordtorInit (void);
void __ctordtorTerm (void);

unsigned long _DLL_InitTerm (unsigned long mod_handle,
                             unsigned long flag)
{
  switch (flag)
    {
    case 0:
      if (_CRT_init () != 0)
        return 0;
      __ctordtorInit ();
     return 1;
    case 1:
      __ctordtorTerm ();
      _CRT_term ();
      return 1;
    default:
      return 0;
    }
  return 1;
}
þendsamplecode


þfunction _dt_free()
þcompat emx
þheaders
#include <sys/dirtree.h>
þendheaders

þparam DT
þprototype
void _dt_free (struct _dt_tree *DT);
þendprototype

    Deallocate the memory allocated by _dt_read() for the directory
    tree DT.

þseealso _dt_read()


þfunction _dt_read()
þcompat emx
þheaders
#include <sys/dirtree.h>
þendheaders

þparam DIR MASK FLAGS
þprototype
struct _dt_tree *_dt_read (const char *DIR, const char *MASK, unsigned FLAGS);
þendprototype

    Create a directory tree in memory.  The tree consists of a linked
    list of _dt_node structures.  Subtrees are attached to the
    þtt{sub} field of _dt_node structures for directories.  Files
    matching the wildcard in the string pointed to by MASK in the
    directory whose name is in the string pointed to by DIR are put
    into the tree.  If FLAGS includes _DT_TREE, all subdirectories of
    DIR are also scanned for files and directories matching the
    wildcard.  If _DT_TREE is not included, the subdirectories of the
    directory are not scanned.  If FLAGS includes _DT_NOCPDIR, the `.'
    and `..'  entries are omitted.

    _fnlwr() is used to convert file names to lower case on
    upper-case-only file systems.  _dt_read() properly handles DBCS
    characters.

þreturnvalue

    If successful, _dt_read() returns a pointer to a _dt_tree
    structure.  The þtt{tree} field of that structure is the root of
    the tree.  On error, _dt_read() sets the errno variable and
    returns NULL.

þseealso _dt_free() _dt_sort() _dt_split() _fnlwr() _fnexplode() _nls_init()

þsamplefile /emx/test/dttest.c


þfunction _dt_sort()
þcompat emx
þheaders
#include <sys/dirtree.h>
þendheaders

þparam DT SPEC
þprototype
void _dt_sort (struct _dt_tree *DT, const char *SPEC);
þendprototype

    Sort the directory tree DT according to the string pointed to by
    SPEC.  DT is a directory tree created by _dt_read().  SPEC points
    to a string of characters which is read from left to right.  Each
    character tells _dt_sort() how to compare two tree nodes.  If the
    nodes compare equal, the next character is examined.  This is
    repeated until the two nodes are different according to the
    sorting criterion indicated by a character of the string pointed
    to by SPEC or the end of the SPEC string is reached.  If the end
    of the string pointed to by SPEC is reached, the two nodes are
    considered equal and the two nodes are put in an arbitrary order.
    The following characters are defined in the string pointed to by
    SPEC:

þdescription
þitem e

    File name extensions are compared, ascending ASCII order

þitem E

    File name extensions are compared, descending ASCII order

þitem f

    Directories are placed before files

þitem F

    Files are placed before directories

þitem n

    File names are compared, ascending ASCII order

þitem N

    File names are compared, descending ASCII order

þitem s

    File size is compared, ascending

þitem S

    File size is compared, descending

þitem t

    Time stamps (last modification) are compared, ascending

þitem T

    Time stamps (last modification) are compared, descending

þenddescription

    All other characters are ignored.  _fncmp() is used for comparing
    file names.  If _fncmp() returns 0, strcmp() is used in addition.
    Then, strcmp() can return a non-zero value only if the current
    code page does not match the code page used for creating the
    directory entries.

þseealso _dt_read() _fncmp()


þfunction _dt_split()
þcompat emx
þheaders
#include <sys/dirtree.h>
þendheaders

þparam SRC DIR MASK
þprototype
int _dt_split (const char *SRC, char *DIR, char *MASK);
þendprototype

    Split the path name pointed to by SRC into a directory part and a
    name part for _dt_read().  The directory part is stored to the
    array pointed to by DIR, the name part is stored to the array
    pointed to by MASK.  If the string pointed to by SRC is the name
    of a directory, the array pointed to by MASK is set to þtt{"*.*"}.

    _dt_split() properly handles DBCS characters.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error (errno set)
þenddescription
    
þseealso _dt_read() _nls_init()


þfunction dup() dup2()
þcompat UNIX
þheaders
#include <io.h>
þendheaders

þparam HANDLE HANDLE1 HANDLE2
þprototype
int dup (int HANDLE);
int dup2 (int HANDLE1, int HANDLE2);
þendprototype

    Create a duplicate of the file handle HANDLE or HANDLE1,
    respectively, that is, another handle that refers to the same file
    or device or pipe as the handle given.  Both handles share the
    same file pointer.  dup() chooses the lowest numbered available
    handle.  dup2() uses HANDLE2 for the new file handle.  If HANDLE2
    is open when dup2() is called, it will be closed by dup2() unless
    HANDLE1 is invalid or identical to HANDLE2.

    If HANDLE1 is a valid open file handle and is equal to HANDLE2,
    dup2() returns HANDLE2 without closing it.

þreturnvalue

    dup() and dup2() return the new file handle (which is HANDLE2 if
    dup2() succeeds).  They return -1 on error.

þerrors
þdescription
þitem EBADF
    The HANDLE or HANDLE1 argument is not a valid open file descriptor
    or HANDLE2 is out of range.
þitem EMFILE
    No file descriptor is available.
þenddescription

þrestrictions

    Duplicated file handles should share the file status flags
    O_APPEND and O_NONBLOCK; however, dup() and dup2() just copy the
    file status flags, changing the file status flags after
    duplicating a file handle does not affect the other file handle.

    dup2() currently doesn't work correctly under DOS.

þseealso close() fcntl() open()


þfunction _ea_free()
þcompat emx
þheaders
#include <sys/ea.h>
þendheaders

þparam PTR
þprototype
void _ea_free (struct _ea *PTR);
þendprototype

    Free the memory allocated for the value of an extended attribute
    stored in the structure pointed to by PTR.  If the þtt{value}
    field of the structure is non-þtt{NULL}, free() is called for that
    pointer.  Then, the þtt{value} field is set to NULL.

þseealso _ea_get()


þfunction _ea_get()
þcompat emx
þheaders
#include <sys/ea.h>
þendheaders

þparam DST PATH HANDLE NAME
þprototype
int _ea_get (struct _ea *DST, const char *PATH, int HANDLE,
             const char *NAME);
þendprototype

    Retrieve the extended attribute whose name is in the string
    pointed to by NAME of a file or directory.  If PATH is
    non-þtt{NULL}, an extended attribute of the file or directory
    whose name is in the string pointed to by PATH is retrieved.
    Otherwise, an extended attribute of the file referred to by HANDLE
    is retrieved.  The letter case of NAME is ignored.  The flags, the
    value and the size of the value of the extended attribute is
    copied to the structure pointed to by DST.  If the extended
    attribute does not exist, the þtt{size} member of the structure
    pointed to by DST is set to 0 and the þtt{value} member of the
    structure pointed to by DST is set to NULL.  _ea_get() allocates
    memory for the value of the extended attribute by calling
    malloc().  The structure declaration is:

þexample
struct _ea
{
  int flags;
  int size;
  void *value;
};
þendexample

    The þtt{flags} member contains the flags byte of the extended
    attribute (only bits 0 through 7 of þtt{flags} are used).
    Currently, OS/2 defines only bit 7: it's set for critical EAs.
    þtt{size} is the length of the value in bytes.  The þtt{value}
    member points to the (binary) value of the extended attribute.

    Use _ead_read() to retrieve all the extended attributes of a file
    or directory.

þreturnvalue
þdescription
þitem 0
    success or EA not found
þitem -1
    error
þenddescription

þseealso _ea_free() _ea_put() _ead_read()


þfunction _ea_put()
þcompat emx
þheaders
#include <sys/ea.h>
þendheaders

þparam SRC PATH HANDLE NAME
þprototype
int _ea_put (struct _ea *SRC, const char *PATH, int HANDLE,
             const char *NAME);
þendprototype

    Add an extended attribute to a file or directory.  If PATH is
    non-þtt{NULL}, the extended attribute is added to the file or
    directory whose name is in the string pointed to by PATH.
    Otherwise, the extended attribute is added to the file referred to
    by HANDLE which must be open for writing.  The string pointed to
    by NAME contains the name of the extended attribute.  The letter
    case of the name is ignored.  SRC points to an _ea structure which
    holds the flags, size and value of the extended attribute to be
    added.  If the þtt{size} member is 0, the extended attribute is
    removed.  Bits 0 though 7 of þtt{flags} contain the flags byte for
    the extended attribute.  Currently, OS/2 defines only bit: the
    critical EA bit.  The þtt{flags} member should be zero unless you
    exactly know what you are doing.

    Use _ead_write() to replace or update multiple extended attributes
    at once.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error (errno is set)
þenddescription

þseealso _ea_get() _ea_remove() _ead_write()


þfunction _ea_remove()
þcompat emx
þheaders
#include <sys/ea.h>
þendheaders

þparam PATH HANDLE NAME
þprototype
int _ea_remove (const char *PATH, int HANDLE, const char *NAME);
þendprototype

    Remove the extended attribute whose name is in the string pointed
    to by NAME from a file or directory.  If PATH is non-þtt{NULL},
    the extended attribute is removed from the file or directory whose
    name is in the string pointed to by PATH.  Otherwise, the extended
    attribute is removed from the file referred to by HANDLE.  The
    letter case of the string pointed to by NAME is ignored.  Removing
    a non-existing extended attribute of an existing file or directory
    is not an error.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error (errno is set)
þenddescription

þseealso _ea_put() _ead_write()


þfunction _ead_add()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD NAME FLAGS VALUE SIZE
þprototype
int _ead_add (_ead EAD, const char *NAME, int FLAGS, const void *VALUE,
              int SIZE);
þendprototype

    Add the extended attribute whose name is in the string pointed to
    by NAME to the extended attributes descriptor EAD.  NAME should
    point to a null-terminated string.  The value of the extended
    attribute is set to SIZE bytes of the array pointed to by VALUE.
    The flags byte of the extended attribute is set to FLAGS.  Only
    bits 0 through 7 of FLAGS are used.  Currently, OS/2 defines only
    bit 7 of the flags byte: it's the critical EA bit.  FLAGS should
    be zero unless you exactly know what you are doing.  If an
    extended attribute with the name in the string pointed to by NAME
    already exists in EAD, it is updated with FLAGS, SIZE and the
    array pointed to by VALUE.  The extended attributes on disk are
    not affected.  After calling _ead_add(), the pointers returned by
    previous invocations of _ead_get_fea2list(), _ead_get_name() and
    _ead_get_value() will be invalid.  As _ead_add() does a
    case-sensitive search, you should pass an upper-case names in the
    string pointed to by NAME.  If there are two extended attributes
    in an extended attributes descriptor whose names differ only in
    letter case, only one of both will be written to the disk by
    _ead_write().

þreturnvalue

    _ead_add() returns the index of the new (or updated) extended
    attribute.  On error, _ead_add() sets errno and returns a negative
    value.

þseealso _ead_delete() _ead_replace() _ead_write() _nls_strupr()


þfunction _ead_clear()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD
þprototype
void _ead_clear (_ead EAD);
þendprototype

    Discard the extended attributes of the extended attributes
    descriptor EAD.  After calling _ead_clear(), _ead_count() will
    return 0 for EAD.  The extended attributes on disk are not
    modified.  After calling _ead_clear(), do not use pointers
    returned by _ead_get_name(), _ead_get_value() and
    _ead_get_fea2list() for that descriptor.


þseealso _ead_create() _ead_destroy() _ead_read()


þfunction _ead_copy()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam DST_EAD SRC_EAD SRC_INDEX
þprototype
int _ead_copy (_ead DST_EAD, _ead SRC_EAD, int SRC_INDEX);
þendprototype

    Copy the extended attribute SRC_INDEX from the extended attributes
    descriptor SRC_EAD to the extended attributes descriptor DST_EAD.
    If SRC_INDEX is 0, all extended attributes of SRC_EAD are copied
    to DST_EAD.  Otherwise, SRC_INDEX must be a number between 1 and
    the number of extended attributes of SRC_EAD.  _ead_copy() uses
    _ead_add() to copy the extended attributes.  The extended
    attributes on disk are not affected.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error (errno is set)
þenddescription

þseealso _ead_add()


þfunction _ead_count()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD
þprototype
int _ead_count (_ead EAD);
þendprototype

    Get the number of extended attributes available from the
    extended attributes descriptor EAD.

þreturnvalue

    _ead_count() returns the number of extended attributes available
    from the extended attributes descriptor EAD.

þseealso _ead_create() _ead_get_name() _ead_get_value()


þfunction _ead_create()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þprototype
_ead _ead_create (void)
þendprototype

    Create an extended attributes descriptor.  Such a descriptor is
    used for handling the extended attributes of files and
    directories.  Use _ead_destroy() if you no longer need the
    descriptor.  To copy all the extended attributes of a file or a
    directory to an extended attributes descriptor, use _ead_read().
    Initially, no extended attributes are held by an extended
    attributes descriptor.

þreturnvalue

    _ead_create() returns a descriptor which can be used by the other
    functions for handling extended attributes.  On error,
    _ead_create() sets errno and returns NULL.

þseealso _ead_destroy() _ead_get_name() _ead_get_value() _ead_read()

þsamplefile /emx/samples/eatool.c


þfunction _ead_delete()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD INDEX
þprototype
int _ead_delete (_ead EAD, int INDEX);
þendprototype

    Delete the extended attribute INDEX from the extended attributes
    descriptor EAD.  INDEX must be a number between 1 and the number
    of extended attributes of EAD.  After calling _ead_delete(), the
    pointers returned by previous invocations of _ead_get_fea2list(),
    _ead_get_name() and _ead_get_value() will be invalid.  Moreover,
    _ead_delete() invalidates index numbers.

þreturnvalue

    _ead_delete() returns 0 if successful.  On error, _ead_delete()
    sets errno and returns a negative number.

þseealso _ead_add() _ead_find()


þfunction _ead_destroy()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD
þprototype
void _ead_destroy (_ead EAD);
þendprototype

    Invalidate the extended attributes descriptor EAD which has been
    created by _ead_create().  All memory associated with EAD is
    released.  EAD must not be NULL.  After calling _ead_destroy(),
    EAD is invalid and can no longer be used.  After calling
    _ead_destroy(), do not use pointers returned by _ead_get_name(),
    _ead_get_value() and _ead_get_fea2list() for that descriptor.

þseealso _ead_clear() _ead_create()


þfunction _ead_fea2list_size()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD
þprototype
int _ead_fea2list_size (_ead EAD);
þendprototype

    Get the size of the FEA2LIST of the extended attributes
    descriptor EAD.  If EAD doesn't hold any extended attributes, the
    size is 0.

þreturnvalue

    _ead_fea2list_size() returns the size of the FEA2LIST of the
    extended attributes descriptor EAD.  _ead_fea2list_size() returns
    0 if EAD doesn't hold any extended attributes.

þseealso _ead_get_fea2list()


þfunction _ead_fea2list_to_fealist()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam SRC
þprototype
void *_ead_fea2list_to_fealist (const void *SRC);
þendprototype

    Convert the FEA2LIST SRC (OS/2 2.x format) to a FEALIST (OS/2 1.2
    format).  SRC must not be NULL.  This function allocates memory
    with malloc() to hold the converted list.  A pointer to the
    converted list is returned.  If you no longer need the buffer
    allocated by this function, you should deallocate it with free().
    SRC is of type PFEA2LIST, the return value is of type PFEALIST.
    To avoid having to include <os2.h> when including <sys/ead.h>, void
    pointers are used instead.

þreturnvalue

    _ead_fea2list_to_fealist() returns a pointer to a FEALIST,
    allocated with malloc().  On error, _ead_fea2list_to_fealist()
    sets errno and returns NULL.

þseealso _ead_fealist_to_fea2list() _ead_get_fea2list()


þfunction _ead_fealist_to_fea2list()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam SRC
þprototype
void *_ead_fealist_to_fea2list (const void *SRC);
þendprototype

    Convert the FEALIST SRC (OS/2 1.2 format) to a FEA2LIST (OS/2 2.x
    format).  SRC must not be NULL.  This function allocates memory
    with malloc() to hold the converted list.  A pointer to the
    converted list is returned.  If you no longer need the buffer
    allocated by this function, you should deallocate it with free().
    SRC is of type PFEALIST, the return value is of type PFEA2LIST.
    To avoid having to include <os2.h> when including <sys/ead.h>, void
    pointers are used instead.

þreturnvalue

    _ead_fealist_to_fea2list() returns a pointer to a FEA2LIST,
    allocated with malloc().  On error, _ead_fealist_to_fea2list()
    sets errno and returns NULL.

þseealso _ead_fea2list_to_fealist()


þfunction _ead_find()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD NAME
þprototype
int _ead_find (_ead EAD, const char *NAME);
þendprototype

    Retrieve the index of the extended attribute whose name is in the
    string pointed to by NAME of the extended attributes descriptor
    EAD.  NAME should point to a null-terminated string.  If there is
    no such extended attribute, errno is set to ENOENT and -1 is
    returned.  Otherwise, a number between 1 and the number of
    extended attributes of EAD is returned.  Note that OS/2 converts
    names of extended attributes to upper case when writing them to
    the disk.  As _ead_find() does a case-sensitive compare,
    lower-case names are not found.

þreturnvalue

    _ead_find() returns the index of the extended attribute.  If the
    extended attribute is not found, _ead_find() returns -1.

þseealso _ead_count() _ead_get_name() _ead_get_value() _nls_strupr()


þfunction _ead_get_fea2list()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD
þprototype
const void *_ead_get_fea2list (_ead EAD);
þendprototype

    Retrieve a pointer to the FEA2LIST of the extended attributes
    descriptor EAD.  You should cast the return value to PFEA2LIST.
    The return type of _ead_get_fea2list() is not PFEA2LIST to be able
    to include <sys/ead.h> without having to include <os2.h>.  The pointer
    points to memory allocated by the extended attributes functions --
    do not use the pointer after calling _ead_add(), _ead_clear(),
    _ead_copy(), _ead_delete(), _ead_destroy() or _ead_replace() and
    do not write to the buffer.

þreturnvalue

    _ead_get_fea2list() returns a pointer to the FEA2LIST of the
    extended attributes descriptor EAD.

þseealso _ead_fea2list_size() _ead_fea2list_to_fealist()


þfunction _ead_get_flags()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD INDEX
þprototype
int _ead_get_flags (_ead EAD, int INDEX);
þendprototype

    Get the þtt{flags} byte of the extended attribute INDEX of the
    extended attributes descriptor EAD.  INDEX must be a number
    between 1 and the number of extended attributes of EAD.  On error,
    errno is set and -1 is returned.

þreturnvalue

    _ead_get_flags() returns the þtt{flags} by of an extended
    attribute.  On error, _ead_get_flags() returns -1.

þseealso _ead_count() _ead_get_value()


þfunction _ead_get_name()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD INDEX
þprototype
const char *_ead_get_name (_ead EAD, int INDEX);
þendprototype

    Return a pointer to the name of the extended attribute INDEX of
    the extended attributes descriptor EAD.  INDEX must be a number
    between 1 and the number of extended attributes of EAD.  The
    pointer points to memory allocated by the extended attributes
    functions -- do not use the pointer after calling _ead_add(),
    _ead_clear(), _ead_copy(), _ead_delete(), _ead_destroy() or
    _ead_replace() and do not write to the buffer.  On error, errno is
    set and NULL is returned.

þreturnvalue

    _ead_get_name() returns a pointer to the name of an extended
    attribute.  On error, _ead_get_name() returns NULL.

þseealso _ead_count() _ead_name_len()


þfunction _ead_get_value()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD INDEX
þprototype
const void *_ead_get_value (_ead EAD, int INDEX);
þendprototype

    Return a pointer to the value of the extended attribute INDEX of
    the extended attributes descriptor EAD.  INDEX must be a number
    between 1 and the number of extended attributes of EAD.  The
    pointer points to memory allocated by the extended attributes
    functions -- do not use the pointer after calling _ead_add(),
    _ead_clear(), _ead_copy(), _ead_delete(), _ead_destroy() or
    _ead_replace() and do not write to the buffer.  On error, errno is
    set and NULL is returned.

þreturnvalue

    _ead_get_value() returns a pointer to the value of an extended
    attribute.  On error, _ead_get_value() returns NULL.

þseealso _ead_count() _ead_find() _ead_get_flags() _ead_value_size()


þfunction _ead_name_len()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD INDEX
þprototype
int _ead_name_len (_ead EAD, int INDEX);
þendprototype

    Get the length of the name of the extended attribute INDEX of the
    extended attributes descriptor EAD.  If INDEX is 0, the total
    length of all the names is returned, not including the terminating
    null characters.  Otherwise, INDEX must be a number between 1 and
    the number of extended attributes of EAD; the length of the name
    of the þpa{INDEX}th extended attribute is returned.  The
    terminating null character is not included in the length.  On
    error, errno is set and -1 is returned.

þreturnvalue

    _ead_name_len() returns the length of the name of an extended
    attribute.  On error, _ead_name_len() returns -1.

þseealso _ead_count() _ead_get_name()


þfunction _ead_read()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD PATH HANDLE FLAGS
þprototype
int _ead_read (_ead EAD, const char *PATH, int HANDLE, int FLAGS);
þendprototype

    Copy the extended attributes of a file or directory to the
    extended attributes descriptor EAD.  The extended attributes held
    previously by EAD are discarded.  If PATH is not NULL, the
    extended attributes of file or directory whose name is in the
    string pointed to by PATH are copied to EAD.  If PATH is NULL, the
    extended attributes of the file referred to by the file handle
    HANDLE are copied to EAD.  FLAGS is not yet used and must be 0.
    _ead_read() calls _ead_clear(), reads all the extended attributes
    and stores them in memory.  Use _ead_destroy() to deallocate that
    memory and invalidate EAD.  When using a non-þtt{NULL} PATH,
    _ead_read() does not lock the file while while reading the
    extended attributes.  You might want to open a handle in
    deny-write mode and pass it in HANDLE to avoid problems due to
    other threads or processes modifying the extended attributes while
    _ead_read() is reading.  This doesn't work with and isn't required
    for directories.  _ead_read() can also be used under DOS though no
    extended attributes will be copied.  Therefore, your program
    doesn't have to decide whether to use these functions or not.

    Use _ea_get() to retrieve extended attributes one by one.

þreturnvalue

  If successful, _ead_read() returns 0.  On error, _ead_read() sets
  errno and returns a negative number.

þseealso _ea_get() _ead_create() _ead_destroy() _ead_get_name() _ead_get_value() _ead_write()

þfunction _ead_replace()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD INDEX FLAGS VALUE SIZE
þprototype
int _ead_replace (_ead EAD, int INDEX, int FLAGS, const void *VALUE,
                  int SIZE);
þendprototype

    Update the extended attribute INDEX of the extended attributes
    descriptor EAD with FLAGS and SIZE bytes of VALUE.  INDEX must be
    a number between 1 and the number of extended attributes of EAD.
    The extended attributes on disk are not affected.  After calling
    _ead_replace(), the pointers returned by previous invocations of
    _ead_get_fea2list(), _ead_get_name() and _ead_get_value() will be
    invalid.

þreturnvalue

    On success, _ead_replace() returns 0.  On error, _ead_replace()
    sets errno and returns a negative value.

þseealso _ead_add() _ead_write()


þfunction _ead_sort()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD
þprototype
void _ead_sort (_ead EAD);
þendprototype

    Sort by name the extended attributes of the extended attributes
    descriptor EAD.  Sorting is done in memory -- the extended
    attributes on disk are not affected.  After calling _ead_sort(),
    index 1 refers to the extended attribute with the lexically
    smallest name.  strcmp() is used for comparing names.  _ead_sort()
    sorts the index, not the extended attributes proper.  Therefore,
    all functions that modify the extended attributes of EAD undo the
    effect of _ead_sort().

þseealso _ead_create() _ead_get_name() _ead_read()


þfunction _ead_use_fea2list()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD SRC
þprototype
int _ead_use_fea2list (_ead EAD, const void *SRC);
þendprototype

    Copy all the extended attributes from the FEA2LIST SRC (OS/2 2.x
    format) to the extended attributes descriptor EAD.  All extended
    attributes previously held by EAD are discarded.  The extended
    attributes on the disk are not affected.

þreturnvalue

    If successful, _ead_use_fea2list() returns 0.  Otherwise,
    _ead_use_fea2list() sets errno and returns a negative value.

þseealso _ead_write()


þfunction _ead_value_size()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD INDEX
þprototype
int _ead_value_size (_ead EAD, int INDEX);
þendprototype

    Get the size of the extended attribute INDEX of the extended
    attributes descriptor EAD.  If INDEX is 0, the total size of all
    the values of EAD is returned.  Otherwise, INDEX must be a number
    between 1 and the number of extended attributes of EAD; the size
    of the þtt{INDEX}th extended attribute is returned.  On error,
    errno is set and -1 is returned.

þreturnvalue

    _ead_value_size() returns the length of the value of an extended
    attribute.  On error, _ead_value_size() returns -1.

þseealso _ead_count() _ead_get_value()


þfunction _ead_write()
þcompat emx
þheaders
#include <sys/ead.h>
þendheaders

þparam EAD PATH HANDLE FLAGS
þprototype
int _ead_write (_ead EAD, const char *PATH, int HANDLE, int FLAGS);
þendprototype

    Write all the extended attributes of the extended attributes
    descriptor EAD to the file or directory whose name is in the
    string pointed to by PATH or to the file associated with HANDLE.
    The extended attributes previously attached to that file or
    directory are discarded and replaced by the extended attributes of
    EAD if FLAGS is 0.  This is done by deleting the extended
    attributes of the file or directory which are not in EAD.  If
    FLAGS is _EAD_MERGE, the extended attributes of the file or
    directory which are also present in EAD are replaced by those of
    EAD.  Extended attributes of EAD which are not attached to the
    file or directory are added to the extended attributes of the file
    or directory.  If PATH is non-þtt{NULL}, the extended attributes
    are written to the file or directory whose name is in the string
    pointed to by PATH.  If PATH is NULL, the extended attributes are
    written to the file referred to by the file handle HANDLE.  The
    extended attributes of EAD are not modified.

    Use _ea_put() to add or update extended attributes one by one.

þreturnvalue

  _ead_write() returns 0 if successful.  On error, _ead_write() sets
  errno and returns a negative value.  Under DOS, _ead_write() does
  nothing and always returns 0.

þseealso _ea_put() _ead_clear() _ead_read() _ead_use_fea2list()


þfunction _emx_16to32() _emx_32to16()
þcompat emx
þheaders
#include <os2.h>
þendheaders

þparam PTR
þprototype
void *_emx_16to32 (_far16ptr PTR);
_far16ptr _emx_32to16 (void *PTR);
þendprototype

    _emx_16to32() converts a 16-bit far pointer (16:16 format) to a
    32-bit flat pointer.

    _emx_32to16() converts a 32-bit flat pointer to a 16-bit far
    pointer (16:16 format).

    The type _far16ptr is used for 16-bit far pointers.

þreturnvalue

    _emx_16to32() returns a 32-bit flat pointer.
    _emx_32to16() returns a 16-bit far pointer.

    
þfunction _emxload_connect() _emxload_disconnect()
þcompat emx
þheaders
#include <sys/emxload.h>
þendheaders

þprototype
int _emxload_connect (void)
int _emxload_disconnect (void)
þendprototype

    Call _emxload_connect() to explicitly connect to the emxload
    server process.  The connection will be kept open until
    _emxload_disconnect() or _emxload_stop() is called to terminate
    the connection.  A counter is maintained which is incremented for
    each successful call to _emxload_connect() and decremented by each
    successful call to _emxload_disconnect().  The connection is
    closed when the counter reaches zero.

    If _emxload_connect() has not been called, _emxload_env(),
    _emxload_prog(), _emxload_this(), _emxload_stop() and
    _emxload_unload() open and close a temporary connection to the
    emxload server process.

    The emxload server process is started by _emxload_connect() if the
    emxload server process is not already running.

þreturnvalue
þdescription
þitem 0
    connection sucessfully established or closed
þitem -1
    the emxload server process could not be started
þenddescription

þrestrictions

    Under DOS, _emxload_connect() and _emxload_disconnect() do nothing
    and return -1.

þseealso _emxload_disconnect() _emxload_prog() _emxload_stop()


þfunction _emxload_env()
þcompat emx
þheaders
#include <sys/emxload.h>
þendheaders

þparam NAME
þprototype
int _emxload_env (const char *NAME)
þendprototype

    Keep (another copy of) the current program in memory if the
    environment variable whose name is in the string pointed to by
    NAME is set and contains a number.  That number specifies the
    number of minutes the process should be kept in memory.

    The emxload server process is started by _emxload_env() if the
    environment variable is valid and the emxload server process is
    not already running.

þreturnvalue
þdescription
þitem 0
    request successfully sent to the emxload server process
þitem -1
    error: the environment variable is not set, or does not contain a
    valid number or the emxload server process could not be started
þenddescription

þrestrictions

    Under DOS, _emxload_env() does nothing and returns -1.

þseealso _emxload_prog() _emxload_this() _emxload_unload()


þfunction _emxload_list_start() _emxload_list_get()
þcompat emx
þheaders
#include <sys/emxload.h>
þendheaders

þparam BUF BUF_SIZE PSECONDS
þprototype
int _emxload_list_start (void);
int _emxload_list_get (char *BUF, size_t BUF_SIZE, int *PSECONDS);
þendprototype

    Get a list of all preloaded programs.  To start the list, call
    _emxload_list_start().  If _emxload_list_start() returns 0, call
    _emxload_list_get() to receive the names and timeouts of the
    preloaded programs until _emxload_list_get() returns a non-zero value.

    _emxload_list_get() stores the complete path name of the program
    to the array pointed to by BUF.  BUF_SIZE is the size of the
    array, including the trailing null character.  The number of
    seconds remaining until automatic unloading is stored to the
    integer pointed to by PSECONDS.  If automatic unloading is
    disabled for that program, _EMXLOAD_INDEFINITE is stored.

    If you stop calling _emxload_list_get() before information about
    all the programs has been transferred, you should call
    _emxload_disconnect() to close the connection.  Calling
    _emxload_disconnect() is not required if _emxload_list_start()
    returns a non-zero value or after _emxload_list_get() returns a
    non-zero value.

    Do not call _emxload_list_get() without prior calling
    _emxload_list_start().  Do not call _emxload_list_get() if the
    previous call to _emxload_list_start() or _emxload_list_get()
    returned a non-zero value.

þreturnvalue
þdescription
þitem 0
    request processed successfully
þitem -1
    an error occured
þitem 1
    end of the list of programs (_emxload_list_get() only)
þenddescription

þrestrictions

    Under DOS, _emxload_list_start() and _emxload_list_get() do
    nothing and return -1.

þseealso _emxload_prog() _emxload_disconnect()


þfunction _emxload_prog()
þcompat emx
þheaders
#include <sys/emxload.h>
þendheaders

þparam NAME SECONDS
þprototype
int _emxload_prog (const char *NAME, int SECONDS)
þendprototype

    Keep a program in memory for SECONDS seconds.  NAME points to a
    string containing the file name of the program.  If SECONDS is
    _EMXLOAD_INDEFINITE, the program will not be unloaded
    automatically.  The default extension of the name is .exe, the
    PATH environment variable is used for finding the executable file.

    The emxload server process is started by _emxload_prog() if
    SECONDS and the string pointed to by NAME are valid and the
    emxload server process is not already running.

þreturnvalue
þdescription
þitem 0
    request successfully sent to the emxload server process
þitem -1
    error: the program has not been found or the emxload server process
    could not be started
þenddescription

þrestrictions

    Under DOS, _emxload_prog() does nothing and returns -1.

þseealso _emxload_connect() _emxload_env() _emxload_list_start() _emxload_this() _emxload_unload()


þfunction _emxload_stop()
þcompat emx
þheaders
#include <sys/emxload.h>
þendheaders

þparam WAIT_FLAG
þprototype
int _emxload_stop (int WAIT_FLAG)
þendprototype

    Stop the emxload server process.  All preloaded programs will be
    unloaded.  If WAIT_FLAG is zero, _emxload_stop() returns
    immediately after sending the request to the server.  If WAIT_FLAG
    is non-zero, _emxload_stop() waits until the server process no
    longer exists.

þreturnvalue
þdescription
þitem 0
    emxload server process stopped
þitem -1
    the emxload server process was not running or could not be stopped
þenddescription

þrestrictions

    Under DOS, _emxload_stop() does nothing and returns -1.

þseealso _emxload_connect()


þfunction _emxload_this()
þcompat emx
þheaders
#include <sys/emxload.h>
þendheaders

þparam SECONDS
þprototype
int _emxload_this (int SECONDS)
þendprototype

    Keep (another copy of) the current program in memory for SECONDS
    seconds.  If SECONDS is _EMXLOAD_INDEFINITE, the program will not
    be unloaded automatically.

    The emxload server process is started by _emxload_this() if
    SECONDS is valid and the emxload server process is not already
    running.

þreturnvalue
þdescription
þitem 0
    request successfully sent to the emxload server process
þitem -1
    error: SECONDS is invalid or the emxload server process could
    not be started
þenddescription

þrestrictions

    Under DOS, _emxload_this() does nothing and returns -1.

þseealso _emxload_env() _emxload_prog() _emxload_unload()


þfunction _emxload_unload()
þcompat emx
þheaders
#include <sys/emxload.h>
þendheaders

þparam NAME WAIT_FLAG
þprototype
int _emxload_unload (const char *NAME, int WAIT_FLAG)
þendprototype

    Unload a preloaded program.  NAME points to a string containing
    the file name of the program.  The default extension for the file
    name is .exe, the PATH environment variable is used for finding
    the executable file.  If WAIT_FLAG is zero, _emxload_unload()
    returns immediately after sending the request to the server.  If
    WAIT_FLAG is non-zero, _emxload_unload() waits until the server
    process has unloaded the program.

þreturnvalue
þdescription
þitem 0
    request successfully sent to the emxload server process
þitem -1
    error: the program has not been found
þenddescription

þrestrictions

    Under DOS, _emxload_unload() does nothing and returns -1.

þseealso _emxload_prog() _emxload_stop()


þfunction _endthread()
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þprototype
void _endthread (void);
þendprototype

    A thread that has been created by _beginthread() can call
    _endthread() to end its execution.  A thread also ends when the
    function started with _beginthread() returns.  In that case,
    _endthread() will be called automatically.  Terminating the main
    thread (thread 1) of a process terminates the process (return
    value will be 0).  Do not use DosExit to end a thread started by
    _beginthread().

    _endthread() is available only in the multithread libraries (-Zmt,
    -Zmts, or -Zmtd).

þseealso _beginthread()


þfunction _envargs()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam ARGCP ARGVP NAME
þprototype
void _envargs (int *ARGCP, char ***ARGVP, const char *NAME);
þendprototype

    Take arguments from the environment variable whose name is in the
    string pointed to by NAME and insert them before the arguments
    given on the command line.  If you want to get arguments from the
    environment variable MYPROGOPT, insert

þexample
_envargs (&argc, &argv, "MYPROGOPT");
þendexample

    at the beginning of main().  The contents of the environment
    variable is parsed the same way as the command line, including
    quoting.  If you call _response() or _wildcard() after _envargs(),
    the arguments taken from the environment variable are treated like
    command line arguments, that is, _wildcard() will expand wildcards
    in the value of the environment variable unless they are quoted.

    If the environment variable is not defined or if there is not
    enough memory, _envargs() does not modify *ARGCP and *ARGVP.

þseealso getenv() main() _response() _wildcard()


þfunction eof()
þcompat PC
þheaders
#include <io.h>
þendheaders

þparam HANDLE
þprototype
int eof (int HANDLE);
þendprototype

    Check whether the current position of HANDLE is at the end of the
    file or not.

þreturnvalue
þdescription
þitem 1
    at end of file
þitem 0
    not at end of file
þitem -1
    error
þenddescription


þfunction _errno()
þcompat emx
þheaders
#include <errno.h>
þendheaders

þprototype
int *_errno (void);
þendprototype

    Return the address of the errno value.  In single-thread
    programs, errno is a variable, in multithread programs, errno
    is an lvalue that depends on the thread number.  In consequence,
    you cannot create a library that uses errno and can be used for
    both single-thread and multithread programs.  To solve this
    problem, the _errno() function has been provided: it returns a
    pointer to the errno value in both single-thread and
    multithread programs.  Use the option

þexample
-D__ST_MT_ERRNO__
þendexample

    on the GCC command line to define errno to call _errno().
    However, using _errno() doesn't remove any other reasons why your
    library might not be thread-safe.

þseealso errno


þfunction exec*() execl() execle() execlp() execlpe() execv() execve() execvp() execvpe()
þcompat UNIX
þheaders
#include <process.h>
þendheaders

þparam NAME ARG0 ARGV ENVP
þprototype
int execl (const char *NAME, const char *ARG0, ...);
int execle (const char *NAME, const char *ARG0, ...);
int execlp (const char *NAME, const char *ARG0, ...);
int execlpe (const char *NAME, const char *ARG0, ...);
int execv (const char *NAME, char * const ARGV[]);
int execve (const char *NAME, char * const ARGV[], char * const ENVP[]);
int execvp (const char *NAME, char * const ARGV[]);
int execvpe(const char *NAME, char * const ARGV[], char * const ENVP[]);
þendprototype

    Replace calling process with a new process.  The calling process
    terminates after starting the new process.  NAME points to a
    string containing the name of the executable file to run.

    Use execl(), execle(), execlp() or execlpe() for passing a fixed
    number of arguments.  ARG0 points to a string containing the 0th
    argument which is the program name, by convention.  Following
    ARG0, pointers to the argument strings are passed.  After the last
    argument pointer, a null pointer cast to `þtt{char *}' must be
    following.  At least ARG0 must be specified.

    Use execv(), execve(), execvp() or execvpe() for passing a
    variable number of arguments.  ARGV points to an array of pointers
    to strings.  The first entry is the program name, by convention.
    The last argument must be followed by a null pointer.

    execl(), execlp(), execv() and execvp() pass the environment of
    the current process to the new process.  To pass a different
    environment to the new process, pass a pointer to an array of
    pointers to strings after the null argument pointer of execle()
    and execlpe() or pass the pointer in the ENVP argument of execve()
    and execvpe().  The last pointer to an environment string in the
    array must be followed by a null pointer.

    If both the old process and the new process use emx.exe or
    emx.dll, the new process will inherit the signal actions of the
    old process: Signals set to SIG_IGN in the old process will be set
    to SIG_IGN in the new process, signals set to SIG_DFL in the old
    process will be set to SIG_DFL in the new process, signals caught
    in the old process will be set to SIG_DFL in the new process.

    When the new process ends, the parent process will be notified by
    SIGCHLD and wait() will return the original process ID.

þreturnvalue

    These functions return -1 if an error occurs.  On success, they do
    not return.

þrestrictions

    Native DOS programs cannot be run.  The new process gets a new
    process ID.  Unless the new process is an emx program (using
    emx.dll or emx.exe), the actions for all signals are reset to
    SIG_DFL in the new process

þseealso fork() sigaction() signal() spawn*() wait() waitpid()


þfunction _execname()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam BUF BUFSIZE
þprototype
int _execname (char *BUF, size_t BUFSIZE);
þendprototype

    Copy the full path name of the executable file for the current
    process to the array pointed to by BUF.  It is assumed that there
    are BUFSIZE bytes available at BUF, including the terminating null
    character.

þreturnvalue

    _execname() returns 0 on success, -1 on error (buffer too small,
    for instance).

þrestrictions

    _execname() is not yet implemented under DOS.

þseealso main()


þfunction exit()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam RET
þprototype
void exit (int RET);
þendprototype

    Flush streams, remove temporary files, call functions set by
    atexit() and terminate the current process.  The return code RET
    is passed to the parent process.  If RET is negative or greater
    than 255, 255 will be used instead to avoid returning 0 (success)
    for non-zero RET due to truncation to 8 bits.

þseealso abort() atexit() _exit()


þfunction _exit()
þcompat UNIX
þheaders
#include <stdlib.h>
þendheaders

þparam RET
þprototype
void _exit (int RET);
þendprototype

    Terminate the process without flushing streams, removing temporary
    files or calling functions set by atexit().  The return code RET
    is passed to the parent process.  If RET is negative or greater
    than 255, 255 will be used instead to avoid returning 0 (success)
    for non-zero RET due to truncation to 8 bits.

þseealso abort() atexit() exit()


þfunction exp() expl()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
double exp (double X);
long double expl (long double X);
þendprototype

    exp() computes the exponential function of X.  On overflow, +INF
    is returned and errno set to ERANGE.

    expl() uses the þtt{long double} format.

þreturnvalue

    exp() returns e^þpa{X}.  On overflow, exp() returns +INF.


þseealso log() pow()


þfunction _expand()
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þparam MEM NEW_SIZE
þprototype
void *_expand (void *MEM, size_t NEW_SIZE);
þendprototype

    Try to expand the memory block pointed to by MEM to the new size
    NEW_SIZE.  If the block cannot be expanded, NULL is returned.
    Otherwise, MEM is returned.  Please do not use this function --
    use realloc() instead.

þreturnvalue

    _expand() returns MEM if the block could be resized.  Otherwise,
    _expand() returns NULL.

þseealso realloc()


þfunction fabs() fabsl()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
double fabs (double X);
long double fabsl (long double X);
þendprototype

    Return the absolute value of X: If X is negative, -þpa{X} is returned.
    Otherwise, X is returned.

    fabsl() uses the þtt{long double} format.

þreturnvalue

    fabs() returns the absolute value of its argument.

þseealso abs() labs()


þfunction _fassign()
þcompat emx
þheaders
#include <stdio.h>
þendheaders

þparam TARGET SOURCE
þprototype
FILE *_fassign (FILE *TARGET, FILE *SOURCE);
þendprototype

    Replace the stream pointed to by TARGET with the stream pointed to
    by SOURCE.  After a successful call of _fassign(), the stream
    pointed to by SOURCE is no longer available and the stream pointed
    to by TARGET is associated with the file with which the stream
    pointed to by SOURCE was associated.  _fassign() closes the file
    previously associated with the stream pointed to by TARGET.

    If TARGET and SOURCE are equal and both point to a stream,
    _fassign() does nothing.

þreturnvalue

    _fsasign() returns TARGET if successful.  _fassign() returns NULL
    on error.

þseealso freopen() _mfopen() v_fopen() wm_fopen()

þsamplecode
#include <stdio.h>
#include <sys/winmgr.h>

wm_handle wh_stderr;

void init (void)
{
  FILE *f;

  /*...*/
  f = wm_fopen (wh_stderr);
  _fassign (stderr, f);
}
þendsamplecode


þfunction fclose()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
int fclose (FILE *STREAM);
þendprototype

    Flush and close the stream STREAM.  STREAM must be open prior to
    calling fclose().  If the stream buffer was automatically
    allocated, it will be deallocated.  If the stream was created with
    tmpfile(), the temporary file will be deleted.

þreturnvalue
þdescription
þitem 0
  success
þitem EOF
  error
þenddescription

þseealso fcloseall() fflush() fopen() tmpfile()


þfunction fcloseall()
þcompat PC
þheaders
#include <stdio.h>
þendheaders

þprototype
int fcloseall (void);
þendprototype

    Close all open streams.

þreturnvalue

    fcloseall() returns the number of streams closed.  On error,
    fcloseall() returns EOF.

þseealso fclose() flushall() fopen()


þfunction fcntl()
þcompat BSD *
þheaders
#include <fcntl.h>
þendheaders

þparam HANDLE REQUEST ARG
þprototype
int fcntl (int HANDLE, int REQUEST);
int fcntl (int HANDLE, int REQUEST, int ARG);
þendprototype

    File control.  The following REQUEST codes are implemented
    (partially):

þdescription
þitem F_DUPFD

    Create a duplicate of the file handle HANDLE, that is, another
    handle that refers to the same file or device or pipe as HANDLE.
    Both handles share the same file pointer.  The lowest numbered
    available file handle greater than or equal to ARG will be used
    and returned.

þitem F_GETFL

    Return the file flags of the file associated with HANDLE.
    Currently, only two file flags are supported by fcntl(): O_APPEND
    and O_NONBLOCK (alias O_NDELAY).

þitem F_SETFL

    Set the file flags of the file associated with HANDLE.  Currently,
    only two file flags are supported by fcntl(): O_APPEND and
    O_NONBLOCK (alias O_NDELAY).  O_NONBLOCK has an effect only if
    HANDLE is 0 and HANDLE refers to the keyboard and the IDEFAULT and
    ICANON bits are not set.  O_NONBLOCK also works for pipes created
    by emx programs, for named pipes, and for sockets.  See
    `þhpt{General terminal interface}' and þhpt{read()}.

þitem F_GETFD

    Return file descriptor flags.  If the return value includes
    FD_CLOEXEC (close-on-exec flag), HANDLE will not be inherited by
    child processes created with þhpt{exec*()} and þhpt{spawn*()}.

þitem F_SETFD

    Set file-descriptor flags.  If the flags include FD_CLOEXEC,
    (close-on-exec flag), HANDLE will not be inherited by child
    processes created with þhpt{exec*()} and þhpt{spawn*()}.

þenddescription

þreturnvalue

    On error, fcntl() sets errno and returns -1.  Otherwise, fcntl()
    returns 0 unless a different return value is defined above.

þerrors
þdescription
þitem EBADF
    The HANDLE argument is not a valid open file descriptor.
þitem EINVAL
    REQUEST is invalid.

    REQUEST is F_DUPFD and ARG is out of range.

    REQUEST is F_SETFL and ARG is not a combination of supported
    flags.

þitem EMFILE
    REQUEST is F_DUPFD and no file descriptor greater than or equal to
    ARG is available.
þenddescription

þrestrictions

    O_NONBLOCK is not supported by the system call library sys.lib
    (þhpt{-Zsys}).

    Duplicated file handles should share the file status flags
    O_APPEND and O_NONBLOCK; however, F_DUPFD, dup(), and dup2() just
    copy the file status flags, changing the file status flags after
    duplicating a file handle does not affect the other file handle.

    F_GETFL should return the access mode but doesn't.

    Under DOS, FD_CLOEXEC is currently ignored for child processes
    which are DOS programs (vs. emx programs).

þseealso dup() ioctl() open() read()


þfunction fdopen()
þcompat UNIX
þheaders
#include <stdio.h>
þendheaders

þparam HANDLE MODE
þprototype
FILE *fdopen (int HANDLE, const char *MODE);
þendprototype

    Create a stream for the file handle HANDLE.  The flags in the mode
    string pointed to by MODE should match the mode used for opening
    the file handle HANDLE.  If þtt{b} or þtt{t} is used in the mode
    string, the handle will be changed using setmode() to O_BINARY or
    O_TEXT mode, respectively.  If neither þtt{b} nor þtt{t} is used,
    the translation mode is not changed.  You should not rely on this
    behavior: always specify the desired translation mode.

þreturnvalue

    fdopen() returns a new stream.  On error, fdopen() returns NULL.

þseealso fopen() open()


þfunction ferror() feof()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
int ferror (FILE *STREAM);
int feof (FILE *STREAM);
þendprototype

    ferror() checks STREAM for an error condition.  feof() checks
    STREAM for an end-of-file condition.

þreturnvalue

    ferror() returns a non-zero value if the error indicator of STREAM
    is set.  Otherwise, ferror() returns zero.  feof() returns a
    non-zero value if the end-of-file indicator of STREAM is set.
    Otherwise, feof() returns zero.

þhints

    The end-of-file indicator is not set if the file position
    indicator reaches the end of the file; rather, it is set when
    attempting to read past end-of-file.

þseealso clearerr() fgetc() rewind()


þfunction fflush()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
int fflush (FILE *STREAM);
þendprototype

    If STREAM is an output stream or an update stream in write mode,
    write unwritten data of STREAM's buffer to its file.  If STREAM is
    NULL, fflush() is applied to all open output streams and update
    streams in write mode.

    If STREAM is an update stream in write mode, the next operation on
    STREAM may be input or output.

þreturnvalue

    fflush() returns EOF if a write error occurs, otherwise zero.

þimplementation

    If STREAM is an input stream, fflush() discards the buffer
    contents and undoes any effects of ungetc().  If the stream is
    connected to a disk file, the buffer will be refilled (no data
    lost) on the next input operation.  If the stream is connected to
    a character device, a pipe, or a socket, the buffer contents will
    be lost.  (Note that this does not clear the type-ahead buffer of
    the keyboard device!  Only the data which has been read into the
    buffer will be discarded.)

þhints

    Use fflush() for switching an update stream from write mode to
    read mode: output may not be directly followed by input --
    fflush(), fseek(), fsetpos(), or rewind() must be called between
    output and input.

    Use fflush() to force output (for instance, a prompt) of a
    buffered stream to a device: you should do
þexample
fflush (stdout);
þendexample
    before getting input from stdin, in case stdout is connected to a
    pipe (a stream connected to a pipe is buffered by default).

þseealso fclose() fopen() fseek() ungetc()


þfunction ffs()
þcompat BSD
þheaders
#include <strings.h>
þendheaders

þparam I
þprototype
int ffs (int I);
þendprototype

    Find the first (least significant, right-most) bit in I which is
    set and return the index of that bit.  The least significant bit
    is numbered 1, the most significant bit is numbered 32.

þreturnvalue

    ffs() returns the smallest number þpa{N} for which bit þpa{N} is
    set in I (the least significant bit is numbered 1).  If there are
    no bits set in I (that is, I is zero), ffs() returns zero.

þseealso __fls()


þfunction fgetc()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
int fgetc (FILE *STREAM);
þendprototype

    Read the next character (as þtt{unsigned char} converted to an
    þtt{int}) from the input stream STREAM and advance the file
    position indicator of the stream (if defined).  All input from
    streams takes place as if characters were read by successive calls
    to fgetc().

    fgetc() is a function, in contrast to getc().

þreturnvalue

    fgetc() returns the next character from the stream.  If the stream
    is at end-of-file (before fgetc() is called), fgetc() sets the
    end-of-file indicator of the stream and returns EOF.  If a read
    error occurs, fgetc() sets the error indicator of the stream and
    returns EOF.

þhints

    Use feof() and ferror() to distinguish an end-of-file condition
    from a read error.

    If you assign the return value of fgetc() to a þtt{char} variable,
    you cannot compare it to EOF.  Use an þtt{int} variable instead.

þseealso feof() ferror() fgetchar() getc() getchar()


þfunction fgetchar()
þcompat PC
þheaders
#include <stdio.h>
þendheaders

þprototype
int fgetchar (void);
þendprototype

    fgetchar() is equivalent to þtt{fgetc (stdin)}.

þreturnvalue

    fgetchar() returns the next character from stdin.  If stdin is at
    end-of-file (before fgetchar() is called), fgetchar() sets the
    end-of-file indicator of stdin and returns EOF.  If a read error
    occurs, fgetchar() sets the error indicator of stdin and returns
    EOF.

þhints

    Use getchar() or þtt{fgetc(stdin)} instead of fgetchar() as
    fgetchar() is not portable.

þseealso fgetc() getchar()


þfunction fgetpos()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM POS
þprototype
int fgetpos (FILE *STREAM, fpos_t *POS);
þendprototype

    Store the current position of the file pointer of the file STREAM
    in the variable pointed to by POS.

þreturnvalue
þdescription
þitem 0
    success
þitem non-0
    error
þenddescription

þrestrictions

    fgetpos() does not work for text-mode streams unless either CR/LF
    pairs or LF only is used for all lines of the file.  If there are
    lines terminated with CR/LF and lines terminated with LF,
    fgetpos() does not work correctly.

þseealso fsetpos() ftell()


þfunction fgets()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam BUFFER N STREAM
þprototype
char *fgets (char *BUFFER, int N, FILE *STREAM);
þendprototype

    Read a string from STREAM to the array pointed to by BUFFER.  Stop
    after reading þpa{N}-1 characters or after a newline character has
    been read.  A null character is appended.

þreturnvalue

    fgets() returns BUFFER.  If end of file occurs before any
    character has been read, the array pointed to by BUFFER will
    remain unchanged and fgets() will return NULL.  If a read error
    occurs, fgets() will return NULL.

þseealso gets() scanf()


þfunction filelength()
þcompat PC
þheaders
#include <io.h>
þendheaders

þparam HANDLE
þprototype
long filelength (int HANDLE);
þendprototype

    Get the length of the file HANDLE, in bytes.

þreturnvalue

    filelength() returns the length of the file HANDLE.  If there is
    an error, filelength() returns -1.

þseealso chsize() ftruncate() lseek()


þfunction fileno()
þcompat UNIX
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
int fileno (FILE *STREAM);
þendprototype

    Get the file handle associated with STREAM.

þreturnvalue

    fileno() returns the file handle associated with STREAM.

þseealso fdopen()


þfunction _filesys()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam DRIVE NAME SIZE
þprototype
int _filesys (const char *DRIVE, char *NAME, size_t SIZE);
þendprototype

    Copy the file system type of the disk drive whose name is in the
    string pointed to by DRIVE to the array pointed to by NAME.  The
    size of the array is SIZE bytes.  DRIVE must point to a drive
    letter followed by a colon.  Examples for file system types are:
    FAT, LAN, HPFS, CDFS, NFS.

þreturnvalue

þdescription
þitem 0
    Success.  The file system type has been copied to NAME.
þitem -1
    Error.  errno contains the error number.
þenddescription

þseealso _fnlwr()

þsamplecode
char drive[3] = "C:";
char fsys[16];

if (_filesys (drive, fsys, sizeof (fsys)) != 0)
  perror ("_filesys");
else
  printf ("File system: %s\n", fsys);
þendsamplecode

    Typical output of the example:

þexample
File system: FAT
þendexample


þfunction flock()
þcompat UNIX
þheaders
#include <fcntl.h>
þendheaders

þparam HANDLE OPERATION
þprototype
int flock (int HANDLE, int OPERATION)
þendprototype

    Perform file locking.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þrestrictions

    flock() is not yet implemented (dummy function).


þfunction floor() floorl()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
double floor (double X);
long double floorl (long double X);
þendprototype

    Compute the largest integer that is less than or equal to X (round
    down).

    floorl() uses the þtt{long double} format.

þreturnvalue

    Return as floating-point number the largest integer that is less
    than or equal to X.

þseealso ceil() rint() trunc()


þfunction __fls()
þcompat emx
þheaders
#include <sys/builtin.h>
þendheaders

þparam I
þprototype
int __fls (int I);
þendprototype

    Find the last (most significant, left-most) bit in I which is
    set and return the index of that bit.  The most significant bit
    is numbered 32, the least significant bit is numbered 1.

    This function is implemented as inline function.

þreturnvalue

    __fls() returns the greatest number þpa{N} for which bit þpa{N} is
    set in I (the least significant bit is numbered 1).  If there are
    no bits set in I (that is, I is zero), __fls() returns zero.

þseealso ffs()


þfunction flushall()
þcompat PC
þheaders
#include <stdio.h>
þendheaders

þprototype
int flushall (void);
þendprototype

    Flush the buffers of all open streams.  Write the buffers of
    streams open for writing to their files, clear the buffers of
    streams open for reading.

    Locked streams are ignored; therefore, flushall() can be called in
    signal handlers.

þreturnvalue

    flushall() returns the number of open streams.

þhints

    If you don't need the return value (that is, the number of open
    streams) and deadlock on locked streams cannot occur, you should
    use
þexample
fflush (NULL)
þendexample
    instead of flushall().

þseealso fflush()


þfunction fmod() fmodl()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X Y
þprototype
double fmod (double X, double Y);
long double fmodl (long double X, long double Y);
þendprototype

    Compute remainder of þpa{X}/þpa{Y}.  The return value z is
    calculated such that X = i * Y + z, where i is an integer, z has
    the same sign as X and |z| < |þpa{Y}|.  If Y is 0.0, fmod()
    returns 0.0.

    fmodl() uses the þtt{long double} format.

þreturnvalue

    See above.


þfunction _fmutex_available()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
þendheaders

þparam SEM
þprototype
int _fmutex_available (_fmutex *SEM);
þendprototype

    Check if the _fmutex semaphore pointed to by SEM is available or
    owned, without changing the state of the semaphore and without
    blocking.  Return zero if the semaphore is owned, return a
    non-zero value if the semaphore is available.  Note that
    _fmutex_available() just returns a snapshot of the state of the
    semaphore; in presence of other threads or, in case of a shared
    semaphore, other processes, the state may change at any time, even
    before _fmutex_available() returns. This function can be used to
    avoid deadlock.

þreturnvalue

    _fmutex_available() returns a non-zero value if the semaphore is
    available.  _fmutex_available() returns 0 if the semaphore is
    owned.  The return value is undefined if the object pointed to by
    SEM has not been initialized by _fmutex_create().

þseealso _fmutex_close() _fmutex_create() _fmutex_open() _fmutex_release() _fmutex_request() _rmutex_available() _smutex_available()


þfunction _fmutex_close() _fmutex_checked_close()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
þendheaders

þparam SEM
þprototype
unsigned _fmutex_close (_fmutex *SEM);
void _fmutex_checked_close (_fmutex *SEM);
þendprototype

    Close an _fmutex semaphore.  SEM should point to an _fmutex object
    initialized by _fmutex_create().  If there have been þpa{N} calls
    to þhpt{_fmutex_open()} for this semaphore, þpa{N}+1 calls to
    _fmutex_close() are required to destroy the semaphore, one call
    for þhpt{_fmutex_create()} and one call per _fmutex_open().  The
    semaphore can no longer be used after it has been destroyed.

    _fmutex_checked_close() does not return an error code; it calls
    abort() on failure.

þreturnvalue

    _fmutex_close() returns 0 if successful.  Otherwise,
    _fmutex_close() returns an OS/2 error code defined in <os2.h> such
    as ERROR_INVALID_HANDLE.  Under DOS, _fmutex_close() always
    returns 0.

þseealso abort() atexit() _fmutex_available() _fmutex_create() _fmutex_open() _fmutex_release() _fmutex_request() _rmutex_close()


þfunction _fmutex_create() _fmutex_checked_create()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
þendheaders

þparam SEM FLAGS
þprototype
unsigned _fmutex_create (_fmutex *SEM, unsigned FLAGS);
void _fmutex_checked_create (_fmutex *SEM, unsigned FLAGS);
þendprototype

    Create an _fmutex semaphore.  SEM points to the _fmutex object to
    be initialized.  The semaphore is local to the process if FLAGS is
    0.  The semaphore can be shared by multiple processes if FLAGS is
    _FMC_SHARED.  A shared _fmutex semaphore must be located in shared
    memory (that is, SEM must point to an object in shared memory).

    _fmutex_checked_create() does not return an error code; it calls
    abort() on failure.

þreturnvalue

    _fmutex_create() returns 0 if successful.  Otherwise,
    _fmutex_create() returns an OS/2 error code defined in <os2.h>
    such as ERROR_TOO_MANY_HANDLES.  Under DOS, _fmutex_create()
    always returns 0.

þseealso abort() _fmutex_available() _fmutex_close() _fmutex_dummy() _fmutex_open() _fmutex_release() _fmutex_request() _rmutex_create()


þfunction _fmutex_dummy()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
þendheaders

þparam SEM
þprototype
void _fmutex_dummy (_fmutex *SEM);
þendprototype

    Create a dummy _fmutex semaphore.  SEM points to the _fmutex
    object to be initialized.  Behavior is undefined if ownership of a
    dummy _fmutex semaphore is requested when the semaphore is owned.
    _fmutex_close() must not be called on a dummy _fmutex semaphore.

þseealso _fmutex_create() _rmutex_dummy()


þfunction _fmutex_open() _fmutex_checked_open()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
þendheaders

þparam SEM
þprototype
unsigned _fmutex_open (_fmutex *SEM);
void _fmutex_checked_open (_fmutex *SEM);
þendprototype

    Open an _fmutex semaphore.  SEM should point to an _fmutex object
    initialized by þhpt{_fmutex_create()}.  _fmutex_open() is used to
    obtain access to a shared _fmutex semaphore created by another
    process.  All threads of the process which called _fmutex_create()
    have access to the semaphore without calling _fmutex_open().  Call
    þhpt{_fmutex_close()} when you no longer need access to the
    semaphore.

    _fmutex_checked_open() does not return an error code; it calls
    abort() on failure.

þreturnvalue

    _fmutex_open() returns 0 if successful.  Otherwise, _fmutex_open()
    returns an OS/2 error code defined in <os2.h> such as
    ERROR_INVALID_HANDLE.  Under DOS, _fmutex_open() always returns 0.

þseealso abort() atexit() _fmutex_available() _fmutex_close() _fmutex_create() _fmutex_release() _fmutex_request() _rmutex_open()


þfunction _fmutex_release() _fmutex_checked_release()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
þendheaders

þparam SEM
þprototype
unsigned _fmutex_release (_fmutex *SEM);
void _fmutex_checked_release (_fmutex *SEM);
þendprototype

    Relinquish ownership of the _fmutex semaphore pointed to by SEM.
    If another thread blocks in þhpt{_fmutex_request()} for this
    semaphore, _fmutex_release() will unblock one of the blocking
    threads.  The semaphore should be owned when _fmutex_release() is
    called.  Though not strictly necessary, ownership of the semaphore
    should have been requested by the same thread.

    _fmutex_checked_release() does not return an error code; it calls
    abort() on failure.  Note that _fmutex_checked_release() is slower
    than _fmutex_release() because it is not inlined.

þreturnvalue

    _fmutex_release() returns 0 if successful.  Otherwise,
    _fmutex_release() returns an OS/2 error code defined in <os2.h>
    such as ERROR_TOO_MANY_HANDLES.

þseealso abort() __cxchg() _fmutex_available() _fmutex_close() _fmutex_create() _fmutex_open() _fmutex_request() _rmutex_release()


þfunction _fmutex_request() _fmutex_checked_request()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
þendheaders

þparam SEM FLAGS
þprototype
unsigned _fmutex_request (_fmutex *SEM, unsigned FLAGS);
void _fmutex_checked_request (_fmutex *SEM, unsigned FLAGS);
þendprototype

    Request ownership of the _fmutex semaphore pointed to by SEM.  If
    FLAGS is 0, _fmutex_request() returns ERROR_INTERRUPT if
    interrupted by a signal while blocking.  FLAGS is zero or a set of
    flags combined with the þtt{|} operator.  If FLAGS includes
    _FMR_IGNINT, _fmutex_request() does not return if a signal occurs
    while blocking.  If FLAGS includes _FMR_NOWAIT and the semaphore
    is owned, _fmutex_request() returns immediately ERROR_MUTEX_OWNED.

    _fmutex_checked_request() does not return an error code; it calls
    abort() on failure.  Note that _fmutex_checked_request() is slower
    than _fmutex_request() because it is not inlined.

    If the semaphore is available, it will be set to owned and
    _fmutex_request() will return immediately.  If the semaphore is
    owned, _fmutex_request() will block while the semaphore is owned.
    When þhpt{_fmutex_release()} is called for the semaphore, one of
    the threads blocking in _fmutex_request() for this semaphore will
    wake up and gain ownership of the semaphore.

    Note that ownership of an _fmutex semaphore is not tied to a
    thread, that is, it's not a thread which owns the semaphore.  This
    is in contrast to OS/2's mutex semaphores (HMTX).  Deadlock will
    occur if _fmutex_request() is called twice for the same semaphore
    by the same thread without an intervening call to
    _fmutex_release().  This fact is important to keep in mind in
    presence of signals.  Signal handlers must not request semaphores
    which can be owned by the interrupted code.  You might want to
    block signals before requesting ownership of an _fmutex semaphore.

þreturnvalue

    _fmutex_request() returns 0 if successful.  Otherwise,
    _fmutex_request() returns an OS/2 error code defined in <os2.h>
    such as ERROR_INTERRUPT.

þrestrictions

    Under DOS, _fmutex_request() and _fmutex_checked_request() crash
    if the semaphore is already owned.

þseealso abort() __cxchg() _fmutex_available() _fmutex_close() _fmutex_create() _fmutex_open() _fmutex_release() _rmutex_request()


þfunction _fncmp()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam STRING1 STRING2
þprototype
int _fncmp (const unsigned char *STRING1, const unsigned char *STRING2);
þendprototype

    _fncmp() compares the two file name strings pointed to by STRING1
    and STRING2 and returns zero if the two strings are identical
    after conversion to upper case.  Otherwise, a non-zero value is
    returned which is negative if the string pointed to by STRING1 is
    less than the string pointed to by STRING2 and positive if the
    string pointed to by STRING1 is greater than the string pointed to
    by STRING2 after conversion to upper case.  Conversion to upper
    case includes accented characters etc., depending on the current
    country code and code page, DBCS characters are compared as is.

þreturnvalue
þdescription
þitem <0
   1st string < 2nd string
þitem =0
   1st string = 2nd string
þitem >0
   1st string > 2nd string
þenddescription

þseealso _nls_init() _nls_strupr() strcmp()


þfunction _fnexplode() _fnexplodefree()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam MASK LIST
þprototype
char **_fnexplode (const char *MASK);
void _fnexplodefree (char **LIST);
þendprototype

    Wildcard expansion of MASK.  _fnexplode() returns a vector
    containing pointers to the file name strings.  The list includes
    directories.  Hidden and system files are omitted.  The end of the
    list is marked by a NULL pointer.  On error, NULL is returned.
    MASK not being a wildcard or no files matching MASK is treated as
    error.  Memory is allocated with malloc().

    _fnlwr() is used to convert file names to lower case on
    upper-case-only file systems.

    Use _fnexplodefree() to free the memory allocated for a file name
    list.

þreturnvalue

    _fnexplode() returns a vector containing pointers to file name
    strings.

þseealso _dt_read() _fnlwr() glob() opendir() _wildcard()

þsamplefile /emx/samples/eatool.c


þfunction _fngetdrive()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam SRC
þprototype
char _fngetdrive (const char *SRC);
þendprototype

    Extract the drive name of the path name SRC.

þreturnvalue

    _fngetdrive () return as upper-case letter the drive name in the
    path name pointed to by SRC.  If the string does not contain a
    drive name, _fngetdrive() returns 0.

þseealso _fnisabs() _fnisrel() _getdrive()

þsamplecode
/* this fails if the -r emx option is used */

char *fname, drive;

drive = _fngetdrive (fname);
if (drive == 0)
  drive = _getdrive ();
þendsamplecode


þfunction _fnisabs() _fnisrel()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam NAME
þprototype
int _fnisabs (const char *NAME);
int _fnisrel (const char *NAME);
þendprototype

    _fnisabs() returns a non-zero value if the string pointed to by
    NAME is an absolute file name.  Otherwise, it returns 0.  Absolute
    file names start with \ or /, optionally preceded by a drive name.
    If _fnisabs() returns a non-zero value, the location of the file
    whose name is in the string pointed to by NAME does not depend on
    the current working directory (though it may depend on the current
    drive).

    _fnisrel() returns a non-zero value if the string pointed to by
    NAME is a relative file name.  Otherwise is returns 0.  Relative
    file names do not start with \ or / or a drive name.  If
    _fnisrel() returns a non-zero value, you can prepend a directory
    to the string pointed to by NAME.

    Note that both _fnisabs() and _fnisrel() return 0 for path names
    which start with a drive name not followed by \ or /.

þexample
name                  ³ _fnisabs (name) ³ _fnisrel (name)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
"\\"                  ³ non-zero        ³ zero
"/etc/passwd"         ³ non-zero        ³ zero
"c:\\foo\\bar"        ³ non-zero        ³ zero
"c:/"                 ³ non-zero        ³ zero
"foo"                 ³ zero            ³ non-zero
"foo/bar"             ³ zero            ³ non-zero
"c:foo"               ³ zero            ³ zero
"d:"                  ³ zero            ³ zero
""                    ³ zero            ³ zero
þendexample

þreturnvalue

    _fnisabs() returns a non-zero value if the string pointed to by
    NAME is an absolute file name.  Otherwise, _fnisabs() returns 0.

    _fnisrel() returns a non-zero value if the string pointed to by
    NAME is a relative file name.  Otherwise _fnisrel() returns 0.

þseealso _abspath() _fngetdrive()


þfunction _fnlwr() _fnlwr2() _rfnlwr() _sfnlwr()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam NAME BASE
þprototype
void _fnlwr (char *NAME);
void _fnlwr2 (char *NAME, const char *BASE);
void _rfnlwr (void);
void _sfnlwr (const char *NAME);
þendprototype

    _fnlwr() converts the file name pointed to by NAME to lower case
    unless the file system is case preserving.  Accented characters
    etc. are converted as well, DBCS characters are not changed.  If
    the file name does not contain a drive letter, it is assumed to
    refer to the drive set by _sfnlwr().  To save time, _fnlwr()
    caches information about file systems.  If the file system of a
    drive changes or if the current drive changes, you should call
    _rfnlwr() to reset the cache.  _sfnlwr() takes the drive name from
    the string pointed to by NAME for future _fnlwr() calls.  If
    _sfnlwr() hasn't been called since the last call to _rfnlwr() or
    if the file name does not contain a drive letter, _fnlwr() uses
    the current drive.

    _fnlwr2() is a variant of _fnlwr() which should be used when
    converting only a suffix of a path name to lower case.  NAME
    points to the suffix, BASE points to the beginning of the path
    name.  The string pointed to by BASE is used for getting the drive
    letter.

þhints

    _fnlwr2() should be used instead of _sfnlwr() and _fnlwr()
    whenever possible.

þseealso _filesys() _nls_init() _nls_strlwr()


þfunction fnmatch()
þcompat POSIX.2
þheaders
#include <fnmatch.h>
þendheaders

þparam PATTERN NAME FLAGS
þprototype
int fnmatch (const char *PATTERN, const char *NAME, int FLAGS);
þendprototype

    The fnmatch() function checks the string pointed to by NAME to see
    if it matches the file name pattern pointed to by the PATTERN
    argument.  The interpretation of the strings pointed to by PATTERN
    and NAME are is modified by FLAGS, which is the bitwise OR of zero
    or more of the following flags:

þdescription
þitem FNM_NOESCAPE

    If FNM_NOESCAPE is þem{not} set, a backslash character (`þtt{\}')
    in the string pointed to by PATTERN followed by any other character
    matches that second character in the string pointed to by NAME.
    In particular, `þtt{\\}' matches a backslash in the string pointed
    to by NAME.

    If FNM_NOESCAPE is set, a backslash character in the string
    pointed to by PATTERN is treated as an ordinary character.

þitem FNM_PATHNAME

    If FNM_PATHNAME is set, a slash character (`þtt{/}') in the string
    pointed to by NAME must be explicitely matched by a slash in the
    string pointed to by PATTERN; it is not matched by `þtt{?}',
    `þtt{*}', or `þtt{[]}' in the string pointed to by PATTERN.

    If FNM_PATHNAME is not set, a slash character in the string
    pointed to by NAME is treated as an ordinary character.

    If _FNM_OS2 or _FNM_DOS is set, the backslash character is treated
    like a slash, with repect to FNM_PATHNAME.

þitem FNM_PERIOD

    If FNM_PERIOD is set, then a `leading' period character (`þtt{.}')
    in the string pointed to by NAME matches a period (but not
    `þtt{?}', `þtt{*}', and `þtt{[]}') in the string pointed to by
    PATTERN.  The meaning of `leading' depends on FNM_PATHNAME: If
    FNM_PATHNAME is set, a period is `leading' if it is the first
    character in the string pointed to by NAME or if it immediately
    follows a slash.  If FNM_PATHNAME is not set, a period is
    `leading' if it is the first character of the string pointed to by
    NAME.

    If FNM_PERIOD is not set, a period in the string pointed to by
    NAME is treated as an ordinary character.

þitem _FNM_IGNORECASE

    If _FNM_IGNORECASE is set, letter case is ignored, that is, lower
    case letters match the corresponding upper case letters.  If
    _FNM_IGNORECASE is not set, lower case letters and upper case
    letters are distinct.

    _FNM_IGNORECASE is an emx extension.

þitem _FNM_PATHPREFIX

    If _FNM_PATHPREFIX is set, the string pointed to by PATTERN may match
    a complete path prefix of the string pointed to by NAME, that is,
    the string pointed to by NAME can have additional path components
    at the end.

    _FNM_PATHPREFIX is an emx extension.

þitem _FNM_POSIX

    If _FNM_POSIX is set, or none of _FNM_OS2 and _FNM_DOS are set,
    fnmatch() has POSIX.2 semantics.

    _FNM_POSIX is an emx extension.

þitem _FNM_OS2

    If _FNM_OS2 is set, fnmatch() has OS/2 semantics: Path components
    in the string pointed to by NAME have an implicit period at the
    end if they don't contain a period.  A period at the end of a
    component in the string pointed to by PATTERN may match zero
    characters at the end of a component of the string pointed to by
    NAME.  `þtt{?}' may match zero characters at the end of a
    component of the string pointed to by NAME or before a period.
    þtt{"/*/"} does not match UNC names.  `þtt{[}' in the string
    pointed to by PATTERN is treated as an ordinary character.  `þtt{\}'
    is a path separator.  _FNM_NOESCAPE implied.

    _FNM_OS2 is an emx extension.  At most one of _FNM_POSIX,
    _FNM_OS2, and _FNM_DOS can be set.

þitem _FNM_DOS

    If _FNM_OS2 is set, fnmatch() has DOS semantics: Path components
    in the string pointed to by NAME have an implicit period at the
    end if they don't contain a period.  A period at the end of a
    component in the string pointed to by PATTERN may match zero
    characters at the end of a component of the string pointed to by
    NAME.  `þtt{?}' may match zero characters at the end of a
    component of the string pointed to by NAME or before a period.
    `þtt{*}' does not match a period.  þtt{"/*/"} does not match UNC
    names.  `þtt{[}' in the string pointed to by PATTERN is treated as an
    ordinary character.  `þtt{\}' is a path separator.  _FNM_NOESCAPE
    is implied.

    _FNM_DOS is an emx extension.  At most one of _FNM_POSIX,
    _FNM_OS2, and _FNM_DOS can be set.

þenddescription

    The characters `þtt{?}', `þtt{*}', and `þtt{[]}' are interpreted
    as wildcard characters in the pattern.  `þtt{?}' matches one
    character, `þtt{*}' matches zero or more characters.  For
    _FNM_POSIX, `þtt{[]}' matches the set of characters listed between
    the brackets, ranges (such as `þtt{[0-9]}') are allowed.  If the
    first character after `þtt{[}' is `þtt{!}', all characters
    þem{not} in the set match the set.  DBCS characters are not
    allowed in sets.

þreturnvalue

    fnmatch() returns 0 if the string pointed to by NAME matches the
    string pointed to by PATTERN.  fnmatch() returns FNM_NOMATCH if the
    string pointed to by NAME does not match the string pointed to by
    PATTERN.  fnmatch() returns another non-zero value on error.

þimplementation

    If the first character after `þtt{[}' is `þtt{^}', all characters
    þem{not} in the set match the set.

þbugs

    Ranges in `þtt{[]}' which include letters don't work correctly if
    _FNM_IGNORECASE is set.

þseealso glob() _nls_tolower()


þfunction _fnslashify()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam NAME
þprototype
char *_fnslashify (char *NAME);
þendprototype

    _fnslashify() replaces backslashes by slashes in the string pointed to
    by NAME.

    _fnslashify() properly handles DBCS characters.

þreturnvalue

   _fnslashify() returns NAME.

þseealso _nls_init()


þfunction fopen()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam FNAME MODE
þprototype
FILE *fopen (const char *FNAME, const char *MODE);
þendprototype

    Open a stream.  FNAME points to a string giving the name of the
    file, MODE points to a string which specifies the file mode:

þlist
þitem þtt{r}

    Open the file for reading.  The file must exist.

þitem þtt{w}

    Open the file for writing.  If the file exists, it will be
    truncated to 0 bytes, destroying its contents.  If the file does
    not exist, it will be created.

þitem þtt{a}

    Open the file for appending.  Writing will always take place at
    the end of the file.  If the file does not exist, it will be
    created.

þitem þtt{r+}

    Open the file for both reading and writing.  The file must exist.

þitem þtt{w+}

    Open the file for both reading and writing.  If the file exists,
    it will be truncated to 0 bytes, destroying its contents.  If the
    file does not exist, it will be created.

þitem þtt{a+}

    Open the file for both reading and appending.  Writing will always
    take place at the end of the file.  If the file does not exist, it
    will be created.

þendlist

    There are two additional MODE flags which can be appended to one
    of the above modes: þtt{t} for text mode, þtt{b} for binary mode.
    Text mode, which is the default, skips CR characters on input and
    converts newline characters to CR/LF pairs on output.  If the last
    character of a file is Ctrl-Z, it is discarded on input.  Binary
    mode disables these transformations.

    The file is opened in the sharing mode SH_DENYNO, see
    þhpt{sopen()}.  If you want to use a different sharing mode, use
    þhpt{_fsopen()}.

þreturnvalue

    fopen() returns a new stream.  On error, fopen() returns NULL.

þseealso fclose() fdopen() freopen() _fsopen() sopen()


þfunction fork()
þcompat POSIX.1 *
þheaders
#include <unistd.h>
þendheaders

þprototype
int fork (void);
þendprototype

    Duplicate the current process.  A child process is created which is a
    copy of the calling process.  Both the parent process and the
    child process resume at the point where fork() was called.  The
    child process inherits the following attributes of the parent
    process:

þitemize

þitem

    environment

þitem

    dynamically loaded DLLs created with emx 0.9c or later

þitem

    memory (data segment, heap, stack, and data segments of DLLs
    created with emx 0.9c or later)

þitem

    signal actions

þitem

    file handles

þitem

    current working directories

þitem

    umask

þitem
    flags set with _uflags()

þitem

    break points.  This is an OS/2 bug.  To debug a program containing
    fork(), set a breakpoint in the branch of execution that's
    executed only in the parent process

þenditemize

    The new process differs from the parent process in the following
    ways:

þitemize

þitem

    the child process has a unique process ID

þitem

    the child process has a different parent process ID (the process
    ID of the parent process)

þitem

    the child process has copies of the file descriptors of the parent
    process.  The file pointers are shared

þitem

    Terminal settings are reset in the child process (that is, the
    IDEFAULT bit is set)

þitem

    all resources allocated using OS/2 calls (except for DLLs created
    with emx 0.9c or later) are not inherited by the child process:
    semaphores, queues, threads, memory, file handles, etcþ.

þitem

    the alarm clock is turned off

þitem

    the CPU time (returned by þhpt{clock()}) is set to 0

þitem

    non-shared _rmutex semaphores

þenditemize

    When the new process terminates, SIGCHLD is sent to the process
    which forked that process.

þreturnvalue

    On success, fork() returns the process ID of the new process to
    the calling process, 0 to the new process.  On error, fork()
    returns -1.

þrestrictions

    fork() is not implemented for DOS.  fork() works only in programs
    linked by ld.  It does not work in programs linked by LINK386.
    fork() is not available with the system call library sys.lib
    (þhpt{-Zsys}).

    The data segments of dynamic link libraries created with emx 0.9c
    or later are copied, therefore fork() can be used with the
    þhpt{-Zcrtdll} option of GCC and with DLLs created with emx 0.9c
    and later.  However, data segments of DLLs not created with emx or
    created with emx 0.9b or older are not duplicated, therefore
    fork() does not work correctly when using such DLLs.

    fork() is very inefficient for OS/2.  To start a child process,
    use spawn*() instead of fork() and exec*().

    If the parent process uses the þhpt{general terminal interface}
    for the keyboard, the child process cannot read from the keyboard
    using þhpt{_read_kbd()}, the general terminal interface, or the
    þtt{Kbd} OS/2 API functions.

    If the process has a non-contiguous heap (that is, multiple heap
    objects), fork() will fail.  Increase the initial heap size to
    work around this problem.  If any DLL used by the program shares
    the heap with the program and uses the heap in _DLL_InitTerm() by
    calling sbrk(), malloc(), etc., fork() will fail.  In both cases,
    fork() will return -1 and set errno to ENOMEM.

þseealso alarm() exec*() _rmutex_create() sbrk() sigaction() signal() spawn*() _uflags() wait() waitpid()


þfunction fpclassify()
þcompat C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
int fpclassify (float X);
int fpclassify (double X);
int fpclassify (long double X);
þendprototype

    Classify X as zero (FP_ZERO), subnormal (FP_SUBNORMAL), normal
    (FP_NORMAL), infinite (FP_INFINITE), or NaN (FP_NAN).  The
    argument X must be of a floating-point type.  Classification is
    based on the type of the argument.

þreturnvalue

    fpclassify() returns the value of one of the following macros:
    FP_ZERO, FP_SUBNORMAL, FP_NORMAL, FP_INFINITE, FP_NAN.

þseealso copysign() isfinite() isnan() isnormal() signbit()


þfunction _fpreset()
þcompat PC
þheaders
#include <float.h>
þendheaders

þprototype
void _fpreset (void);
þendprototype

    Reset the floating point coprocessor.

þseealso _clear87() _control87()


þfunction fprintf()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM FORMAT
þprototype
int fprintf (FILE *STREAM, const char *FORMAT, ...);
þendprototype

    Formatted output to the stream STREAM.  See printf() for details.

þreturnvalue

    On success, fprintf() returns the number of characters written to
    STREAM.  On error, fprintf() returns EOF.

þseealso fscanf() printf()


þfunction fputc()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam C STREAM
þprototype
int fputc (int C, FILE *STREAM);
þendprototype

    Write the character C (converted to an þtt{unsigned char}) to the
    output stream STREAM and advance the file position indicator of
    the stream (if defined).  All output to streams takes place as if
    characters were written by successive calls to fputc().

    fputc() is a function, in contrast to putc().

þreturnvalue

    fputc() returns the character written.  On error, fputc() sets the
    error indicator of the stream and returns EOF.

þseealso ferror() fprintf() fputchar() fputs() putc() putchar()


þfunction fputchar()
þcompat PC
þheaders
#include <stdio.h>
þendheaders

þparam C
þprototype
int fputchar (int C);
þendprototype

    þtt{fputchar (c)} is equivalent to þtt{fputc (c, stdout)}.

þreturnvalue

    fputchar() returns the character written.  On error, fputchar()
    sets the error indicator of stdout and returns EOF.

þhints

    Use putchar() or þtt{fputc (c, stdout)} instead of fputchar() as
    fputchar() is not portable.

þseealso fputc() putchar()


þfunction fputs()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STRING STREAM
þprototype
int fputs (const char *STRING, FILE *STREAM);
þendprototype

    Write the string pointed to by STRING to STREAM.  In contrast to
    puts(), a newline character is not appended automatically.

þreturnvalue

    fputs() returns a non-negative value if successful.  On error,
    fputs() returns EOF.

þseealso fgets() fputc() printf() puts() setvbuf()


þfunction fread()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam BUFFER SIZE COUNT STREAM
þprototype
size_t fread (void *BUFFER, size_t SIZE, size_t COUNT, FILE *STREAM);
þendprototype

    Read up to COUNT elements whose size is SIZE from STREAM to the
    array pointed to by BUFFER.  The file pointer is incremented by
    the number of bytes read.  If STREAM has been opened in text mode,
    CR/LF pairs are translated to newline characters and a Ctrl-Z
    character is discarded if it is the last character of the file.
    If fread() fails, the position of the file pointer will be
    undefined.

þreturnvalue

    fread() returns the number of elements successfully read, which
    may be less than COUNT if an error occurs or if the end of the
    file is reached.  Use ferror() and feof() to distinguish between
    these two conditions.

    Text mode translation does not affect the return value -- SIZE and
    COUNT are applied after translation.

þseealso fgetc() fgets() _fsetmode() fwrite()


þfunction free()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam MEM
þprototype
void free (void *MEM);
þendprototype

    Deallocate the block of memory pointed to by MEM.  MEM must point
    to a block which is still in use (that is, has not been freed) and
    must have been returned by calloc(), malloc(), realloc(),
    _tcalloc(), _tmalloc(), _trealloc(), _ucalloc(), _umalloc(),
    _utcalloc(), or _utmalloc().  Do not use the memory pointed to by
    MEM after calling free().  If MEM is NULL, free() does nothing.

þseealso calloc() _heapmin() malloc() realloc() _tfree() _umalloc()


þfunction freopen()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam FNAME MODE STREAM
þprototype
FILE *freopen (const char *FNAME, const char *MODE, FILE *STREAM);
þendprototype

    Open the file whose name is in the string pointed to by FNAME in
    the mode given by the string pointed to by MODE (see
    þhpt{fopen()}) and associate STREAM with that file.  If STREAM is
    associated with a file when freopen() is called, freopen() will
    close the file, ignoring any errors, before opening the file whose
    name is in the string pointed to by FNAME.

þreturnvalue

    If successful, freopen() returns STREAM.  On error, freopen()
    returns NULL.

þhints

    The major application of freopen() is to redirect stdin, stdout,
    or stderr.

þseealso _fassign() fclose() fopen() stderr


þfunction frexp() frexpl()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X EXP_PTR
þprototype
double frexp (double X, int *EXP_PTR);
long double frexpl (long double X, int *EXP_PTR);
þendprototype

    Extract mantissa and exponent of X.  The mantissa is returned, the
    exponent, an integer, is stored to *EXP_PTR.  The following holds
    for the mantissa m: 0.5 <= |m| < 1.0.  If X is zero, both the
    mantissa and the exponent are 0.

    frexpl() uses the þtt{long double} format.

þreturnvalue

    frexp() returns the mantissa of X.

þseealso ldexp() log()


þfunction fscanf()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM FORMAT
þprototype
int fscanf (FILE *STREAM, const char *FORMAT, ...);
þendprototype

    The stream STREAM is read and input is parsed according to the
    format string FORMAT.  For each field in the string pointed to by
    FORMAT there must be a pointer to the location receiving the
    value.  The pointers are passed after the FORMAT argument.

þreturnvalue

    If successful, fscanf() returns the number of fields converted.
    On error, fscanf() returns EOF.

þseealso fprintf() scanf()


þfunction fseek()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM OFFSET ORIGIN
þprototype
int fseek (FILE *STREAM, long OFFSET, int ORIGIN);
þendprototype

    fseek() moves the file pointer of STREAM.  The new position OFFSET
    is relative to ORIGIN: If ORIGIN is SEEK_SET, OFFSET is relative
    to the beginning of the file, if ORIGIN is SEEK_CUR, OFFSET is
    relative to the current position, if ORIGIN is SEEK_END, OFFSET is
    relative to the end of the file.  The file pointer cannot be moved
    before the beginning of the file.

    For text-mode streams, OFFSET must be either zero (with ORIGIN
    equal to SEEK_SET, SEEK_CUR, or SEEK_END) or a value returned by a
    call to ftell() on the same stream (with ORIGIN equal to
    SEEK_SET).

    If successful, fseek() resets the end-of-file indicator of the
    stream and undoes ungetc().  If STREAM is open for reading and
    writing (update), the next operation after fseek() can be either
    input or output.

þreturnvalue
þdescription
þitem 0
    success
þitem non-0
    error
þenddescription

þimplementation

    For binary-mode streams, the file position can be set beyond end
    of file; the data between end of file and the new position is
    undefined.

    For text-mode streams ending with a Ctrl-Z, SEEK_END is not
    allowed.

þrestrictions

    fseek() does not work for text-mode streams unless either CR/LF
    pairs or LF only is used for all lines of the file.  If there are
    lines terminated with CR/LF and lines terminated with LF, fseek()
    does not work correctly.

þseealso chsize() fgetpos() fsetpos() ftell() lseek() rewind()


þfunction _fseek_hdr()
þcompat emx
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
int _fseek_hdr (FILE *STREAM);
þendprototype

    Move the file pointer of STREAM to the a.out header of an
    executable file (a.out or bound .exe).  _fseek_hdr() assumes that
    the file pointer points to the beginning of the header (ie, the
    beginning of the file).  If no header is found, the file pointer
    will be repositioned to the original position.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error (errno is set)
þenddescription

þseealso _seek_hdr()


þfunction _fsetmode()
þcompat emx
þheaders
#include <stdio.h>
þendheaders

þparam STREAM MODE
þprototype
int _fsetmode (FILE *STREAM, const char *MODE);
þendprototype

    Change the text/binary mode of a stream.  MODE must point either
    to þtt{"b"} or to þtt{"t"}.  _fsetmode() is usually used to switch
    stdin or stdout to binary mode.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þrestrictions

    Do not call _fsetmode() on a stream with non-empty buffer.  If
    there is data in the buffer (either data to be read or data to be
    written), call fflush() before _fsetmode().  Otherwise, future
    behavior of the stream will be undefined.

þseealso fopen()


þfunction fsetpos()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM POS
þprototype
int fsetpos (FILE *STREAM, const fpos_t *POS);
þendprototype

    Restore the position of the file pointer of the file STREAM to the
    position saved by fgetpos() in the variable pointed to by POS.

þreturnvalue
þdescription
þitem 0
    success
þitem non-0
    error
þenddescription

þrestrictions

    fsetpos() does not work for text-mode streams unless either CR/LF
    pairs or LF only is used for all lines of the file.  If there are
    lines terminated with CR/LF and lines terminated with LF,
    fsetpos() does not work correctly.

þseealso fgetpos() fseek()


þfunction _fsopen()
þcompat PC
þheaders
#include <stdio.h>
#include <share.h>
þendheaders

þparam FNAME MODE SHFLAG
þprototype
FILE *_fsopen (const char *FNAME, const char *MODE, int SHFLAG);
þendprototype

    Open a stream.  FNAME points to a string giving the name of the
    file, MODE points to a string which specifies the file mode, see
    þhpt{fopen()} for details.

    The sharing mode of the file is given by SHFLAG.  The following
    sharing modes are available:

þdescription

þitem SH_DENYRW

    Deny read and write access

þitem SH_DENYRD

    Deny read access (permit write access)

þitem SH_DENYWR

    Deny write access (permit read access)

þitem SH_DENYNO

    Deny nothing (permit read and write access)

þenddescription

þreturnvalue

    _fsopen() returns a new stream.  On error, _fsopen() returns NULL.

þseealso fopen() sopen()


þfunction fstat()
þcompat UNIX
þheaders
#include <io.h>
#include <sys/types.h>
#include <sys/stat.h>
þendheaders

þparam HANDLE BUFFER
þprototype
int fstat (int HANDLE, struct stat *BUFFER);
þendprototype

    Retrieve information about the open file HANDLE.  fstat() will put
    the data into the structure pointed to by BUFFER.

    See þhpt{stat()} for a description of þtt{struct stat}.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error (errno is set)
þenddescription

þrestrictions

    st_dev and st_rdev are set to zero.  Each call to fstat() returns
    a different value for st_ino.

þseealso ioctl() stat() ttyname()


þfunction fsync()
þcompat BSD
þheaders
#include <io.h>
þendheaders

þparam HANDLE
þprototype
int fsync (int HANDLE);
þendprototype

    Flush the buffers associated with HANDLE and update the directory.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þrestrictions

    fsync() is currently not implemented for DOS: errno is set to
    ENOSYS.

    Due to a bug in HPFS.IFS, calling fsync() can be quite dangerous.
    If HPFS.IFS has the bug, and fsync() (i.e., DosResetBuffer) is
    called after writing to a file, and Ctrl+Alt+Del is pressed while
    the file is still open, HPFS.IFS will corrupt the allocation
    bitmap of the partition containing that file.  This may damange
    existing and future files and directories.  The bug is present in
    all HPFS.IFS versions of (at least) OS/2 2.0 through OS/2 Warp
    3.0, red box of 1994.  That HPFS.IFS bug seems to be fixed in
    FixPak XR_W005 and later.  Performing a system shutdown instead of
    pressing Ctrl+Alt+Del causes the same problem if the process that
    wrote to the file and called fsync() or DosResetBuffer cannot be
    killed.  As you cannot assume that the user of your application
    has a working HPFS.IFS, better don't call fsync() and
    DosResetBuffer.


þfunction ftell()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
long ftell (FILE *STREAM);
þendprototype

    ftell() retrieves the current position of the file pointer of
    STREAM.  

þreturnvalue

    ftell() returns the current position of the file pointer of
    STREAM, in characters.  On error, ftell() returns -1.

þrestrictions

    ftell() does not work for text-mode streams unless either CR/LF
    pairs or LF only is used for all lines of the file.  If there are
    lines terminated with CR/LF and lines terminated with LF,
    ftell() does not work correctly.

þseealso fgetpos() fseek()


þfunction ftime()
þcompat SysV
þheaders
#include <sys/timeb.h>
þendheaders

þparam PTR
þprototype
void ftime (struct timeb *PTR);
þendprototype

    Get the current time and store it to the structure pointed to by PTR.
    That structure has the following fields:

þlist

þitem dstflag

    Non-zero if daylight saving time is active for the local timezone.

þitem millitm

    Milliseconds of current time.

þitem þtt{time}

    Current time in seconds since 00:00:00 1-Jan-1970 Coordinated
    Universal Time (UTC, GMT).

þitem þtt{timezone}

    Difference between UTC and local time in minutes.  Positive values
    are to the west of the Prime Meridian.

þendlist

    See þhpt{tzset()} for a description of the TZ environment
    variable.

þseealso gettimeofday() settimeofday() time() tzset()


þfunction ftruncate()
þcompat BSD
þheaders
#include <io.h>
þendheaders

þparam HANDLE LENGTH
þprototype
int ftruncate (int HANDLE, long LENGTH);
þendprototype

    Truncate the file associated with HANDLE to at most LENGTH bytes.
    The position of the file pointer is undefined after calling this
    function.  If LENGTH is greater than the current length of the
    file, the length is not changed.  HANDLE must be open for writing.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso chsize() truncate()


þfunction ftw()
þcompat UNIX
þheaders
#include <sys/types.h>
#include <sys/stat.h>
#include <ftw.h>
þendheaders

þparam PATH FN NAME STAT_PTR FLAG DEPTH
þprototype
int ftw (const char *PATH,
         int (*FN)(const char *NAME, const struct stat *STAT_PTR, int FLAG),
         int DEPTH);
þendprototype

    Call FN for all entries of the directory tree whose root directory
    is in the string pointed to by PATH.  Directories are visited
    before the entries they contain.  FN is not called for the
    directories `.' and `..'.  A pointer to a string holding the name
    of the entry is passed in NAME.  Forward slashes are used to
    separate directories (backslashes in PATH are not converted to
    forward slashes).  _fnlwr() is called to convert the file names to
    lower case on upper-case-only file systems.  A structure filled in
    by stat() is pointed to by STAT_PTR.  FLAG is one of the
    following:

þdescription

þitem FTW_D

    NAME is a directory

þitem FTW_F

    NAME is a file

þitem FTW_NS

    stat() failed, the contents of structure pointed to by STAT_PTR
    are undefined

þitem FTW_DNR

    the directory whose name is in the string pointed to by NAME is
    unreadable (does not happen under DOS and OS/2)

þenddescription

    If FN returns 0, ftw() continues.  Otherwise, ftw() terminates and
    returns the value returned by FN.

    The DEPTH argument is ignored by this implementation of ftw().  In
    other implementations, DEPTH is used to restrict the number of
    file handles used by ftw(): one file handle is required for each
    level.  If DEPTH is less than the number of levels, ftw() will be
    slow.

    ftw() properly handles DBCS characters.

þreturnvalue

    If FN returns a non-zero value, ftw() returns that value.
    Otherwise, ftw() returns 0.  On error, ftw() returns -1.


þseealso _fnlwr() _nls_init() opendir()

þsamplefile /emx/test/ftwtest.c


þfunction _fullpath()
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þparam DST SRC SIZE
þprototype
int _fullpath (char *DST, const char *SRC, int SIZE);
þendprototype

    Construct an absolute path name for the file name or directory
    name pointed to by SRC.  The absolute path name is written to the
    array pointed to by DST.  It is assumed that there are SIZE bytes
    available at DST, this includes the terminating null character.
    DST can be identical to SRC.  Backslashes are translated into
    forward slashes.  The absolute path name is not translated to
    lower case.

    _fullpath() accesses the appropriate drive.  It fails if a
    directory does not exist unless the non-existing directory is the
    last member of the resulting path name.

    _fullpath() properly handles DBCS characters.

þreturnvalue

  If successful, _fullpath() returns 0.  If there is an error,
  _fullpath() returns -1.  If SIZE is too small, _fullpath() sets
  errno to ERANGE and returns -1.

þseealso _abspath() _nls_init()


þfunction fwrite()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam BUFFER SIZE COUNT STREAM
þprototype
size_t fwrite (const void *BUFFER, size_t SIZE, size_t COUNT, FILE *STREAM);
þendprototype

    Write COUNT elements whose size is SIZE from the array pointed to
    by BUFFER to STREAM.  The file pointer is incremented by the
    number of bytes written.  If fwrite() fails, the value of the file
    pointer is undefined.  If STREAM has been opened in text mode,
    newline characters are translated to CR/LF pairs.

þreturnvalue

    fwrite() returns the number of elements successfully written,
    which will be less than COUNT if an error occurs.  Text mode
    translation does not affect the return value -- SIZE and COUNT are
    applied before the translation.

þseealso fputc() fputs() fread() _fsetmode() printf() setvbuf()


þfunction g_box()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam X0 Y0 X1 Y1 COLOR FILL_FLAG
þprototype
void g_box (int X0, int Y0, int X1, int Y1, int COLOR, int FILL_FLAG);
þendprototype

    Draw a box which has the four vertices (X0,Y0), (X0,Y1), (X1, Y0)
    and (X1, Y1).  If FILL_FLAG is G_OUTLINE, the outline is drawn,
    that is, four lines between the vertices.  If FILL_FLAG is G_FILL,
    the interior of the box is filled.  The color COLOR is used for
    drawing.

þseealso g_clip()


þfunction g_clear()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam COLOR
þprototype
void g_clear (int COLOR);
þendprototype

    Clear the screen (graphics mode, only).  All pixels are set to the
    color COLOR.  The clipping rectangle is ignored.


þfunction g_clip()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam X0 Y0 X1 Y1
þprototype
void g_clip (int X0, int Y0, int X1, int Y1);
þendprototype

    Define the clipping rectangle.  Only pixels with X coordinate
    between X0 and X1 (inclusive) and with Y coordinate between Y0 and
    Y1 (inclusive) are drawn.  No drawing is performed outside that
    clipping rectangle.  After switching to graphics mode with
    g_mode(), the clipping rectangle is set to the entire screen.
    This is equivalent to calling

þexample
g_clip (0, 0, g_xsize-1, g_ysize-1);
þendexample

þseealso g_mode() g_xsize g_ysize


þfunction g_ellipse()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam CX CY RX RY COLOR FILL_FLAG
þprototype
void g_ellipse (int CX, int CY, int RX, int RY, int COLOR, int FILL_FLAG);
þendprototype

    Draw an ellipse or a circle.  One axis is horizontal, the other
    one vertical.  The center of the ellipse is at (CX,CY).  The
    horizontal radius is RX, the vertical radius is RY.  It's
    impossible to draw an ellipse with even length of an axis.  If
    FILL_FLAG is G_OUTLINE, the outline of the ellipse is drawn.  If
    FILL_FLAG is G_FILL, the interior of the ellipse is filled.  The
    color COLOR is used for drawing.

þseealso g_clip()


þfunction g_get()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam X Y
þprototype
int g_get (int X, int Y);
þendprototype

    Return the color of the pixel at (X,Y).  If (X,Y) is outside the
    clipping rectangle, -1 is returned.

þseealso g_clip() g_set()


þfunction g_hline()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam Y X0 X1 COLOR
þprototype
void g_hline (int Y, int X0, int X1, int COLOR);
þendprototype

    Draw a horizontal line between (X0,Y) and (X1,Y).  The color COLOR
    is used for drawing.

þseealso g_box() g_clip() g_line() g_vline()


þfunction g_line()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam X0 Y0 X1 Y1 COLOR
þprototype
void g_line (int X0, int Y0, int X1, int Y1, int COLOR);
þendprototype

    Draw a line of arbitrary slope between (X0,Y0) and (X1,Y1).  The
    color COLOR is used for drawing.  To draw horizontal or vertical
    lines, you should use g_hline() and g_vline(), respectively, which
    are specialized functions optimized for speed.

þseealso g_clip() g_hline() g_polygon() g_triangle() g_vline()


þfunction g_lock()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þprototype
void g_lock (void);
þendprototype

    Lock the screen.  Under OS/2, the screen must be locked while
    access graphics memory.  All the graphics drawing functions lock
    the screen, draw, and unlock the screen unless it's already
    locked.  To avoid the overhead of locking and unlocking for each
    function call, you can lock and unlock the screen yourself when
    performing many successive drawing operations.  Note that you
    should not lock the screen for more than a few seconds.  g_lock()
    increments a counter, which is initialized to zero by g_mode().
    The screen is locked while the counter is non-zero.  g_unlock()
    decrements the counter and unlocks the screen if the counter
    reaches zero.

þseealso g_unlock()


þfunction g_mode()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam MODE
þprototype
int g_mode (int MODE);
þendprototype

    Select graphics mode.  If MODE is G_MODE_OFF, graphics mode is
    turned off and 0 is returned.  Other values of MODE select the
    following graphics modes:

þdescription
þitem G_MODE_EGA_C
    640x200 EGA mode with 16 colors
þitem G_MODE_EGA_E
    640x350 EGA mode with 16 colors
þitem G_MODE_VGA_H
    640x480 VGA mode with 16 colors
þitem G_MODE_VGA_L
    320x200 VGA mode with 256 colors
þenddescription

    The global variables g_xsize, g_ysize and g_colors are set.  The
    clipping rectangle is set to the entire screen.

    General information about the graphics library: Programs using the
    graphics library work both under DOS and in OS/2 full-screen
    sessions.  The coordinates of the screen are (0,0) (upper left)
    through (þtt{g_xsize}-1,þtt{g_ysize}-1) (lower right).  You have
    to link with -lgraph.  Under DOS, emx option -acm is required, see
    `þhpt{Using emx options}'.

þreturnvalue

  If switching to graphics mode succeeds, gmode() returns 1.
  Otherwise, gmode() returns 0.

þseealso g_clip() g_modeset() g_colors g_xsize g_ysize

þsamplefile /emx/samples/graph.c


þfunction g_modeset()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam MODE FLAG
þprototype
int g_modeset (int MODE, int FLAG);
þendprototype

    Modify a graphics mode number.  The mode number to be modified is
    passed in MODE, the value passed in FLAG specifies how to modify
    the mode number: G_SET_KEEP causes the mode number to be not
    modified.

    The global variables g_xsize, g_ysize and g_colors are set.

þreturnvalue

    g_modeset() returns the new mode number.  On failure, g_modeset()
    returns G_MODE_OFF.

þrestrictions

    As only G_SET_KEEP is implemented, g_modeset() is useless.  It's
    included for compatibility with existing programs.

þseealso g_mode() g_colors g_xsize g_ysize


þfunction g_polygon()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam X Y N COLOR FILL_FLAG
þprototype
void g_polygon (const int *X, const int *Y, int N, int COLOR,
                int FILL_FLAG);
þendprototype

    Draw a polygon.  The N vertices are stored in the X and Y arrays:
    (þpa{X}[i],þpa{Y}[i]) for i = 0, ..., þpa{N}-1.  If FILL_FLAG is
    G_OUTLINE, the outline of the polygon is drawn, that is, a line
    from vertex 0 to vertex 1, from vertex 1 to vertex 2, ..., vertex
    þpa{N}-2 to vertex þpa{N}-1, vertex þpa{N}-1 to vertex 0.  If
    FILL_FLAG is G_FILL, the interior of the polygon is filled.  A
    point is defined to be in the interior of the polygon, if an
    infinite line to any side of that pixel intersects the polygon an
    odd number of times.  The color COLOR is used for drawing.

þseealso g_clip() g_line() g_triangle()


þfunction g_set()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam X Y COLOR
þprototype
void g_set (int X, int Y, int COLOR);
þendprototype

    Set the pixel (X,Y) to the color COLOR.

þseealso g_clip() g_get()


þfunction g_triangle()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam X0 Y0 X1 Y1 X2 Y2 COLOR FILL_FLAG
þprototype
void g_triangle (int X0, int Y0, int X1, int Y1, int X2, int Y2, int COLOR,
                 int FILL_FLAG);
þendprototype

    Draw a triangle.  The vertices are (X0,Y0), (X1,Y1) and (X2,Y2).
    If FILL_FLAG is G_OUTLINE, the outline of the triangle is drawn,
    that is, a line from (X0,Y0) to (X1,Y1), a line from (X1,Y1) to
    (X2,Y2) and a line from (X2,Y2) to (X0,Y0).  If FILL_FLAG is
    G_FILL, the interior of the triangle is filled.  The color COLOR
    is used for drawing.

þseealso g_clip() g_line() g_polygon()


þfunction g_unlock() g_unlockall()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þprototype
void g_unlock (void);
void g_unlockall (void);
þendprototype

    Unlock the screen.  g_unlock() undoes one invocation of g_lock()
    by decrementing the counter incremented by g_lock().  If the
    counter reaches zero, the screen is unlocked.  If the counter
    already was zero, the counter is not changed.  g_unlockall()
    undoes all invocations of g_lock() by resetting the counter to
    zero and unlocking the screen if the counter was non-zero.

þseealso g_lock()


þfunction g_vgapal()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam PAL FIRST N WAIT_FLAG
þprototype
void g_vgapal (const char *PAL, int FIRST, int N, int WAIT_FLAG);
þendprototype

    Set the VGA palette.  This function sets N (1 through 256) DAC
    registers starting with register FIRST (0 through 255).  For each
    register, 3 bytes are taken from the array pointed to by PAL: red,
    green, blue.  Each byte should have a value between 0 and 63,
    inclusive.  If WAIT_FLAG is non-zero, g_vgapal() waits for the
    vertical retrace to avoid snow on the screen, see þhpt{g_waitv()}.
    Under DOS, emx option -ai is required, see `þhpt{Using emx
    options}'.  Under OS/2, emxio.dll is required.

þseealso g_waitv() _outps8dac()


þfunction g_vline()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam X Y0 Y1 COLOR
þprototype
void g_vline (int X, int Y0, int Y1, int COLOR);
þendprototype

    Draw a vertical line between (X,Y0) and (X,Y1).  The color COLOR
    is used for drawing.

þseealso g_box() g_clip() g_hline() g_line()


þfunction g_waitv()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þprototype
void g_waitv (void);
þendprototype

    Wait for vertical retrace.  Under DOS, emx option -ai is required,
    see `þhpt{Using emx options}'.  Under OS/2, emxio.dll is required.
    Note that this function eats a lot of CPU time.

þseealso g_vgapal() _wait01()


þfunction g_wmode()
þcompat emx
þheaders
#include <graph.h>
þendheaders

þparam WMODE
þprototype
void g_wmode (int WMODE);
þendprototype

    Select a `writing mode'.  This is not yet implemented.


þfunction gcvt()
þcompat UNIX
þheaders
#include <stdlib.h>
þendheaders

þparam VALUE DIGITS BUFFER
þprototype
char *gcvt (double VALUE, int DIGITS, char *BUFFER);
þendprototype

    Convert the floating point number VALUE to a null-terminated
    string of ASCII digits in the array pointed to by BUFFER, using
    exponential-decimal format or floating-decimal and return a
    pointer to BUFFER.  gcvt() produces DIGITS significant digits.
    Trailing zeros and a trailing decimal point are removed.  The
    array pointed to by BUFFER must be big enough for holding the
    string.

    The decimal point character of the current locale is used.

    Exponential format is used if the absolute value of VALUE is less
    than 0.1 or if the exponent is greater than or equal to DIGITS.

    The empty string is stored to the array pointed to by BUFFER if
    DIGITS is less than one.

þreturnvalue

    gcvt() returns BUFFER.

þrestrictions

    NaN and other special values are not yet handled correctly.

þseealso setlocale() sprintf()


þfunction getc()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
int getc (FILE *STREAM);
þendprototype

    Read the next character (as þtt{unsigned char} converted to an
    þtt{int}) from the input stream STREAM and advance the file
    position indicator of the stream (if defined).  getc() is
    equivalent to fgetc().

    getc() may be implemented as macro, in contrast to fgetc().  In
    consequence, getc() may evaluate its argument more than once.

þreturnvalue

    getc() returns the next character from the stream.  If the stream
    is at end-of-file (before getc() is called), getc() sets the
    end-of-file indicator of the stream and returns EOF.  If a read
    error occurs, getc() sets the error indicator of the stream and
    returns EOF.

þimplementation

    getc() is implemented as in-line function for single-thread
    programs.

þhints

    Use getc() instead of fgetc() if you want to read a lot of
    characters.

    The argument of getc() should not be an expression with side
    effects.

þseealso fgetc() getchar()


þfunction getchar()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þprototype
int getchar (void);
þendprototype

    getchar() is equivalent to þtt{getc (stdin)}.

þreturnvalue

    getchar() returns the next character from stdin.  If stdin is at
    end-of-file (before getchar() is called), getchar() sets the
    end-of-file indicator of stdin and returns EOF.  If a read error
    occurs, getchar() sets the error indicator of stdin and returns
    EOF.

þimplementation

    getchar() is implemented as in-line function for single-thread
    programs.

þhints

    Use getchar() instead of þtt{fgetc(stdin)} if you want to read a
    lot of characters.

þseealso fgetc() getc()


þfunction getcwd()
þcompat POSIX.1
þheaders
#include <stdlib.h>
þendheaders

þparam BUFFER SIZE
þprototype
char *getcwd (char *BUFFER, size_t SIZE);
þendprototype

    getcwd() retrieves the name of the current working directory
    (excluding the drive name) and stores it to the array pointed to
    by BUFFER.  It is assumed that there are SIZE bytes available at
    BUFFER.  This includes the terminating 0.  If BUFFER is NULL, an
    array of suitable size, but at least SIZE bytes, is allocated with
    malloc().  getcwd() translates backslashes into forward slashes.
    It does not translate upper-case directory names to lower case.

    _getcwd() properly handles DBCS characters.

þreturnvalue

    If successful, getcwd() returns BUFFER, or a buffer allocated with
    malloc() if BUFFER is NULL.  On error, getcwd() sets errno and
    returns NULL.

þerrors
þdescription
þitem EINVAL
  SIZE is zero
þitem ENOMEM
  BUFFER is NULL and malloc() failed
þitem ERANGE
  BUFFER is not NULL and SIZE is positive and the length of the
  pathname plus 1 is greater than SIZE
þenddescription

þseealso chdir() _getcwd1() _getcwd2() getwd() _nls_init()


þfunction _getcwd1()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam BUFFER DRIVE
þprototype
int _getcwd1 (char *BUFFER, char DRIVE);
þendprototype

    _getcwd1() retrieves the name of the current working directory
    (starting with a slash, excluding the drive name) of drive DRIVE
    and stores it to the array pointed to by BUFFER.  If DRIVE is 0,
    the currently selected drive is used.  Otherwise, DRIVE must be in
    þtt{'A'} through þtt{'Z'}.  It is assumed that there are enough
    bytes available at BUFFER.  _getcwd1() translates backslashes into
    forward slashes.  It does not translate upper-case directory names
    to lower case.

    _getcwd1() properly handles DBCS characters.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso chdir() getcwd() _getcwd2() _nls_init()


þfunction _getcwd2()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam BUFFER SIZE
þprototype
char *_getcwd2 (char *BUFFER, int SIZE);
þendprototype

    _getcwd2() retrieves the name of the current working directory
    (including the drive name) and stores it to the array pointed to
    by BUFFER.  It is assumed that there are SIZE bytes available at
    BUFFER.  This includes the terminating 0.  If BUFFER is NULL, an
    array of suitable size, but at least SIZE bytes, is allocated with
    malloc().  _getcwd2() translates backslashes into forward slashes.
    It does not translate upper-case directory names to lower case.

    _getcwd2() properly handles DBCS characters.

þreturnvalue

    If successful, _getcwd2() returns BUFFER, or a buffer allocated
    with malloc() if BUFFER is NULL.  On error, _getcwd2() sets errno
    and returns NULL.

þerrors
þdescription
þitem EINVAL
  SIZE is zero
þitem ENOMEM
  BUFFER is NULL and malloc() failed
þitem ERANGE
  BUFFER is not NULL and SIZE is positive and the length of the
  pathname plus 3 is greater than SIZE
þenddescription

þseealso chdir() getcwd() _getcwd1() _nls_init()


þfunction _getdrive()
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þprototype
char _getdrive (void);
þendprototype

    Get the currently selected drive.

þreturnvalue

    _getdrive() returns as upper-case letter the currently selected
    drive.

þseealso _chdir2() _chdrive() _getcwd2()


þfunction getenv()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam NAME
þprototype
char *getenv (const char *NAME);
þendprototype

    Find NAME in the environment.

þreturnvalue

    If the variable is found, getenv() returns a pointer to the
    value.  Otherwise, getenv() returns NULL.

þseealso environ putenv()


þfunction _getext() _getext2()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam PATH
þprototype
char *_getext (const char *PATH);
char *_getext2 (const char *PATH);
þendprototype

    _getext() and _getext2() return a pointer to the extension of the
    file name pointed to by PATH.  The pointer points to the dot
    character that starts the extension.  If there is no extension,
    _getext() returns NULL and _getext2() returns the empty string
    þtt{""}.  If the last member of the string pointed to by PATH
    starts with a dot (þtt{"/usr/mattes/.profile"}, for instance),
    _getext() returns NULL and _getext2() returns the empty string
    þtt{""}.

    _getext() and _getext2() properly handle DBCS characters.

þreturnvalue

    See above.

þseealso _defext() _getname() _nls_init() _remext() _splitpath()


þfunction _getname()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam PATH
þprototype
char *_getname (const char *PATH);
þendprototype

    Return a pointer to the name part (last component, including the
    extension) of the file name pointed to by PATH.  The pointer
    returned by _getname() points to the character after the last path
    separator (slash, backslash and colon).  If there is no path
    separator, PATH is returned.

    _getname() properly handles DBCS characters.

þreturnvalue

    See above.

þseealso _getext() _nls_init() _remext() _splitpath()

þsamplecode
int main (int argc, char *argv[])
{
  argv[0] = _getname (argv[0]);   /* Remove pathname */
  ...
}
þendsamplecode


þfunction getopt()
þcompat POSIX.2
þheaders
#include <unistd.h>     /* without extensions */
#include <getopt.h>     /* with extensions */
þendheaders

þparam ARGC ARGV OPT_STR
þprototype
int getopt (int ARGC, char **ARGV, const char *OPT_STR);
þendprototype

    Parse command line options.  ARGC is the number of argument
    strings, ARGV points to an array of pointers to argument strings,
    OPT_STR points to a string describing the available options.
    Typically, the ARGC and ARGV arguments of main() are passed to
    getopt().  Each option is of one of the following types:

þitemize
þitem

    option without argument: the option letter is listed in the string
    pointed to by OPT_STR;

þitem

    option with mandatory argument: the option letter in the string
    pointed to by OPT_STR is followed by a colon

þitem

    option with optional argument: the option letter in the string
    pointed to by OPT_STR is followed by two colons.

þenditemize

    For instance,

þexample
c = getopt (argc, argv, "abc:d::v");
þendexample

    defines five options: -a, -b, -c and -v don't take arguments, -c
    takes a mandatory argument, -d takes an optional argument.

    Before the first call to getopt(), the global variable optind must
    be set to 0 (that's the initial value, see also bugs below).
    Calling getopt() parses the next command line option.  If there
    are no more command line options, getopt() returns -1.  After
    calling getopt(), optind is the index of the next command line
    argument.  After calling getopt(), the global variable optarg
    points to the argument of the option.  If there is no argument,
    optarg is NULL.

    There are three modes of operation, which are controlled by the
    global variable optmode declared in <getopt.h>:

þdescription
þitem GETOPT_UNIX

    Options are at the start of the command line.  When the first
    non-option is reached, parsing options stops and getopt() returns
    -1.  GETOPT_UNIX is the default.

þitem GETOPT_ANY

    Options may appear anywhere on the command line.  ARGV is
    reordered to move the non-options to the end.  When there are no
    more options, getopt() returns -1.  The remaining arguments are
    all the arguments of the command line which are not options.

þitem GETOPT_KEEP

    Options may appear anywhere on the command line.  If the current
    argument is not an option, getopt() returns 0.  optarg will point
    to the argument.  The next call to getopt() examines the next
    command line argument.

þenddescription

    The behavior on error (invalid option or missing argument) depends
    on the global variable opterr (which is non-zero unless set by the
    application) and the first character of the string pointed to by
    OPT_STR: If the global variable opterr is non-zero and the first
    character of the string pointed to by OPT_STR is not a colon,
    getopt() writes an appropriate error message to stderr and returns
    þtt{'?'} or þtt{':'}.  If opterr is zero and the first character
    of the string pointed to by OPT_STR is not a colon, getopt() does
    not display an error message and returns þtt{'?'}.  If the first
    character of the string pointed to by OPT_STR is a colon, getopt()
    does not display an error message and returns þtt{'?'} or
    þtt{':'}.  In all cases, the global variable optopt is set to the
    character code of the option which caused the error.  The error
    message includes the program name which is taken from
    þpa{ARGV}þtt{[0]}.

    The global variable optswchar declared in <getopt.h> is a string of
    characters which start options.  The default value is þtt{"-"},
    that is, options are started by hyphens.  You might want to assign
    þtt{"-/"} or þtt{"/"} to optswchar.

    If a command line argument consists of two equal switch characters
    (see optswchar), the remaining command line arguments are not
    treated as options.

    Options may be clustered, that is, if an option does not take an
    argument, getopt() treats the following character of the same
    command line argument as option.  If an option takes a mandatory
    argument, the argument either follows immediately the option or is
    taken from the next command line argument.  If an option takes an
    optional argument, the argument must immediately follow the
    option.

    When writing portable programs, you should not use optmode,
    optswchar and options taking optional arguments.  Only letters
    should be used as options.

    optmode must not be changed after the first call to getopt().
    optswchar, however, may be changed at any time.

þreturnvalue

    getopt() returns the next option character.  If there are no more
    command line options, -1 is returned (note that the value of the
    EOF macro defined in <stdio.h> is -1).  If an invalid option is
    encountered, þtt{'?'}  is returned.  If an argument is missing for
    an option which requires an argument, þtt{':'} (if the first
    character of the string pointed to by OPT_STR is a colon) or
    þtt{'?'} (if the first character of the string pointed to by
    OPT_STR is not a colon) is returned.  If optmode is GETOPT_KEEP
    and the current command line argument is not an option, 0 is
    returned.

þimplementation

    The variables optswchar and optmode are extensions.  Both are
    declared in <getopt.h> but not in <unistd.h>.  Optional arguments
    (two colons) are an extension.

    To reinitialize getopt(), that is, to restart parsing options, set
    optind to zero.

þbugs

    For POSIX.2, the ARGV argument should be a þtt{const} pointer;
    however, GETOPT_ANY reorders the array pointed to by ARGV.

þseealso main() _swchar()


þfunction getpagesize()
þcompat BSD
þheaders
#include <stdlib.h>
þendheaders

þprototype
int getpagesize (void);
þendprototype

    Return the page size, which is 4096 for the 386.

þreturnvalue

    getpagesize() returns the page size.


þfunction getpass()
þcompat UNIX
þheaders
#include <pwd.h>
#include <unistd.h>
þendheaders

þparam PROMPT
þprototype
char *getpass (const char *PROMPT);
þendprototype

    Print the string pointed to by PROMPT on stderr and read a
    password from the keyboard device without echoing.  Up to
    _PASSWORD_LEN (which is 128, defined in <pwd.h>) characters can be
    entered.

þreturnvalue

    getpass() returns a pointer to a statically allocated buffer.  The
    string will be null-terminated.

þseealso _getpass1() _getpass2()

þfunction _getpass1() _getpass2()
þcompat emx
þheaders
#include <pwd.h>
#include <unistd.h>
þendheaders

þparam PROMPT KBD
þprototype
char *_getpass1 (const char *PROMPT);
char *_getpass2 (const char *PROMPT, int KBD);
þendprototype

    Print the string pointed to by PROMPT on stderr and read a
    password from the keyboard device or from standard input without
    echoing.  Up to _PASSWORD_LEN (which is 128, defined in <pwd.h>)
    characters can be entered.

    _getpass1() reads from the keyboard device if standard input is
    associated with the console.  Otherwise, _getpass1() reads from
    standard input.

    _getpass2() reads from the keyboard device if KBD is non-zero.
    _getpass2() reads from standard input if KBD is zero.

þreturnvalue

    _getpass1() and _getpass2() return a pointer to a statically
    allocated buffer.  The buffer is shared by getpass(), _getpass1(),
    and _getpass2().  The string will be null-terminated.

þhints

    Use _getpass2() passing zero for KBD if the application should
    work correctly with pseudo ttys (ptys).

þseealso getpass()


þfunction getpid()
þcompat UNIX
þheaders
#include <process.h>
þendheaders

þprototype
int getpid (void);
þendprototype

    Get the process identification number of the calling process.

þreturnvalue

    getpid() returns the process identification number of the calling
    process.

þseealso getppid() _gettid()


þfunction getppid()
þcompat UNIX
þheaders
#include <process.h>
þendheaders

þprototype
int getppid (void);
þendprototype

    Get the process identification number of the parent process of
    the calling process.

þreturnvalue

    getppid() returnes the process identification number of the parent
    process of the calling process.

þseealso getpid()


þfunction getpwent() getpwuid() getpwnam() setpwent() endpwent()
þcompat UNIX
þheaders
#include <pwd.h>
þendheaders

þparam UID NAME
þprototype
struct passwd *getpwent (void);
struct passwd *getpwuid (int UID);
struct passwd *getpwnam (char *NAME);
void setpwent (void);
void endpwent (void);
þendprototype

    Dummy functions.

þseealso cuserid()


þfunction gets()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam BUFFER
þprototype
char *gets (char *BUFFER);
þendprototype

    Read a string from stdin to the array pointed to by BUFFER.  Stop
    after a newline (LF) character has been read.  The newline
    character is replaced with a null character.  Use fgets() instead
    as gets() doesn't know how big the array pointed to by BUFFER is.

þreturnvalue

    gets() returns BUFFER.  If an error occurs or the end of the file
    is reached, gets() returns NULL.

þseealso fgets() scanf()


þfunction _getsockhandle()
þcompat emx *
þheaders
#include <stdlib.h>
þendheaders

þparam HANDLE
þprototype
int _getsockhandle (int HANDLE);
þendprototype

    Return the internal socket handle associated with socket handle
    HANDLE.  As emx.dll maps socket handles internally, you cannot
    pass handles directly to IBM TCP/IP for OS/2 functions.  Use
    _getsockhandle() to retrieve the internal socket handle (for IBM
    TCP/IP for OS/2) of a socket handle.  Internal socket handles can
    be used with IBM TCP/IP for OS/2 functions, only.  Note that you
    cannot use socket handles and internal socket handles with OS/2
    API functions such as DosRead.

    You have to link with the þtt{socket} library (use the -lsocket
    option).

þreturnvalue

    _getsockhandle() returns an internal socket handle.  On error,
    _getsockhandle() sets errno and returns -1.

þrestrictions

    _getsockhandle() is implemented for OS/2 only.

    _getsockhandle() is not available with the system call library
    sys.lib (þhpt{-Zsys}).

þhints

    _getsockhandle() can be used with _impsockhandle() to pass socket
    handles down to child processes.  See þhpt{_impsockhandle()} for
    details.

þseealso _impsockhandle()


þfunction _gettid()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þprototype
int _gettid (void);
þendprototype

    Get the thread identification number of the calling thread.

þreturnvalue

    _gettid() returns the thread identification number of the calling
    thread.  Under DOS, _gettid() always returns 1.

þseealso _beginthread() getpid() _threadid _threadstore()


þfunction _getvol()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam DRIVE
þprototype
char *_getvol (char DRIVE);
þendprototype

    Retrieve the volume label of the drive DRIVE.  DRIVE must be zero
    (for retrieving the volume label of the currently selected drive)
    or in þtt{'A'} through þtt{'Z'} or in þtt{'a'} through þtt{'z'}.

þreturnvalue

    If successful, _getvol() returns a pointer to a statically
    allocated string of up to 11 characters containing the volume
    label.  That string will be overwritten by the next call to
    _getvol().  On error, _getvol() returns NULL.


þfunction getw()
þcompat UNIX
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
int getw (FILE *STREAM);
þendprototype

    Read a word (þtt{int}) from STREAM.  Avoid using this function.

þreturnvalue

    getw() returns the word read.  On error, getw() returns -1.  As -1
    is also a possible word value, you have to use ferror() to
    recognize an error condition.

þseealso putw() fwrite()


þfunction getwd()
þheaders
#include <stdlib.h>
þendheaders

þparam BUFFER
þprototype
char *getwd (char *BUFFER);
þendprototype

    getwd() retrieves the name of the current working directory
    (excluding the drive name) and stores it to the array pointed to
    by BUFFER.  It is assumed that there are MAXPATHLEN bytes
    available at BUFFER.  This includes the terminating 0.  MAXPATHLEN
    is defined in <sys/param.h>.  getwd() translates backslashes into
    forward slashes.  It does not translate upper-case directory names
    to lower case.

    getwd() properly handles DBCS characters.

þreturnvalue

    If successful, getwd() returns BUFFER.  On error, getwd() copies
    an error message to BUFFER and returns NULL.

þseealso getcwd() _nls_init()


þfunction gettimeofday()
þcompat BSD
þheaders
#include <sys/time.h>
þendheaders

þparam TP TZP
þprototype
int gettimeofday (struct timeval *TP, struct timezone *TZP);
þendprototype

    Obtain the current time and timezone.  If TP is not NULL, the
    current Coordinated Universal Time (UTC, GMT), expressed in
    seconds and microseconds since 00:00 1-Jan-1970, is stored to *TP.
    If TZP is not NULL, information about the timezone is stored to
    *TZP.

    The þtt{timeval} structure is defined as follows:

þexample
struct timeval
{
  long tv_sec;
  long tv_usec;
};
þendexample

    þtt{tv_sec} and þtt{tv_usec} are the number of seconds and
    microseconds, respectively, elapsed since 00:00:00 1-Jan-1970
    Coordinated Universal Time (UTC, GMT).

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso ftime() settimeofday() time()


þfunction glob() globfree()
þcompat POSIX.2
þheaders
#include <glob.h>
þendheaders

þparam PATTERN FLAGS ERRFUNC EPATH EERRNO PGLOB
þprototype
int glob (const char *PATTERN, int FLAGS,
          int (*ERRFUNC)(const char *EPATH, int EERRNO), glob_t *PGLOB);
void globfree (glob_t *PGLOB);
þendprototype

    The glob() function generates pathnames matching PATTERN.  The
    value of FLAGS is the bitwise OR of zero or more of the following
    flags:

þdescription
þitem GLOB_APPEND

    Append new pathnames to the ones generated by a previous call of
    glob().  When calling glob() with GLOB_APPEND, glob() must have
    been called without GLOB_APPEND for the structure pointed to by
    PGLOB and the members of that structure must have the same values
    as after the previous call to glob().  Moreover, the GLOB_DOOFFS
    bit of FLAGS must have the same value as for the previous call of
    glob().

þitem GLOB_DOOFFS

    Add null pointers at the beginning of PGLOBþtt{->gl_pathv}.  The
    number of null pointers is specified by PGLOBþtt{->gl_offs}.  If
    GLOB_APPEND is set, the number of null pointers is not changed.

þitem GLOB_ERR

    Return when a non-readable directory is encountered.  If GLOB_ERR
    is not set, glob() ignores non-readable directories.

þitem GLOB_MARK

    Append a slash to pathnames that are directories.

þitem GLOB_NOESCAPE

    Do not treat backslash as an escape character.  If GLOB_NOESCAPE
    is not set, backslash can be used to remove the special meaning
    from special characters such as` þtt{*}' and `þtt{[}'.

þitem GLOB_NOCHECK

    If PATTERN does not match any pathname, add PATTERN to
    PGLOBþtt{->gl_pathv}.  If PATTERN does not match any pathname and
    GLOB_NOCHECK is not set, glob() returns an error.

þitem GLOB_NOSORT

    Do not sort the pathnames.  If GLOB_NOSORT is not set, the
    pathnames added by this call of glob() are sorted according to
    strcoll().

þitem GLOB_PERIOD

    Also include pathnames that have a component starting with a
    period.  If GLOB_PERIOD is not set, those pathnames are excluded.

þenddescription

    If a non-readable directory is encountered and ERRFUNC is not a
    null pointer, ERRFUNC will be called with EPATH pointing to the
    pathname of the non-readable directory and EERRNO set to the errno
    value.  If ERRFUNC returns a non-zero value, glob() will stop the
    scan and return GLOB_ABEND.  If ERRFUNC returns zero, the behavior
    depends on GLOB_ERR.

    PGLOB points to a structure of type glob_t which is defined as
    follows:

þexample
typedef struct
{
  size_t gl_pathc;
  char **gl_pathv;
  size_t gl_offs;
  /* Members used internally are not shown here */
} glob_t;
þendexample

    The gl_pathc member contains the number of pathnames matched by
    PATTERN.  If gl_pathc is zero, the value of gl_pathv is undefined.
    gl_pathv contains a pointer to an array of pointers to pathnames:
    If GLOB_DOOFFS is set, the array starts with gl_offs null
    pointers.  If GLOB_DOOFFS is not set, gl_offs is ignored (treated
    as zero).  Following these null pointers (if any), glob() stores
    gl_pathc pointers to pathnames.  A null pointer follows the last
    pathname.

    The characters `þtt{?}', `þtt{*}', and `þtt{[]}' are interpreted
    as wildcard characters in the pattern.  `þtt{?}' matches one
    character, `þtt{*}' matches zero or more characters.  `þtt{[]}'
    matches the set of characters listed between the brackets, ranges
    (such as `þtt{[0-9]}') are allowed.  If the first character after
    `þtt{[}' is `þtt{!}', all characters þem{not} in the set match the
    set.

    globfree() deallocates any memory allocated by glob() for the
    structure pointed to by PGLOB.  glob() must have been called for
    the structure pointed to by PGLOB and the members of that
    structure must have the same values as after the last call to
    glob().

þreturnvalue

    glob() returns one of the following values:

þdescription
þitem 0
    Success
þitem GLOB_ABEND
    The operation of glob() was stopped for a non-readable directory
    because GLOB_ERR was set or ERRFUNC returned a non-zero value
þitem GLOB_NOMATCH
    No pathname matching PATTERN found
þitem GLOB_NOSPACE
    Out of memory
þenddescription

  Even if glob() returns a non-zero value, gl_pathc and gl_pathv of
  the structure pointed to by PGLOB are set.

þimplementation

    If the first character after `þtt{[}' is `þtt{^}', all characters
    þem{not} in the set match the set.

þseealso _fnexplode() fnmatch() strcoll() _wildcard()


þfunction gmtime()
þcompat C90
þheaders
#include <time.h>
þendheaders

þparam T
þprototype
struct tm *gmtime (const time_t *T);
þendprototype

    Convert the number of seconds elapsed since 00:00:00 1-Jan-1970
    Coordinated Universal Time (UTC, GMT) in the variable pointed to
    by T to a time and date structure (UTC) and return a pointer to
    the structure.  gmtime(), mktime() and localtime() use the same
    memory location, therefore the values are overwritten if one of
    these functions is called.

þreturnvalue

    gmtime() returns a pointer to a structure.

þseealso asctime() ctime() localtime() mktime() time()


þfunction _heapchk()
þcompat PC
þheaders
#include <malloc.h>
þendheaders

þprototype
int _heapchk (void);
þendprototype

    _heapchk() checks the default heap and the tiled default heap and
    all their blocks for consistency.  Note that _heapchk() may crash
    if the heap is corrupted.  _heapchk() can help debugging programs
    which experience heap problems.

þreturnvalue

    _heapchk() returns one of the following values:
þdescription
þitem _HEAPBADBEGIN
    The heap is corrupted.
þitem _HEAPBADEND
    The heap is corrupted.
þitem _HEAPBADNODE
    A block of the heap is damaged or the heap is corrupted.
þitem _HEAPEMPTY
    The heap has not been initialized.
þitem _HEAPOK
    The heap seems to be consistent.
þenddescription

þseealso _udefault() _heapset() _uheapchk() _utdefault()


þfunction _heapmin()
þcompat VAC++
þheaders
#include <malloc.h>
þendheaders

þprototype
int _heapmin (void);
þendprototype

    The _heapmin() function returns unused memory of the default
    regular heap to the operating system.  The heap is never made
    smaller than its initial size.  Calling _heapmin() is equivalent
    to calling _uheapmin() for the default heap.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso brk() _heapchk() sbrk() _theapmin() _udefault() _uheapmin()


þfunction _heapset()
þcompat PC
þheaders
#include <malloc.h>
þendheaders

þparam FILL
þprototype
int _heapset (unsigned FILL);
þendprototype

    _heapset() fills all bytes of all unused blocks of the default
    heap and the tiled default heap with FILL.  Note that _heapset()
    may crash if the heap is corrupted.  _heapset() can help debugging
    programs which erroneously depend on the contents of dynamically
    allocated blocks.  þhpt{_heapchk()} checks the heap more
    thoroughly than _heapset().

þreturnvalue

    _heapset() returns one of the following values:
þdescription
þitem _HEAPBADBEGIN
    The heap is corrupted.
þitem _HEAPBADEND
    The heap is corrupted.
þitem _HEAPBADNODE
    A block of the heap is damaged or the heap is corrupted.
þitem _HEAPEMPTY
    The heap has not been initialized.
þitem _HEAPOK
    The heap seems to be consistent.
þenddescription

þseealso _udefault() _heapchk() _uheapset() _utdefault()


þfunction _heap_walk() _uheap_walk()
þcompat VAC++
þheaders
#include <malloc.h>     /* for _heap_walk() */
#include <umalloc.h>    /* for _uheap_walk() */
þendheaders

þparam H CALLBACK
þparam BLOCK SIZE FLAG STATUS FNAME LINENO
þprototype
int _heap_walk (int (*CALLBACK)(const void *, size_t, int, int,
                                const char *, size_t));
int _uheap_walk (Heap_t H, int (*CALLBACK)(const void *, size_t, int, int,
                                           const char *, size_t));
þendprototype

    _heap_walk() applies the function pointed to by CALLBACK to all
    free and used blocks of the default heap and the tiled default
    heap.

    _uheap_walk() applies the function pointed to by CALLBACK to all
    free and used blocks of the heap H.

    Note that the heap is locked, so using the heap in the callback
    function will cause a deadlock.

þindent
    þtt{int my_walker (const void *}BLOCKþtt{, size_t }SIZEþtt{, int }FLAGþtt{,} þbreak
    þtt{               int }STATUSþtt{, const char *}FNAMEþtt{, size_t }LINENOþtt{);}
þendindent

    BLOCK points to a block of SIZE bytes.  FLAG is either _USEDENTRY
    (for a used block) or _FREEENTRY (for a free block).  STATUS is
    one of the following values, describing the status of the block:

þdescription
þitem _HEAPBADBEGIN
    The heap is corrupted.
þitem _HEAPBADEND
    The heap is corrupted.
þitem _HEAPBADNODE
    The block is damaged.
þitem _HEAPEMPTY
    The heap has not been initialized.
þitem _HEAPOK
    The heap seems to be consistent (_HEAPOK is 0).
þenddescription

    FNAME points to the file name of the source file in which the
    block has been allocated.  LINENO is the line number in which the
    block has been allocated.  FNAME is NULL if that information is
    not available, that is, if the object has not been allocated with
    a debugging heap function.


þreturnvalue

    _heap_walk() and _uheap_walk() return the last status (see above
    for a list of values) unless the callback function returned a
    non-zero value.  If the callback function returned a non-zero
    value, _heap_walk() and _uheap_walk() return that value.

þrestrictions

    FNAME is current always NULL as there are no debugging heap
    functions.

þhints

    Use an extra heap if you want to allocate memory in the callback
    function.

þseealso _heapchk() _udefault() _uheapchk() _uheap_walk2()

þsamplecode
#include <stdio.h>
#include <malloc.h>
#include <umalloc.h>

static int walk_dump (const void *obj, size_t size, int flag,
                      int status, const char *fname, size_t lineno)
{
  if (status == _HEAPOK)
    printf ("0x%.8lx 0x%.8lx %s\n",
            (unsigned long)obj, (unsigned long)size,
            flag == _FREEENTRY ? "free" : "used");
  return status;
}

int main (void)
{
  void *p;

  /* Avoid deadlock due to buffer allocation in printf()! */
  setvbuf (stdout, NULL, _IOLBF, BUFSIZ);

  p = malloc (1000);
  malloc (2000);
  free (p);
  _heap_walk (walk_dump);
  return 0;
}
þendsamplecode


þfunction hypot() hypotl()
þcompat C9X
þheaders
#include <math.h>
þendheaders

þparam X Y
þprototype
double hypot (double X, double Y);
long double hypotl (long double X, long double Y);
þendprototype

    Compute and return

þtypewriter
  sqrt (þpa{X}*þpa{X} + þpa{Y}*þpa{Y})
þendtypewriter

    On overflow, +INF is returned and errno is set to ERANGE.

    hypotl() uses the þtt{long double} format.

þreturnvalue

    See above.

þseealso sqrt()


þfunction _imphandle()
þcompat emx
þheaders
#include <io.h>
þendheaders

þparam HANDLE
þprototype
int _imphandle (int HANDLE);
þendprototype

    Register an OS/2 file handle (created by DosOpen, for instance)
    with the emx run-time system.  Without importing an OS/2 file
    handle with _imphandle() into the emx run-time system, that handle
    cannot be used with any C library function.  If necessary,
    _imphandle() relocates the file handle (this happens when sockets
    are used).  After calling _imphandle(), you can use the returned
    file handle both with library functions and OS/2 API functions,
    and HANDLE can no longer be used (unless identical to the handle
    returned).  _imphandle() must not be called for file handles not
    created by an OS/2 API function.  _imphandle() must not be called
    for socket handles.  Handles inherited from the parent process are
    already registered with the emx run-time system.

þreturnvalue

    _imphandle() returns a file handle.  On error, _imphandle() sets
    errno and returns -1.

þseealso dup() _impsockhandle() open()


þfunction _impsockhandle()
þcompat emx
þheaders
#include <sys/socket.h>
þendheaders

þparam HANDLE RESERVED
þprototype
int _impsockhandle (int HANDLE, int RESERVED);
þendprototype

    Register a socket handle of IBM TCP/IP with the emx run-time
    system.  HANDLE is the socket handle.  It must not be an emx
    socket handle.  To obtain the IBM TCP/IP socket handle of an emx
    socket handle, use þhpt{_getsockhandle()}.  RESERVED must be zero.

    You have to link with the þtt{socket} library (use the -lsocket
    option).

þreturnvalue

    _impsockhandle() returns a file handle.  On error,
    _impsockhandle() sets errno and returns -1.

þrestrictions

    _getsockhandle() is implemented for OS/2 only.

    _impsockhandle() is not available with the system call library
    sys.lib (þhpt{-Zsys}).

þhints

    _getsockhandle() and _impsockhandle() can be used to pass down
    socket handles to child processes.  Call _getsockhandle() in the
    parent process, pass the value returned by _getsockhandle() to the
    child process (on the command line, for instance), and call
    _impsockhandle() on that value in the child process.  Do not close
    the socket in the parent process until the child process has
    called _impsockhandle() for that socket (use a semaphore if the
    child process is run asynchronously)!  Note that socket handles
    are automatically inherited across fork(), therefore
    _impsockhandle() must not be used with fork().

þseealso _getsockhandle() _imphandle()


þfunction index()
þcompat BSD
þheaders
#include <strings.h>
þendheaders

þparam STRING C
þprototype
char *index (const char *STRING, int C);
þendprototype

    Return a pointer to the first occurrence of the character C in the
    null-terminated string pointed to by STRING.  If there is no
    character C in that string, NULL is returned.  If C is the null
    character (0), a pointer to the terminating null character of that
    string is returned.

þreturnvalue

    See above.

þseealso rindex() strchr()


þfunction _inp8() _inp16() _inp32()
þcompat emx *
þheaders
#include <sys/hw.h>
þendheaders

þparam PORT
þprototype
unsigned _inp8 (unsigned PORT);
unsigned _inp16 (unsigned PORT);
unsigned _inp32 (unsigned PORT);
þendprototype

    These functions read a single byte or word from a hardware port.
    _inp8() reads a byte from PORT, _inp16() reads a 16-bit word from
    PORT, _inp32() reads a 32-bit word from PORT.

    You have to call _portaccess() first to enable access to a range
    of ports.  To make your program work under DOS, you have to use
    emx option -ai, see `þhpt{Using emx options}'.  Under OS/2, your
    program requires emxio.dll in a directory listed in LIBPATH.

þreturnvalue

    _inp8(), _inp16() and _inp32() return the value read from PORT.

þseealso _portaccess() _inps8() _outp8() _wait0()


þfunction _inps8() _inps16() _inps32()
þcompat emx *
þheaders
#include <sys/hw.h>
þendheaders

þparam PORT DST COUNT
þprototype
void _inps8 (unsigned PORT, unsigned char *DST, unsigned COUNT);
void _inps16 (unsigned PORT, unsigned short *DST, unsigned COUNT);
void _inps32 (unsigned PORT, unsigned long *DST, unsigned COUNT);
þendprototype

    These functions read multiple bytes or words from a hardware port.
    _inps8() reads COUNT bytes from PORT to the array pointed to by
    DST.  _inps16() reads COUNT 16-bit words from PORT to the array
    pointed to by DST.  _inps32() reads COUNT 32-bit words from PORT
    to the array pointed to by DST.

    The COUNT argument of _inps8() must not exceed 65535.

    The array pointed to by DST of _inps16() must be aligned on a
    16-bit boundary, that is, the address must be even.  COUNT must
    not exceed 32768.

    The array pointed to by DST of _inps32() must be aligned on a
    32-bit boundary, that is, the address must be a multiple of four.
    COUNT must not exceed 65536.

    You have to call _portaccess() first to enable access to a range
    of ports.  To make your program work under DOS, you have to use
    emx option -ai, see `þhpt{Using emx options}'.  Under OS/2, your
    program requires emxio.dll in a directory listed in LIBPATH.

þseealso _portaccess() _inp8() _outps8()


þfunction _int86()
þcompat PC
þheaders
#include <dos.h>
þendheaders

þparam INT_NUM INP_REGS OUT_REGS
þprototype
int _int86 (int INT_NUM, const union REGS *INP_REGS, union REGS *OUT_REGS);
þendprototype

    Issue a software interrupt under DOS.  This function loads the
    processor registers EAX, EBX, ECX, EDX, ESI and EDI from INP_REGS,
    calls software interrupt INT_NUM and stores the processor
    registers EAX, EBX, ECX, EDX, ESI, EDI and the flags register to
    OUT_REGS.

    emx option -ac must be used to enable _int86().  If -ac is not
    used, a protection violation exception occurs when _int86() is
    called.  See `þhpt{Using emx options}'.

þreturnvalue

    _int86() returns the value of the EAX register.

þrestrictions

    _int86() is not supported under OS/2 (there are no software
    interrupts under OS/2).  Calling _int86() under OS/2 results in a
    protection violation.

    The emx DOS extender currently supports only interrupts 0x10,
    0x11, 0x14, 0x16, 0x17, 0x21 and 0x33.  Please note the following
    difference to DOS C compilers: the REGS union does not contain an
    þtt{x.cflag} field.  The complete flags register is stored to the
    þtt{e.eflags} field instead.  The carry flag is available in bit 0
    of the þtt{e.eflags} and þtt{x.flags} fields.

    The following functions of interrupt 0x10 (video) are supported
    (the AH register contains the function number):

þindent

        0x00-0x0f, 0x10 (only subfunctions which don't involve
        pointers), 0x13, 0x1a, 0x40-0x4e (Hercules GRAFIX), 0x4f
        (VESA, subfunction AL=0x06 not supported), 0x6f, 0xf0, 0xf1,
        0xf6

þendindent

    The following functions of interrupt 0x21 (DOS call) are supported
    (the AH register contains the function number):

þindent

        0x01-0x0c, 0x0e, 0x19, 0x2a-0x2e, 0x30, 0x33, 0x36-0x37,
        0x39-0x47, 0x4b-0x4f, 0x54, 0x56, 0x57, 0x5a, 0x5b

þendindent

    The following functions of interrupt 0x33 (mouse) are supported
    (the AX register contains the function number):

þindent

        0x00-0x0b, 0x0d-0x13, 0x15, 0x1a-0x28, 0x2a, 0x2f-0x32, 0x35

þendindent

    No pointer conversion is done for interrupts 0x11, 0x14, 0x16 and
    0x17.  That is, you cannot use functions which involve pointers to
    buffers in memory.

þsamplefile /emx/test/int10.c


þfunction ioctl()
þcompat SysV *
þheaders
#include <sys/ioctl.h>
#include <sys/termio.h>   /* for System V terminal interface */
#include <sys/kbdscan.h>  /* optional, for extended scan codes */
þendheaders

þparam HANDLE REQUEST INT_ARG PTR_ARG TIO
þprototype
int ioctl (int HANDLE, int REQUEST, int INT_ARG);
int ioctl (int HANDLE, int REQUEST, void *PTR_ARG);
int ioctl (int HANDLE, int REQUEST, struct termio *TIO);
þendprototype

    Device control for HANDLE.  REQUEST codes are:

þdescription
þitem TCGETA

    Get the parameters associated with the terminal HANDLE and store
    them in the object pointed to by TIO.  See also `þhpt{General
    terminal interface}'.

þitem TCSETA

    Immediately set the parameters associated with the terminal HANDLE
    from the object pointed to by TIO.  See also `þhpt{General
    terminal interface}'.

þitem TCSETAF

    Set the parameters associated with the terminal HANDLE from the
    object pointed to by TIO after waiting for the output to drain and
    after fglusing the input queue.  See also `þhpt{General terminal
    interface}'.

þitem TCSETAW

    Set the parameters associated with the terminal HANDLE from the
    object pointed to by TIO after waiting for the output to drain.
    See also `þhpt{General terminal interface}'.

þitem TCFLSH

    Flush the terminal queues.  If INT_ARG is 0, the input queue is
    flushed; if INT_ARG is 1, the output queue is flushed; if INT_ARG
    is 2, both the input and output queues are flushed.  Works only if
    HANDLE refers to the keyboard.  Only flushing the keyboard queue
    is implemented.

þitem TCSBRK

    Wait for output to drain and then send a break. The length of the
    break depends on INT_ARG.  Currently ignored.  It is not yet
    specified how the length of the break depends on INT_ARG.

þitem TCXONC

    flow control, depending on INT_ARG.  Currently ignored

þitem FIONREAD

    Get number of available characters.  The number of available
    characters is stored to the int pointed to by PTR_ARG.  FIONREAD
    is implemented for the following types of handles:

þitemize
þitem

    Terminal handles (keyboard) for which the general terminal
    interface is enabled.  Note that if ICANON is set, the number of
    characters in the keyboard buffer is returned which is not the
    number of characters available for read(), as at least one of the
    buffered characters (carriage return) is used for command line
    editing

þitem

    Pseudo TTYs and console device implemented by xf86sup.sys

þitem

    Named pipes

þitem

    Pipes created with pipe() by programs using emx.dll

þitem

    Sockets

þitem

    All file handles under DOS (0 or 1 character available).

þenditemize

þitem FGETHTYPE

    Get the handle type and store it to the int pointed to by
    PTR_ARG.  See <sys/ioctl.h> for handle types (HT_FILE, for
    instance).

þenddescription

    There are additional REQUESTS codes for socket handles.

þreturnvalue

    On error, ioctl() sets errno and returns -1.  Otherwise, ioctl()
    returns 0 unless a different return value is defined above.

þrestrictions

    With the system call library sys.lib (þhpt{-Zsys}), only the
    FGETHTYPE request is available.

    The TCSBRK and TCXONC requests are currently ignored.

    Under DOS, for requests TCGETA, TCSETA, TCSETAF, TCSETAW, and
    TCFLSH, the value of the HANDLE argument must be 0.

    TCFLSH is implemented for the keyboard, only.

þseealso fcntl() open() read()


þfunction isascii()
þcompat UNIX
þheaders
#include <ctype.h>
þendheaders

þparam C
þprototype
int isascii (int C);
þendprototype

    Return a non-zero value iff C is a valid ASCII character (0
    through 127).  isascii() can be applied to all integer values.
    isascii() is implemented both as macro and as function.

þreturnvalue

    See above.

þseealso isalnum()


þfunction isalnum() isalpha() iscntrl() isdigit() isgraph() islower() isprint() ispunct() isspace() isupper() isxdigit()
þcompat C90
þheaders
#include <ctype.h>
þendheaders

þparam C
þprototype
int isalnum (int C);
int isalpha (int C);
int iscntrl (int C);
int isdigit (int C);
int isgraph (int C);
int islower (int C);
int isprint (int C);
int ispunct (int C);
int isspace (int C);
int isupper (int C);
int isxdigit (int C);
þendprototype

    These functions (or macros) are used for determining the type of a
    character, depending on the current locale.  C must be an integer
    which is representable as þtt{unsigned char} (that is, 0 through
    255), or equal to EOF; otherwise the behavior is undefined.  These
    functions are implemented both as macros and as functions.

    isalnum() tests for alphanumeric characters, that is, any
    character for which isalpha() or isdigit() is true.

    isalpha() tests for alphabetic characters, that is, any character
    for which islower() or isupper() is true.  For locales other than
    þtt{"C"}, isalpha() may also return true for characters for which
    none of iscntrl(), isdigit(), ispunct() or isspace() is true.

    iscntrl() tests for control characters.  Control characters are
    not printing characters.

    isdigit() tests for decimal digits (þtt{'0'} through þtt{'9'}).

    isgraph() tests for printing characters except space (þtt{' '}),
    that is, any character (except space) for which isprint() is true.

    islower() tests for lower-case characters, that is, þtt{'a'}
    trough þtt{'z'}.  For locales other than þtt{"C"}, islower() may
    also return true for characters for which none of iscntrl(),
    isdigit(), ispunct() or isspace() is true.

    isprint() tests for printing characters including space (þtt{' '}).
    Printing characters are characters which occupy one printing
    position on a display device.

    ispunct() tests for punctutation characters, that is, printing
    characters for which isalnum() is false and which are not space
    (þtt{' '}).

    isspace() tests for white-space characters.  In locales other than
    þtt{"C"}, isspace() may return true for characters for which
    isalnum() is false.

    isupper() tests for upper-case characters, that is, þtt{'A'}
    trough þtt{'Z'}.  For locales other than þtt{"C"}, isupper() may
    also return true for characters for which none of iscntrl(),
    isdigit(), ispunct() or isspace() is true.

    isxdigit() tests for hexadecimal digits (þtt{'0'} through
    þtt{'9'}, þtt{'a'} through þtt{'f'}, and þtt{'A'} through
    þtt{'F'}).

þreturnvalue

    These functions return a non-zero value if the condition is true,
    or 0 if it is not true.

þrestrictions

    Currently, locale is ignored.

þseealso isascii() setlocale() tolower() toupper() _tolower() _toupper()


þfunction isatty()
þcompat UNIX
þheaders
#include <io.h>
þendheaders

þparam HANDLE
þprototype
int isatty (int HANDLE);
þendprototype

    Returns a non-zero value if HANDLE refers to a character device.
    Returns 0 if HANDLE does not refer to a character file (file or
    pipe).  If there is an error, errno is set and -1 is returned.

þreturnvalue

    See above.

þseealso _isterm() ioctl()


þfunction isfinite()
þcompat C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
int isfinite (float X);
int isfinite (double X);
int isfinite (long double X);
þendprototype

    Determine whether X is finite (zero, subnormal, normal) or not
    (infinite, NaN).  The argument X must be of a floating-point type.
    Determination is based on the type of the argument.

þreturnvalue

    isfinite() returns a non-zero value if X is has a finite value;
    isfinite() returns 0 otherwise.

þseealso fpclassify() isnan() isnormal() signbit()


þfunction isnan()
þcompat C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
int isnan (float X);
int isnan (double X);
int isnan (long double X);
þendprototype

    Determine whether X is a NaN.  The argument X must be of a
    floating-point type.  Determination is based on the type of the
    argument.

þreturnvalue

    isnan() returns a non-zero value if X has a NaN value; isnan()
    returns 0 otherwise.  

þseealso fpclassify() isfinite() isnormal() signbit()


þfunction isnormal()
þcompat C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
int isnormal (float X);
int isnormal (double X);
int isnormal (long double X);
þendprototype

    Determine whether X is normal or not (zero, subnormal, infinite,
    NaN).  The argument X must be of a floating-point type.
    Determination is based on the type of the argument.

þreturnvalue

    isnormal() returns a non-zero value if X has a normal value;
    isnormal() returns 0 otherwise.

þseealso fpclassify() isfinite() isnan() signbit()


þfunction _isterm()
þcompat emx
þheaders
#include <io.h>
þendheaders

þparam HANDLE
þprototype
int _isterm (int HANDLE);
þendprototype

    Returns a non-zero value if HANDLE refers to the standard input
    (keyboard) or standard output (screen) device.  Otherwise, returns
    0.  If there is an error, errno is set and 0 is returned.

    Consider using þtt{ioctl (FGETHTYPE)} instead.

þreturnvalue

    See above.

þseealso isatty() ioctl()


þfunction _itoa() _ltoa() _ultoa()
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þparam VALUE STRING RADIX
þprototype
char *_itoa (int VALUE, char *STRING, int RADIX);
char *_ltoa (long VALUE, char *STRING, int RADIX);
char *_ultoa (unsigned long VALUE, char *STRING, int RADIX);
þendprototype

    Convert the number VALUE to a string using the number base RADIX
    (between 2 and 36).  The string is stored to the array pointed to
    by STRING.

þreturnvalue

    _itoa(), _ltoa() and _ultoa() return STRING.

þseealso atoi() _lltoa() sprintf() strtol()


þfunction kill()
þcompat UNIX *
þheaders
#include <signal.h>
þendheaders

þparam PID SIG
þprototype
int kill (int PID, int SIG);
þendprototype

    Send the signal SIG to process PID.  If PID is smaller than -1,
    the signal is sent to process -þpa{PID} and its children.

    If PID is the process ID of the process which is calling kill(),
    the signal is sent to the main thread (thread 1) of that process
    (unless the syscam call library is used).  Use raise() to generate
    a signal in the current thread.

    If SIG is 0, kill() checks only whether PID is valid or not.

    See section þref{signal processing} for details on
    þhpt{signal processing}.

þreturnvalue

    If successful, kill() returns 0.  Otherwise kill() sets errno and
    returns -1.

þerrors
þdescription
þitem EINVAL
    SIG is not a valid signal number
þitem ESRCH
    PID is not the process ID of a process or process PID is not a
    child process
þenddescription

þrestrictions

    Only SIGKILL can be sent to arbitrary processes.
    Only SIGINT and SIGBREAK can be sent to arbitrary child processes.
    A process can send the other signals only to itself, see
    þhpt{raise()}, or to other emx programs.

    Checking PID by passing 0 for SIG works for child processes only.

    Special treatment of þpa{PID}=0, þpa{PID}=1 and þpa{PID}=-1 is not
    implemented.  Negative values of PID are implemented for OS/2 only
    and work only for direct children of the caller.

    When using the system call library sys.lib (þhpt{-Zsys}), a
    process can send arbitrary signals to itself, only SIGINT and
    SIGBREAK can be sent to only child processes, negative values of
    PID are not allowed.  Moreover, kill() cannot be used to send a
    signal to thread 1; the signal will be generated in the current
    thread.

þseealso pause() raise() sigaction() signal()


þfunction labs()
þcompat C90
þheaders
#include <stdlib.h>     /* use this */
#include <math.h>       /* or this */
þendheaders

þparam N
þprototype
long labs (long N);
þendprototype

    Compute the absolute value of N.  In-line code is generated for
    this function.

þreturnvalue

    If N is negative, labs() returns -þpa{N}.  Otherwise, labs()
    returns N.

þseealso abs() fabs()


þfunction ldexp() ldexpl()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X EXP
þprototype
double ldexp (double X, int EXP);
long double ldexpl (long double X, int EXP);
þendprototype

    Compute and return X * 2 ^ EXP.  On overflow, NaN is returned and
    errno is set to ERANGE.

    ldexpl() uses the þtt{long double} format.

þreturnvalue

    See above.

þseealso frexp() pow()


þfunction _lldiv() _uldiv() _ulldiv()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam NUM DEN
þprototype
_lldiv_t _lldiv (long long NUM, long long DEN);
_uldiv_t _uldiv (unsigned long NUM, unsigned long DEN);
_ulldiv_t _ulldiv (unsigned long long NUM, unsigned long long DEN);
þendprototype

    Perform an integer division, dividing NUM by DEN.  The quotient
    and the remainder are returned in the quot and rem fields,
    respectively.

    The following table shows the signs of quot and rem depending on
    the signs of NUM and DEN for _lldiv():

þexample
NUM DEN ³ quot rem
ÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ
 +   +  ³  +    +
 +   -  ³  -    +
 -   +  ³  -    -
 -   -  ³  +    -
þendexample

    þbf{Note:} Do not use the -fpcc-struct-return option of GCC.

þreturnvalue

    _lldiv(), _uldiv() and _ulldiv() return a structure which contains
    the quotient and the remainder in the quot and rem fields,
    respectively.

þseealso div() ldiv()


þfunction _lltoa() _ulltoa()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam VALUE STRING RADIX
þprototype
char *_lltoa (long long VALUE, char *STRING, int RADIX);
char *_ulltoa (unsigned long long VALUE, char *STRING, int RADIX);
þendprototype

    Convert the number VALUE to a string using the number base RADIX
    (between 2 and 36).  The string is stored to the array pointed to
    by STRING.

þreturnvalue

    _lltoa() and _ulltoa() return STRING.

þseealso atoi() _itoa() _strtoll() _strtoull()


þfunction localeconv()
þcompat C90
þheaders
#include <locale.h>
þendheaders

þprototype
struct lconv *localeconv (void);
þendprototype

    Return the address of a structure containing values for the
    formatting of umeric and monetary quantities according to the
    current locale.

    The structure is defined as follows:

þexample
struct lconv
{
  char *decimal_point;
  char *thousands_sep;
  char *grouping;
  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;
  char p_cs_precedes;
  char p_sep_by_space;
  char n_cs_precedes;
  char n_sep_by_space;
  char p_sign_posn;
  char n_sign_posn;
};
þendexample

    If a string member points to þtt{""}, the value is not available
    in the current locale or is of zero length.  Note that
    þtt{decimal_point} never points to þtt{""}.  The þtt{char} members
    are non-negative numbers.  CHAR_MAX indicates that the value is
    not available in the current locale.

    The members have the following meaning:

þlist
þitem þtt{decimal_point}

    The decimal point character used for formatting numbers (which are
    not monetary quantities).

þitem þtt{thousands_sep}

    The character used for separating groups of digits before the
    decimal point in numbers (which are not monetary quantities).

þitem þtt{grouping}

    An array containing the sizes of the groups of digits (right to
    left), terminated by zero (the previous size is to be used
    repeatedly for the remainder of the digits) or CHAR_MAX (no
    further grouping is to be performed).  This is used for numbers
    which are not monetary quantities.

þitem þtt{int_curr_symbol}

    The first three characters contain the international currency
    symbol, the fourth character (which is the last one) is the
    character used for separating the international currency symbol
    from the monetary quantity.

þitem þtt{currency_symbol}

    The local currency symbol.

þitem þtt{mon_decimal_point}

    The decimal point character used for formatting monetary
    quantities.

þitem þtt{mon_thousands_sep}

    The character used for separating groups of digits before the
    decimal point in monetary quantities.

þitem þtt{mon_grouping}

    An array containing the sizes of the groups of digits (right to
    left), terminated by zero (the previous size is to be used
    repeatedly for the remainder of the digits) or CHAR_MAX (no
    further grouping is to be performed).  This is used for monetary
    quantities.

þitem þtt{positive_sign}

    The string used for indicating that a monetary quantity is not
    negative (zero or positive).

þitem þtt{negative_sign}

    The string used for indicating that a monetary quantity is negative.

þitem þtt{int_frac_digits}

    The number of digits after the decimal point in monetary
    quantities (international format).

þitem þtt{frac_digits}

    The number of digits after the decimal point in monetary
    quantities (local format).

þitem þtt{p_cs_precedes}

    1 or 0 if þtt{currency_symbol} respectively precedes or succeeds
    the monetary quantity if it is not negative (zero or positive).

þitem þtt{p_sep_by_space}

    1 or 0 if a space respectively does or does not separate
    þtt{currency_symbol} from a non-negative (zero or positive)
    monetary quantity.

þitem þtt{n_cs_precedes}

    1 or 0 if þtt{currency_symbol} respectively precedes or succeeds
    the monetary quantity if it is negative.

þitem þtt{n_sep_by_space}

    1 or 0 if a space respectively does or does not separate
    þtt{currency_symbol} from a negative monetary quantity.

þitem þtt{p_sign_posn}

    A number indicating the position of þtt{positive_sign} for a
    non-negative (zero or positive) monetary quantity:

þdescription
þitem 0
    Parentheses surround the monetary quantity and þtt{currency_symbol}.
þitem 1
    The sign string precedes the quantity and þtt{currency_symbol}.
þitem 2
    The sign string succeeds the quantity and þtt{currency_symbol}.
þitem 3
    The sign string immediately precedes þtt{currency_symbol}.
þitem 4
    The sign string immediately succeeds þtt{currency_symbol}.
þenddescription

þitem þtt{n_sign_posn}

    A number indicating the position of þtt{positive_sign} for a
    negative monetary quantity.  See þtt{p_sign_posn} for a
    description of the values.

þendlist

þreturnvalue

    localeconv() returns a pointer to a statically allocated
    structure.  The contents of that structure can be changed by the
    next call to localeconv() or setlocale().  You must not write to
    the structure.

þrestrictions

    The contents of the structure are adjusted to use CHAR_MAX for the
    þtt{char} type of the module calling localeconv().  When mixing
    modules with different þtt{char} types, this will break.  When
    calling localeconv() in a library, CHAR_MAX of the library will be
    used instead of CHAR_MAX of the program using the library.

    When calling the function version of localeconv(), for instance by
    suppressing macro expansion, it is assumed that þtt{char} is
    signed.

þseealso setlocale()


þfunction localtime()
þcompat C90
þheaders
#include <time.h>
þendheaders

þparam T
þprototype
struct tm *localtime (const time_t *T);
þendprototype

    Convert the number of seconds elapsed since 00:00:00 1-Jan-1970
    Coordinated Universal Time (UTC, GMT) in the variable pointed to
    by T to a time and date structure for the local timezone and
    return a pointer to the structure.  gmtime(), mktime() and
    localtime() use the same memory location, therefore the values are
    overwritten if one of these functions is called.

þreturnvalue

    localtime() returns a pointer to a statically allocated
    structure.

þseealso asctime() ctime() gmtime() mktime() time()


þfunction log() log10() logl() log10l()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
double log (double X);
double log10 (double X);

long double logl (long double X);
long double log10l (long double X);
þendprototype

    log() returns the natural logarithm of X.  log10() returns the
    base-10 logarithm of X.

    If X is zero, -INF is returned and errno set to EDOM.
    If X is negative, a NaN is returned and errno set to EDOM.

    logl() and log10l() use the þtt{long double} format.

þreturnvalue

    See above.

þseealso exp() pow()


þfunction longjmp()
þcompat C90
þheaders
#include <setjmp.h>
þendheaders

þparam THERE N
þprototype
void longjmp (jmp_buf THERE, int N);
þendprototype

    Restore the context saved in THERE by setjmp().  longjmp() does a
    non-local þtt{goto}, causing execution to continue at the setjmp()
    call which most recently saved a stack context in THERE.  setjmp()
    will return N.  If N is 0, setjmp() will return 1.  When calling
    longjmp() in a signal handler or in a function called by a signal
    handler (that is, while a signal handler is active), the signal
    handler will be unwound, that is, it is assumed that the signal
    handler doesn't return.  longjmp() must be called in the same
    thread as the most recent call to setjmp() for THERE.  Moreover,
    the function which most recently called setjmp() to save a stack
    context in THERE must still be active.  Don't expect local
    variables to be preserved unless declared volatile.

    As jmp_buf is an array type, the þtt{&} operator need not be
    applied.

þseealso setjmp() sigaction() siglongjmp() sigsetjmp() signal()


þfunction _lrotl() _lrotr()
þcompat VAC++
þheaders
#include <sys/builtin.h>
þendheaders

þparam VALUE SHIFT
þprototype
unsigned long _lrotl (unsigned long VALUE, int SHIFT);
unsigned long _lrotr (unsigned long VALUE, int SHIFT);
þendprototype

    _lrotl() returns VALUE (32 bits) rotated left by SHIFT bits.  If
    SHIFT is 1, bit 30 is returned as bit 31, bit 29 is returned as
    bit 30, and so on, bit 0 is returned as bit 1, and bit 31 is
    returned as bit 0.

    _lrotr() returns VALUE (32 bits) rotated right by SHIFT bits.  If
    SHIFT is 1, bit 1 is returned as bit 0, bit 2 is returned as bit
    1, and so on, bit 31 is returned as bit 30, and bit 0 is returned
    as bit 31.

    SHIFT should be 0 through 31.

    These functions are implemented as inline functions.

þseealso _crotl() _crotr() _srotl() _srotr()


þfunction lseek()
þcompat UNIX
þheaders
#include <io.h>
þendheaders

þparam HANDLE OFFSET ORIGIN
þprototype
long lseek (int HANDLE, long OFFSET, int ORIGIN);
þendprototype

    lseek() moves the file pointer of HANDLE.  The new position OFFSET
    is relative to ORIGIN: If ORIGIN is SEEK_SET, OFFSET is relative
    to the beginning of the file, if ORIGIN is SEEK_CUR, OFFSET is
    relative to the current position, if ORIGIN is SEEK_END, OFFSET is
    relative to the end of the file.  The file pointer cannot be moved
    before the beginning of the file.  lseek() does not change the
    size of the file.

þreturnvalue

    lseek() returns the new position relative to the beginning of the
    file.  If there is an error, lseek() returns -1.

þrestrictions

    If the file pointer is set beyond the end of file, the data
    between the end of file and the new position is undefined (it
    should be read as zeros, but isn't).

    For text-mode files, OFFSET must be either zero (with ORIGIN equal
    to SEEK_SET, SEEK_CUR, or SEEK_END) or a value returned by a call
    to tell() on the same file (with ORIGIN equal to SEEK_SET).  For
    text-mode files ending with a Ctrl-Z, SEEK_END is not allowed.

þseealso chsize() filelength() tell()


þfunction main()
þcompat C90

þparam ARGC ARGV ENVP
þprototype
int main (void);
int main (int ARGC, char *ARGV[]);
int main (int ARGC, char *ARGV[], char *ENVP[]);
þendprototype

    This is the function called by the startup code to run your
    program.  It is not a library function.  ARGC is the number of
    command line arguments, including the program name.  ARGV points
    to an array of pointers to the command line arguments.  ENVP
    points to an array of pointers to the environment strings.  The
    last entry of each array is a NULL pointer.  main() should always
    return a value.  If main() returns, þhpt{exit()} is called using
    the return value of main() as argument.  If main() ends without
    þtt{return} statement and without calling exit(), the return code
    of the program is undefined.  This should be avoided.  After
    changing the environment with þhpt{putenv()}, you should use the
    þhpt{environ} global variable instead of the ENVP argument of
    main().

þreturnvalue

    The return value of main() will be the return code of the process.

þseealso _envargs() environ _execname() exit() putenv() _response() _wildcard()


þfunction _makepath()
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þparam DST DRIVE DIR FNAME EXT
þprototype
void _makepath (char *DST, const char *DRIVE, const char *DIR,
                const char *FNAME, const char *EXT);
þendprototype

    Build a path name from components and store it to the array
    pointed to by DST.  The array at DST should be of size _MAX_PATH.
    If DRIVE is not NULL and does not point to the empty string, the
    first character of the string (a drive name) pointed to by DRIVE
    followed by a colon is stored to the array pointed to by DST.  If
    DIR is not NULL and does not point to the empty string, the string
    (a directory name) pointed to by DIR is copied to DST.  If it does
    not end with \ or /, _makepath() appends a / character (or a \
    character if the string pointed to by DIR contains at least one
    backslash).  If FNAME is not NULL, the string pointed to by FNAME
    (a filename) is copied to DST.  If EXT is not NULL and does not
    point to the empty string, the string pointed to by EXT (an
    extension) is copied to DST.  If the string pointed to by EXT does
    not start with a þtt{.}  character, _makepath() inserts a þtt{.}
    in front of the string pointed to by EXT.  If the length of the
    resulting string (including the terminating null character)
    exceeds _MAX_PATH, the string is truncated to _MAX_PATH characters
    (including the terminating null character).

    _makepath() properly handles DBCS characters.

þseealso _nls_init() _splitpath()

þsamplecode
char drive[_MAX_DRIVE], dir[_MAX_DIR];
char tmp[_MAX_PATH];
_splitpath (path, drive, dir, NULL, NULL);
_makepath (tmp, drive, dir, "tmpfile", "$$$");
þendsamplecode


þfunction malloc()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam SIZE
þprototype
void *malloc (size_t SIZE);
þendprototype

    Allocate a block of memory big enough for holding SIZE bytes.  If
    there is an error, malloc() returns NULL.  If SIZE is 0, zero
    bytes of memory are allocated, the return value will be unequal
    NULL.

þreturnvalue

    malloc() returns a pointer to a newly allocated block of memory.
    On error, malloc() returns NULL.

þimplementation

    malloc() allocates from the default heap of the current thread.
    þtt{malloc(0)} returns a non-NULL pointer if there's enough space
    left in the heap for a block of the minimum size.

þrestrictions

    It's possible to replace the emx C library's malloc()
    implementation; for instance, you can use GNU malloc.  However, do
    not replace malloc() etc. when dynamically linking to the C
    runtime library as the functions in the DLL won't call your
    replacements.

þseealso calloc() free() _msize() realloc() _tmalloc() _udefault() _umalloc()


þfunction matherr()
þcompat SysV
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
int matherr (struct exception *X);
þendprototype

    Exception handler for floating point math.

þreturnvalue
þdescription
þitem 0
    success
þitem non-0
    error
þenddescription

þrestrictions

    matherr() is not implemented.

þseealso sigaction() signal()


þfunction mblen()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam S N
þprototype
int mblen (const char *S, size_t N);
þendprototype

    Compute the number of bytes comprising the multibyte character
    pointed to by S.  If S is NULL, the shift state is reset to the
    initial state.  At most N bytes at S are examined; a multibyte
    character consisting of more than N bytes is deemed invalid.

    Except for the different shift states, this is equivalent to

þtypewriter
  mbtowc (NULL, þpa{S}, þpa{N})
þendtypewriter

    The shift state of mbtowc() is not affected.

    In programs linked with the multithread libraries, each thread has
    its own shift state for mblen().

þreturnvalue

    If S is NULL, mblen() returns a non-zero value (if state-dependent
    encoding is used) or a zero value (if state-dependent encoding is
    not used).  If S is not NULL, mblen() returns 0 (if S points to
    the null character), the number of bytes comprising the multibyte
    character pointed to by S (if there is a valid multibyte
    character), or -1 (if there is not a valid multibyte character).

þseealso mbtowc() setlocale()


þfunction mbstowcs()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam PWCS S N
þprototype
size_t mbstowcs (wchar_t *PWCS, const char *S, size_t N);
þendprototype

    Convert the null-terminated sequence of multibyte character
    pointed to by S to a sequence of wchar_t codes pointed to by PWCS.
    The multibyte character sequence starts in the initial shift
    state.  At most N codes are stored to PWCS.  PWCS will be
    terminated with a code of value zero if N is big enough.

    The shift state of mbtowc() and mblen() is not affected.

þreturnvalue

    mbstowcs() returns the number of codes stored to PWCS (excluding
    the terminating zero code) or þtt{(size_t)-1} if an invalid
    multibyte character is encountered.

þseealso mblen() mbtowc() setlocale() wcstombs()


þfunction mbtowc()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam PWC S N
þprototype
int mbtowc (wchar_t *PWC, const char *S, size_t N);
þendprototype

    Convert the multibyte character pointed to by S to a wchar_t code
    and store it to PWC.  If S is NULL, the shift state is reset to
    the initial state.  At most N bytes at S are examined; a multibyte
    character consisting of more than N bytes is deemed invalid.

    The shift state of mblen() is not affected.

    In programs linked with the multithread libraries, each thread has
    its own shift state for mbtowc().

þreturnvalue

    If S is NULL, mbtowc() returns a non-zero value (if state-dependent
    encoding is used) or a zero value (if state-dependent encoding is
    not used).  If S is not NULL, mbtowc() returns 0 (if S points to
    the null character), the number of bytes comprising the multibyte
    character pointed to by S (if there is a valid multibyte
    character), or -1 (if there is not a valid multibyte character).

þseealso mblen() mbstowcs() setlocale() wctomb()


þfunction _md_close()
þcompat emx
þheaders
#include <stdio.h>
#include <sys/moddef.h>
þendheaders

þparam MD
þprototype
int _md_close (struct _md *MD);
þendprototype

  Destroy the descriptor MD.  MD must have been returned by _md_open()
  or _md_use_file().  If MD has been returned by _md_open(), the file
  will be closed.  If MD has been returned by _md_use_file(), the file
  won't be closed.  _md_close() frees the memory associated with MD.
  Do not use MD after calling _md_close().

  You have to link with the moddef library (use the -lmoddef option).

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso _md_open() _md_use_file()


þfunction _md_errmsg()
þcompat emx
þheaders
#include <stdio.h>
#include <sys/moddef.h>
þendheaders

þparam CODE
þprototype
const char *_md_errmsg (_md_error CODE);
þendprototype

  Return a pointer to the default error message for the error code
  CODE.  This function can be used in the callback function of
  _md_parse().

  You have to link with the moddef library (use the -lmoddef option).

þseealso _md_parse()


þfunction _md_get_linenumber() _md_get_number() _md_get_string() _md_get_token()
þcompat emx
þheaders
#include <stdio.h>
#include <sys/moddef.h>
þendheaders

þparam MD
þprototype
_md_token _md_get_token (struct _md *MD);
long _md_get_number (const struct _md *MD);
const char *_md_get_string (const struct _md *MD);
long _md_get_linenumber (const struct _md *MD);
þendprototype

  Retrieve information about the current token of MD (the token most
  recently read by þtt{_md_next_token (md)}).

  _md_get_token() returns the token identifier (see
  þhpt{_md_next_token()} for details).  If _md_get_token() has not
  been called for MD, _MD_eof is returned.

  If the current token is a number, _md_get_number() returns the value
  of the number.  Otherwise, _md_get_number() returns 0.

  _md_get_string() returns the string value of the current token.  The
  string value consists of all the characters that are part of the
  token.

  _md_get_linenumber() returns the number of the line from
  which the token has been read.  The first line is numbered 1.

  You have to link with the moddef library (use the -lmoddef option).

þseealso _md_next_token()


þfunction _md_next_token()
þcompat emx
þheaders
#include <stdio.h>
#include <sys/moddef.h>
þendheaders

þparam MD
þprototype
_md_token _md_next_token (struct _md *MD);
þendprototype

  Read the next token from the module definition file MD and return
  the token identifier.  See <sys/moddef.h> for token identifiers.  Most
  token identifiers identify a keyword.  For instance, _MD_NAME
  is returned for the NAME keyword.  The following special token
  identfiers are defined:

þlist
þitem _MD_dot

  The character `þtt{.}'.

þitem _MD_at

  The character `þtt{@}'.

þitem _MD_equal

  The character `þtt{=}'.

þitem _MD_number

  A number.  Use _md_get_number() to retrieve the value.

þitem _MD_word

  A word which isn't a keyword.  Use _md_get_string() to retrieve the
  value.

þitem _MD_quote

  A quoted string. _md_get_string() to retrieve the value.

þitem _MD_eof

  The end of the file has been reached.

þitem _MD_ioerror

  An I/O error occured while reading from the file (fatal error).

þitem _MD_missingquote

  A quote character is missing (fatal error).  Quote characters must
  come in pairs.

þendlist

  After calling _md_next_token(), you can retrieve the token
  identifier, numeric value, string value and line number of the
  current token by calling _md_get_token(), _md_get_number(),
  _md_get_string() and _md_get_linenumber(), respectively.

  You have to link with the moddef library (use the -lmoddef option).

þseealso _md_get_linenumber() _md_get_number() _md_get_string() _md_get_token() _md_open() _md_parse() _md_use_file()


þfunction _md_open()
þcompat emx
þheaders
#include <stdio.h>
#include <sys/moddef.h>
þendheaders

þparam FNAME
þprototype
struct _md *_md_open (const char *FNAME);
þendprototype

  Create a descriptor for reading module definition statements from
  the file whose name is in the string pointed to by FNAME.  The file
  is opened in SH_DENYWR mode.  On error (file cannot be opened or out
  of memory), _md_open() sets errno and returns NULL.  Otherwise, a
  descriptor is returned which can be passed to _md_next_token() or
  _md_parse() to parse the file.  Call _md_close() to close the file
  and to destroy the descriptor.

  You have to link with the moddef library (use the -lmoddef option).

þseealso _md_next_token() _md_parse() _md_use_file()


þfunction _md_parse()
þcompat emx
þheaders
#include <stdio.h>
#include <sys/moddef.h>
þendheaders

þparam MD CALLBACK ARG STMT TOKEN
þprototype
int _md_parse (struct _md *MD,
               int (*CALLBACK)(struct _md *MD, const _md_stmt *STMT,
                               _md_token TOKEN, void *ARG),
               void *ARG);
þendprototype

  Parse the module definition file MD, calling CALLBACK for each
  statement.  The token identifier of the statement is passed in TOKEN
  to CALLBACK.  Information about the statement is passed in STMT.
  Moreover, CALLBACK receives þtt{_md_parse()}'s MD and ARG arguments.
  ARG can be used to pass additional user data to CALLBACK.

  CALLBACK is also called if an error is encountered.  In that case,
  TOKEN has the special value _MD_parseerror.

  _md_parse() starts parsing at the current token, that is,
  _md_next_token() has to be called before invoking _md_parse().
  _md_parse() stops parsing when reaching the end of the file or when
  CALLBACK returns a non-zero value.  In the latter case, _md_parse()
  returns the value returned by CALLBACK.  In all other cases,
  _md_parse() returns 0.

  The following values of TOKEN can be passed to CALLBACK:

þlist

þitem _MD_BASE

  BASE statement.  The base address is available in STMTþtt{->base.addr}.

þitem _MD_CODE

  CODE statement.  The segment attributes are available in
  STMTþtt{->segment.attr}, using a combination of constants like
  _MDS_IOPL.

þitem _MD_DATA

  DATA statement.  The segment attributes are available in
  STMTþtt{->segment.attr}, using a combination of constants like
  _MDS_MULTIPLE.

þitem _MD_DESCRIPTION

  DESCRIPTION statement.  The description string is available in
  STMTþtt{->descr.string}.

þitem _MD_EXETYPE

  EXETYPE statement.  The executable type is available in
  STMTþtt{->exetype.type} using a constant like _MDX_OS2.  For
  _MDX_WINDOWS, the minor and major version numbers are available in
  STMTþtt{->exetype.minor_version} and STMTþtt{->exetype.major_version},
  respectively.  If the version numbers are not specified or if the
  executable type is not WINDOWS, these fields are 0.

þitem _MD_EXPORTS

  One export entry of an EXPORTS statement.  Information about the
  export entry is available in STMTþtt{->export}:

þlist
þitem þtt{flags}

  If an ordinal number is present, _MDEP_ORDINAL is set.  If the
  NONAME keyword is present, _MDEP_NONAME is set.  If the RESIDENTNAME
  keyword is present, _MDEP_RESIDENTNAME is set.  If the NODATA
  keyword is present, _MDEP_NODATA is set.  If the number of parameter
  words is present, _MDEP_PWORDS is set.

þitem þtt{internalname}

  The internal name of the entry point.  If no internal name is
  specified, the string is empty.

þitem þtt{entryname}

  The external name of the entry point.

þitem þtt{ordinal}

  The ordinal number, if þtt{flags} contains _MDEP_ORDINAL.
  Otherwise, this field is 0.

þitem þtt{pwords}

  The number of parameter words, if þtt{flags} contains _MDEP_PWORDS.
  Otherwise, this field is 0.

þendlist

þitem _MD_HEAPSIZE

  HEAPSIZE statement.  If a heap size is specified, the heap size is
  available in STMTþtt{->heapsize.size} and STMTþtt{->heapsize.maxval}
  is 0.  If MAXVAL is specified, STMTþtt{->heapsize.maxval} is
  non-zero and STMTþtt{->heapsize.size} is 0.

þitem _MD_IMPORTS

  One import entry of an IMPORTS statement.  Information about the
  import entry is available in STMTþtt{->import}:

þlist

þitem þtt{flags}

  If an ordinal number is present, _MDIP_ORDINAL is set.

þitem þtt{internalname}

  The internal name of the entry point.  If no internal name is
  specified, the string is empty.

þitem þtt{entryname}

  The external name of the entry point.  If no external name is
  specified (that is, if _MDIP_ORDINAL is set), the string is empty.

þitem þtt{modulename}

  The name of the dynamic link library.

þitem þtt{ordinal}

  The ordinal number, if þtt{flags} contains _MDIP_ORDINAL.
  Otherwise, this field is 0.

þendlist

þitem _MD_LIBRARY

  LIBRARY statement.  The name is available in
  STMTþtt{->library.name}.  The library initialization and termination
  modes are available in STMTþtt{->library.init} and
  STMTþtt{->library.term}, respectively.  These fields are set to
  _MDIT_DEFAULT if no modes are specified.  Otherwise, _MDIT_INSTANCE
  or _MDIT_GLOBAL is used.

þitem _MD_NAME

  NAME statement.  The name is available in STMTþtt{->name.name}.  The
  application type is available in STMTþtt{->name.pmtype}.  That field
  is set to _MDT_DEFAULT (if no type is specified), _MDT_WINDOWAPI,
  _MDT_WINDOWCOMPAT or _MDT_NOTWINDOWCOMPAT.  If NEWFILES is
  specified, the STMTþtt{->name.newfiles} field is non-zero.

þitem _MD_OLD

  OLD statement.  The file name is available in
  STMTþtt{->old.name}.
  
þitem _MD_PHYSICAL

  PHYSICAL DEVICE statement.  The name is available in
  STMTþtt{->device.name}.

þitem _MD_PROTMODE

  PROTMODE statement.  No additional information is available.

þitem _MD_REALMODE

  REALMODE statement.  No additional information is available.

þitem _MD_SEGMENTS

  One segment definition of a SEGMENTS statement.  The segment
  attributes are available in STMTþtt{->segment.attr}, using a
  combination of constants like _MDS_SHARED.  The segment name is
  available in STMTþtt{->segment.segname}.  The class name is
  available in STMTþtt{->segment.classname}.  If no class name is
  specified, that string is empty.

þitem _MD_STACKSIZE

  STACKSIZE statement.  The stack size is available in
  STMTþtt{->stacksize.size}.

þitem _MD_STUB

  STUB statement.  The file name is available in STMTþtt{->stub.name}.
  If the NONE keyword is used, STMTþtt{->stub.none} is none-zero and
  the string is empty.

þitem _MD_VIRTUAL

  VIRTUAL DEVICE statement.  The name is available in
  STMTþtt{->device.name}.

þitem _MD_parseerror

  _md_parse() has detected an error.  The token identifier of the
  current statement is available in STMTþtt{->error.stmt}.  An error
  code is available in STMTþtt{->error.code}.  The following error
  codes are defined:

þlist
þitem _MDE_IO_ERROR

  _md_next_token() returned _MD_ioerror because an I/O error
  occured while reading from the file.

þitem _MDE_MISSING_QUOTE

  _md_next_token() returned _MD_missingquote because a quote
  character is missing.  Quote characters must come in pairs.

þitem _MDE_EMPTY

  The module definition file is empty, there are no statements.  This
  error also occurs if _md_next_token() wasn't called before
  calling _md_parse().

þitem _MDE_NAME_EXPECTED

  A name (segment name, class name, entry name) was expected, but a
  different token was read.

þitem _MDE_STRING_EXPECTED

  A quoted string was expected, but a different token was read.

þitem _MDE_NUMBER_EXPECTED

  A number was expected, but a different token was read.

þitem _MDE_DEVICE_EXPECTED

  The VIRTUAL or PHYSICAL keyword isn't followed by the DEVICE
  keyword.

þitem _MDE_EQUAL_EXPECTED

  An `þtt{=}' character was expected, but a different token was read.

þitem _MDE_DOT_EXPECTED

  A `þtt{.}' character was expected, but a different token was read.

þitem _MDE_STRING_TOO_LONG

  A string is too long.

þitem _MDE_INVALID_ORDINAL

  An ordinal number is invalid.  Valid ordinal numbers are in 1
  through 65535.

þitem _MDE_INVALID_STMT

  An invalid keyword (which doesn't start a statement) was read.

þendlist

  You can use þhpt{_md_errmsg()} to get a default error message for
  the error code.

  If CALLBACK returns 0, _md_parse() skips tokens until finding a
  keyword which starts a statement or until hitting end of file.  If
  CALLBACK returns a non-zero number, that number will be immediately
  returned by _md_parse().

þendlist

  You have to link with the moddef library (use the -lmoddef option).

þseealso _md_errmsg() _md_next_token() _md_open() _md_use_file()

þsamplefile /emx/test/mdecho.c


þfunction _md_use_file()
þcompat emx
þheaders
#include <stdio.h>
#include <sys/moddef.h>
þendheaders

þparam F
þprototype
struct _md *_md_use_file (FILE *F);
þendprototype

  Create a descriptor for reading module definition statements from
  the file F.  On error (out of memory), _md_use_file() sets errno and
  returns NULL.  Otherwise, a descriptor is returned which can be
  passed to _md_next_token() or _md_parse() to parse the file.  Don't
  close F before calling _md_close().  Call _md_close() to destroy the
  descriptor.

  You have to link with the moddef library (use the -lmoddef option).

þseealso _md_close() _md_next_token() _md_open()


þfunction _memaccess()
þcompat emx
þheaders
#include <sys/hw.h>
þendheaders

þparam FIRST LAST FLAG
þprototype
void *_memaccess (unsigned FIRST, unsigned LAST, int FLAG);
þendprototype

    Gain access to physical memory under DOS.  To access memory which
    is outside the memory space of the current process, you have to
    call _memaccess().  emx option -am must be used to enable
    _memaccess(), see `þhpt{Using emx options}'.

    FIRST is the address of the first byte of the physical memory
    area, LAST is the address of the last byte of the physical memory
    area to be accessed.  Both addresses are physical addresses.
    FIRST and þpa{LAST}+1 must be page aligned: FIRST and þpa{LAST}+1
    must be integral multiples of 4096.  That is, with using
    hexadecimal notation, FIRST must end with 000, LAST must end with
    fff.  If FLAG is 0, read access is granted.  If FLAG is 1, read
    and write access is granted.  Write access can be granted if the
    address range of the physical memory area is entirely in the range
    0xa0000 to 0xbffff.  If bytes outside this range are included in
    FIRST to LAST, emx option -aw must be used to enable write access,
    see `þhpt{Using emx options}'.

þreturnvalue

    _memaccess() returns a pointer to virtual memory mapped to the
    physical memory area.  On failure, _memaccess() sets errno and
    returns NULL.

þerrors

þdescription
þitem EACCES

    FIRST not page aligned; þpa{LAST}+1 not page aligned; LAST not
    greater than FIRST; write access not allowed

þitem EINVAL

    FLAG is not 0 or 1

þitem ENOMEM

    not enough virtual memory for storing the paging tables; linear
    address space of process not big enough for the request

þenddescription

þrestrictions

    _memaccess() is not available under OS/2.  Obtaining access to
    memory by linear address is not yet supported.

þseealso _portaccess()

þsamplefile /emx/test/hw_mem.c


þfunction memccpy()
þcompat PC
þheaders
#include <string.h>     /* use this */
#include <memory.h>     /* or this */
þendheaders

þparam S1 S2 C N
þprototype
void *memccpy (void *S1, const void *S2, int C, size_t N);
þendprototype

    Copy at most the first N bytes from S2 to S1, stopping after
    copying a byte equal to the lower 8 bits C.  If memccpy() stops
    because a byte equal to C has been found, a pointer to the byte
    after the last destination byte (which is equal to C) is returned.
    If N bytes have been copied without finding a byte equal to C,
    NULL is returned.

þreturnvalue

    See above.

þseealso memchr() memcpy() memmove() strcpy() strncpy()


þfunction memchr()
þcompat C90
þheaders
#include <string.h>     /* use this */
#include <memory.h>     /* or this */
þendheaders

þparam S C N
þprototype
void *memchr (const void *S, int C, size_t N);
þendprototype

    Search the first N bytes at S for a byte equal to the lower 8 bits
    of C.  If a byte equal to C is found, a pointer to the first
    occurrence of C is returned.  If there is no such byte, NULL is
    returned.

þreturnvalue

    See above.

þseealso _memrchr() strchr()


þfunction memcmp()
þcompat C90

þheaders
#include <string.h>     /* use this */
#include <memory.h>     /* or this */
þendheaders

þparam S1 S2 N
þprototype
int memcmp (const void *S1, const void *S2, size_t N);
þendprototype

    Compare the first N bytes at S1 to the first N bytes at S2.  If
    the two buffers are identical (or if N is zero), 0 is returned.
    Otherwise, a value is returned which indicates the relationship of
    the first differing byte: a negative value means buffer S1 is
    lexically less than buffer S2, a positive value means buffer S1 is
    lexically greater than buffer S2.

þreturnvalue
þdescription
þitem <0
   S1 < S2
þitem =0
   S1 = S2
þitem >0
   S1 > S2
þenddescription

þseealso bcmp() _memdif() memicmp()


þfunction _memcount()
þcompat emx

þheaders
#include <string.h>     /* use this */
#include <memory.h>     /* or this */
þendheaders

þparam MEM C N
þprototype
size_t _memcount (const void *MEM, int C, size_t N);
þendprototype

    Count and return the number of occurrences of character C in the
    memory area of size N bytes pointed to by MEM.

þreturnvalue

    See above.


þfunction memcpy()
þcompat C90

þheaders
#include <string.h>     /* use this */
#include <memory.h>     /* or this */
þendheaders

þparam S1 S2 N
þprototype
void *memcpy (void *S1, const void *S2, size_t N);
þendprototype

    Copy memory.  Copy N bytes from S2 to S1.  The two regions must
    not overlap.  GCC generates in-line code for special applications
    of memcpy().  Use memmove() instead of memcpy() to copy
    overlapping regions of memory.

þreturnvalue

    memcpy() returns S1.

þseealso bcopy() memmove()


þfunction _memdif()
þcompat emx

þheaders
#include <string.h>     /* use this */
#include <memory.h>     /* or this */
þendheaders

þparam MEM1 MEM2 N
þprototype
size_t _memdif (const void *MEM1, const void *MEM2, size_t N);
þendprototype

    Compare the first N bytes pointed to by MEM1 to the first N bytes
    pointed to by MEM2.  If the two buffers are identical (or if N is
    zero), _MEMDIF_EQ is returned.  Otherwise, the byte offset of the
    first difference is returned.

þreturnvalue

    See above.

þseealso memcmp()


þfunction memicmp()
þcompat PC

þheaders
#include <string.h>     /* use this */
#include <memory.h>     /* or this */
þendheaders

þparam S1 S2 N
þprototype
int memicmp (const void *S1, const void *S2, size_t N);
þendprototype

    Compare the first N bytes at S1 to the first N bytes at S2,
    ignoring letter case.  If the two buffers are identical (or if N
    is zero), 0 is returned.  Otherwise, a value is returned which
    indicates the relationship of the first differing byte: a negative
    value means buffer S1 is lexically less than buffer S2 (after
    conversion to lower case), a positive value means buffer S1 is
    lexically greater than buffer S2 (after conversion to lower case).

þreturnvalue
þdescription
þitem <0
   S1 < S2
þitem =0
   S1 = S2
þitem >0
   S1 > S2
þenddescription

þseealso memcmp() tolower()


þfunction memmove()
þcompat C90

þheaders
#include <string.h>     /* use this */
#include <memory.h>     /* or this */
þendheaders

þparam S1 S2 N
þprototype
void *memmove (void *S1, const void *S2, size_t N);
þendprototype

    Copy memory.  Copy N bytes from S2 to S1.  The two regions may
    overlap.

þreturnvalue

    memmove() returns S1.

þseealso bcopy() memcpy()


þfunction _memrchr()
þcompat emx
þheaders
#include <string.h>     /* use this */
#include <memory.h>     /* or this */
þendheaders

þparam S C N
þprototype
void *_memrchr (const void *S, int C, size_t N);
þendprototype

    Search the first N bytes at S for a byte equal to the lower 8 bits
    of C.  If a byte equal to C is found, a pointer to the last
    occurrence of C is returned.  If there is no such byte, NULL is
    returned.

þreturnvalue

    See above.

þseealso memchr() strrchr()


þfunction memset()
þcompat C90

þheaders
#include <string.h>     /* use this */
#include <memory.h>     /* or this */
þendheaders

þparam S C N
þprototype
void *memset (void *S, int C, size_t N);
þendprototype

    Fill memory.  Set N bytes at S to C.

þreturnvalue

    memset() returns S.

þseealso bzero()


þfunction _memswap()
þcompat emx

þheaders
#include <string.h>     /* use this */
#include <memory.h>     /* or this */
þendheaders

þparam S1 S2 N
þprototype
void _memswap (void *S1, void *S2, size_t N);
þendprototype

    Swap two areas of memory of N bytes each, pointed to by S1 and S2.
    The two areas must not overlap.


þfunction _mfclose()
þcompat emx
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
char *_mfclose (FILE *STREAM);
þendprototype

    Close a memory file.  A pointer to the buffer is returned.  On
    error, NULL is returned.  Use ftell() before calling _mfclose() to
    get the number of characters in the buffer.  If the þpa{BUF}
    argument of _mfopen() was NULL, use free() to deallocate the
    buffer.

þreturnvalue

    See above.

þseealso _mfopen()


þfunction _mfopen()
þcompat emx
þheaders
#include <stdio.h>
þendheaders

þparam BUF MODE SIZE INC
þprototype
FILE *_mfopen (char *BUF, const char *MODE, size_t SIZE, int INC);
þendprototype

    Open a memory file.  All output to a memory file goes to a buffer
    in memory.  The stream returned by _mfopen() can be used with
    fprintf(), fputc(), ftell() and fwrite().  If BUF is
    non-þtt{NULL}, output goes to the array of SIZE bytes pointed to
    by BUF.  INC must be zero.  If BUF is NULL, output goes to a
    buffer allocated with malloc() and resized with realloc().  The
    initial size of the buffer is SIZE bytes (which can be zero).  INC
    must be non-zero.  If INC is positive, the buffer size is
    increased by INC bytes whenever it is full.  If INC is -2, the
    buffer size is doubled whenever the buffer is full.  If SIZE
    is 0 and INC is -2, the initial buffer size is 512 bytes, the
    buffer will be allocated on the first output to the stream.
    Currently, MODE must point to þtt{"wb"}.  On error, _mfopen()
    returns NULL.  Do not use fclose() on a stream created by
    _mfopen(), use _mfclose() instead.  Do not read from a stream
    created by _mfopen().

þreturnvalue

    _mfopen() returns a new stream.  On error, _mfopen() returns NULL.

þrestrictions

    _fsetmode() doesn't work, newline characters written to the
    stream are not expanded to CR/LF.

þseealso _fassign() fopen() _mfclose() sprintf()

þsamplefile /emx/test/mftest.c


þfunction _mheap()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam MEM
þprototype
Heap_t _mheap (const void *MEM);
þendprototype

    Return a pointer to the heap in which the memory block MEM has
    been allocated.  MEM must be the pointer obtained by calling
    calloc(), malloc(), realloc(), _tcalloc(), _tmalloc(),
    _trealloc(), _ucalloc(), _umalloc(), _utcalloc(), or _utmalloc().
    _mheap() returns NULL if MEM is NULL.  The return value of
    _mheap() is undefined if MEM points to a memory block which has
    been freed.  _mheap() may crash if MEM does not point to a memory
    block allocated by one of the functions listed above.

þreturnvalue

    _mheap() returns a pointer to the heap in which the memory block
    MEM has been allocated. _mheap() returns NULL if MEM is NULL.

þseealso malloc() _msize() _ucreate() _ucreate2() _udefault() _umalloc()


þfunction mkdir()
þcompat BSD
þheaders
#include <stdlib.h>
þendheaders

þparam NAME MODE
þprototype
int mkdir (const char *NAME, long MODE);
þendprototype

    Create a directory whose name is in the string pointed to by NAME.
    Only one directory can be created in one step, therefore all but
    the last component of the string pointed to by NAME must exist.
    MODE (containing the permission bits) is ignored.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso chdir() rmdir()


þfunction mkstemp()
þcompat BSD
þheaders
#include <unistd.h>
þendheaders

þparam STRING
þprototype
int mkstemp (char *STRING);
þendprototype

    Create a unique file name by modifying the string pointed to by
    STRING and open a file descriptor for that file using O_RDWR mode.
    Trailing þtt{X} characters of the string pointed to by STRING are
    replaced by a letter followed by digits (the process ID).  There
    should be 6 trailing þtt{X} characters.  Only 26 different file
    names per process can be created.

þreturnvalue

    On success, mkstemp() returns a file descriptor.  On failure,
    mkstemp() sets errno and returns -1.

þhints

    Note that the string pointed to by STRING will be modified; do not
    use a string constant!

    mkstemp() opens the file in text mode; use setmode() to switch the
    file descriptor to binary mode.

    mkstemp() avoids the race condition of mktemp(), however it is
    less portable than mktemp().

þseealso mktemp() setmode() tmpfile()


þfunction mktemp()
þcompat UNIX
þheaders
#include <unistd.h>
þendheaders

þparam STRING
þprototype
char *mktemp (char *STRING);
þendprototype

    Create a unique file name by modifying the string pointed to by
    STRING.  Trailing þtt{X} characters of the string pointed to by
    STRING are replaced by a letter followed by digits (the process
    ID).  There should be 6 trailing þtt{X} characters.  Only 26
    different file names per process can be created.

þreturnvalue

    On success, mktemp() returns STRING.  On failure, mktemp() returns
    NULL.

þhints

    Note that the string pointed to by STRING will be modified; do not
    use a string constant!

    Note that mktemp() is subject to a race condition: other threads
    of the same process may use the same temporary file name before
    you have a chance to create the temporary file.

þseealso mkstemp() tempnam() tmpfile() tmpnam()

þsamplecode
char tmp[20];

strcpy (tmp, "exXXXXXX");
if (mktemp (tmp) != NULL)
  {
    /* ... */
  }
þendsamplecode


þfunction mktime()
þcompat C90
þheaders
#include <time.h>
þendheaders

þparam T
þprototype
time_t mktime (struct tm *T);
þendprototype

    Compute the number of seconds elapsed between 00:00:00 1-Jan-1970
    Coordinated Universal Time (UTC, GMT) and the time in the
    structure pointed to by T, interpreted as local time.  The tm_wday
    and tm_yday members of the structure are ignored.  The members of
    the structure are allowed to be out of range; mktime() modifies
    the structure to force the values to the usual ranges.  The
    tm_mday member is not set until the tm_mon and tm_year members
    have been adjusted.  The time in the structure is assumed to
    initially represent standard time if tm_isdst is zero.  The time
    in the structure is assumed to initially represent daylight saving
    time if tm_isdst is positive.  If tm_isdst is negative, mktime()
    determines whether daylight saving time is in effect for the
    specified time.  mktime() sets the tm_wday, tm_yday, and tm_isdst
    members of the structure as appropriate.

    See þhpt{tzset()} for a description of the TZ environment
    variable.

þreturnvalue

    mktime() returns the number of seconds elapsed between 00:00:00
    1-Jan-1970 UTC and the time in the structure pointed to by T.  If
    the time cannot be represented, mktime() returns -1 cast as
    time_t.

þimplementation

    If tm_isdst is negative and the specified time is in the time gap
    between standard time and daylight saving time, mktime() assumes
    that daylight saving time is not in effect for the specified time.

þseealso gmtime() localtime() tzset()


þfunction modf() modfl()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X INT_PTR
þprototype
double modf (double X, double *INT_PTR);
long double modfl (long double X, long double *INT_PTR);
þendprototype

    Split X into fractional part (which is returned) and integer part
    (which is stored to þtt{*}þpa{INT_PTR}).  Both the fractional and
    the integer part have the same sign as X.

    modfl() uses the þtt{long double} format.

þreturnvalue

    modf() returns the fractional part of X.

þseealso ceil() floor() frexp() rint() trunc()


þfunction _msize()
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þparam MEM
þprototype
size_t _msize (const void *MEM);
þendprototype

    Return the size of the memory block MEM which has been allocated
    by one of the C library's memory allocation functions.  MEM must
    be the pointer obtained by calling calloc(), malloc(), realloc(),
    _tcalloc(), _tmalloc(), _trealloc(), _ucalloc(), _umalloc(),
    _utcalloc(), or _utmalloc().  _msize() returns zero if MEM is
    NULL.  The return value of _msize() is undefined if MEM points to
    a memory block which has been freed.

þreturnvalue

    _msize() returns the number of bytes allocated to MEM or zero if
    MEM is NULL.

þseealso _expand() malloc() _mheap() _umalloc()


þfunction nextafter() nextafterf() nextafterl()
þcompat C9X
þheaders
#include <math.h>
þendheaders

þparam X Y
þprototype
double nextafter (double X, double Y);
float nextafterf (float X, float Y);
long double nextafterl (long double X, long double Y);
þendprototype

    Return the next representable value after X, in the type of the
    function, in the direction of Y.

þreturnvalue

    Return Y if Xþtt{==}Y is true.  If both X and Y are NaNs, return
    one of them.  If X or Y is a NaN, return that NaN.  If Y is
    greater than X, return the smallest value in the type of the
    function that is greater than X.  If Y is smaller than X, return
    the greatest value in the type of the function that is smaller
    than X.

þseealso copysign() fpclassify()


þfunction _nls_init()
þcompat emx
þheaders
#include <sys/nls.h>
þendheaders

þprototype
void _nls_init (void);
þendprototype

    Initialize the global variables _nls_tolower_tab,
    _nls_toupper_tab, and _nls_ctype_tab, which are used by
    _nls_tolower(), _nls_toupper(), _nls_strlwr(), _nls_strupr(), and
    _nls_is_dbcs_lead().  The tables are initialized appropriately for
    the current country code and code page.  _nls_init() is
    automatically called by the startup code, therefore you don't have
    to call _nls_init() unless you change the country code or the code
    page: _nls_init() should be called after changing the country code
    or code page.

þseealso _defext() _fncmp() _getext() _getname() _nls_is_dbcs_lead() _nls_strlwr() _nls_tolower() _remext() _splitpath()


þfunction _nls_is_dbcs_lead()
þcompat emx
þheaders
#include <sys/nls.h>
þendheaders

þparam C
þprototype
int _nls_is_dbcs_lead (int C);
þendprototype

    This macro evaluates to a non-zero value if C is the lead byte of
    a DBCS character.  C must be an integer which is representable as
    þtt{unsigned char} (that is, 0 through 255).  Note that C must not
    be EOF.

þreturnvalue

    _nls_is_dbcs_lead() returns zero if its argument is not a DBCS
    lead byte.  _nls_is_dbcs_lead() returns a non-zero value if its
    argument is a DBCS lead byte.

þseealso _nls_init() _nls_strlwr() _nls_strupr()


þfunction _nls_strlwr() _nls_strupr()
þcompat emx
þheaders
#include <sys/nls.h>
þendheaders

þparam STRING
þprototype
unsigned char *_nls_strlwr (unsigned char *STRING);
unsigned char *_nls_strupr (unsigned char *STRING);
þendprototype

    These functions convert all the characters of the string pointed
    to by STRING to lower case or upper case, respectively.  Accented
    characters etc.  are converted as well, DBCS characters are not
    changed.

þreturnvalue

    _nls_strlwr() and _nls_strupr() return STRING.

þseealso _nls_init() _nls_is_dbcs_lead() _nls_tolower() _nls_toupper()


þfunction _nls_tolower() _nls_toupper()
þcompat emx
þheaders
#include <sys/nls.h>
þendheaders

þparam C
þprototype
unsigned char _nls_tolower (unsigned char C);
unsigned char _nls_toupper (unsigned char C);
þendprototype

    These macros convert the character C to lower case or upper
    case, respectively.  Accented characters etc. are converted as
    well.  The result is undefined if C is a DBCS lead byte.

þreturnvalue

    _nls_tolower() returns its argument converted to lower case.
    _nls_toupper() returns its argument converted to upper case.

þseealso _nls_init() _nls_strlwr() _nls_strupr()


þfunction offsetof()
þcompat C90
þheaders
#include <stddef.h>
þendheaders

þparam TYPE MEMBER
þprototype
size_t offsetof (TYPE, MEMBER);
þendprototype

    The offsetof() macro expands to an integral constant expression of
    type þtt{size_t}.  The value of that expression is the offset in
    bytes from the beginning of the structure designated by TYPE to
    the structure member designated by MEMBER.

    The structure member must not be a bit-field.  Given the declaration
þtypewriter
static TYPE s;
þendtypewriter
    the expression
þtypewriter
&(s.þpa{MEMBER})
þendtypewriter
    must evaluate to an address constant.

þreturnvalue

    See above.

þsamplecode
#include <stddef.h>

struct sample
{
  int a;
  struct
    {
      int b[2];
    } inner;
};

size_t offset_a  = offsetof (struct sample, a);
size_t offset_b0 = offsetof (struct sample, inner.b[0]);
size_t offset_b1 = offsetof (struct sample, inner.b[1]);
þendsamplecode


þfunction open()
þcompat UNIX
þheaders
#include <io.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
þendheaders

þparam NAME OFLAG PMODE ISIZE
þprototype
int open (const char *NAME, int OFLAG);
int open (const char *NAME, int OFLAG, int PMODE);

int open (const char *NAME, int OFLAG, unsigned long ISIZE);
int open (const char *NAME, int OFLAG, int PMODE, unsigned long ISIZE);
þendprototype

    Open a file or device.  NAME points to the name of the file or
    device.  OFLAG contains one or more of the following values,
    combined by the þtt{|} operator:

þdescription

þitem O_RDONLY

    Open for reading.  Writing is not allowed

þitem O_WRONLY

    Open for writing.  Reading is not allowed

þitem O_RDWR

    Open for reading and writing

þitem O_APPEND

    Move the file pointer to the end of file before any write
    operation takes place.  This is used for appending to a file

þitem O_CREAT

    Create the file if it does not exist.  If this flag is set, the
    PMODE argument is required

þitem O_TRUNC

    Truncate the size of the file to 0

þitem O_EXCL

    Fail if the O_CREAT flag is used and the file already exists

þitem O_NONBLOCK and O_NDELAY

    Currently ignored

þitem O_BINARY

    Binary mode, no translation.  See below

þitem O_TEXT

    Text mode, translate CR/LF to the newline character.  See below

þitem O_NOINHERIT

    Child processes won't inherit the file handle

þitem O_SYNC

    Write operations are synchronous, that is, write() waits until
    file data has been physically written

þitem O_SIZE

    Set the initial size of the file to ISIZE if the file is a new
    file (O_CREAT) or an existing file truncated (O_TRUNC).  If this
    flag is set, the ISIZE argument is required.  O_SIZE is ignored
    under DOS

þenddescription

    If a new file is created, PMODE (modified by the umask value), is
    used to set the file permissions.  S_IREAD grants read access,
    S_IWRITE grants write access.  S_IREAD is ignored (DOS and OS/2
    limitation).  To grant both read and write access, use
    þtt{S_IREAD|S_IWRITE}.

    There are two additional OFLAG flags: O_TEXT for text mode,
    O_BINARY for binary mode.  Text mode, which is the default,
    translates each CR/LF pair to a newline character on input and
    translates newline characters to CR/LF pairs on output.  If the last
    character of a file is Ctrl-Z, it is discarded on input.  Binary
    mode disables these transformations.

    If the file or device cannot be opened, open() sets errno and
    returns -1.  If open() succeeds, the file handle is returned.  The
    file handle is always greater than -1.

    The mode þtt{O_TRUNC|O_RDONLY} is not implemented.  A Ctrl-Z at
    the end of the file is removed only when opening a file for
    appending in text mode.  Ctrl-Z at the end of the file is
    obsolete, anyway.

    The file is opened in the sharing mode SH_DENYNO, see
    þhpt{sopen()}.

þreturnvalue

    open() returns a file handle for the file.  On error, open() sets
    errno and returns -1.

þimplementation

    O_SIZE is an emx extension.  It's the caller's responsibility to
    truncate the file if its size should be less than ISIZE bytes.
    O_SIZE is ignored under DOS.

þrestrictions

    Under DOS, the O_NOINHERIT flag is currently ignored for child
    processes which are DOS programs (vs. emx programs).  Under DOS,
    the O_SYNC and O_SIZE flags are ignored.

þseealso close() fcntl() fdopen() ftruncate() sopen()


þfunction opendir() closedir() readdir() seekdir() telldir() rewinddir()
þcompat POSIX.1
þheaders
#include <sys/types.h>
#include <dirent.h>             /* this is recommended */
#include <sys/dir.h>            /* this also works (for now) */
þendheaders

þparam NAME DIRP OFF
þprototype
DIR *opendir (const char *NAME);
int closedir (DIR *DIRP);
struct dirent *readdir (DIR *DIRP);
void seekdir (DIR *DIRP, long OFF);
long telldir (DIR *DIRP);
void rewinddir (DIR *DIRP);
þendprototype

    Scan directories.  opendir() opens the directory whose name is in
    the string pointed to by NAME for scanning.  If there is an error,
    NULL is returned.  Otherwise a value is returned which is used
    with the other functions to continue the scanning.

    closedir() ends the directory scan of DIRP.  After closing DIRP,
    you must not use DIRP.  You should close all handles created by
    opendir().

    readdir() retrieves the next directory entry for DIRP.  If there
    are no more directory entries, NULL is returned.

    seekdir() moves to the specified directory entry of DIRP.  If OFF
    is 0, the first directory entry will be read next.  If OFF is 1,
    the second directory entry will be read next.  And so on.
    seekdir() is not a POSIX.1 function.

    telldir() returns the current position in DIRP.  0 is returned for
    the first directory entry.  telldir() is not a POSIX.1 function.

    rewinddir() is equivalent to þtt{seekdir (0)}.

    These functions use _fnlwr() to convert the file names to lower
    case on upper-case-only file systems.

þreturnvalue

    opendir() returns a descriptor to be used with the other
    functions.  On error, opendir() returns NULL.

    closedir() returns 0 if successful, -1 on error.

    readdir() returns a pointer to a directory entry.  If there are no
    more directory entries, readdir() returns NULL.

    telldir() returns the current position in DIRP.

þseealso _fnlwr() _wildcard()


þfunction _outp8() _outp16() _outp32()
þcompat emx *
þheaders
#include <sys/hw.h>
þendheaders

þparam PORT VALUE
þprototype
void _outp8 (unsigned PORT, unsigned VALUE);
void _outp16 (unsigned PORT, unsigned VALUE);
void _outp32 (unsigned PORT, unsigned VALUE);
þendprototype

    These functions write a single byte or word to a hardware port.
    _outp8() writes the byte VALUE to PORT, _outp16() writes the
    16-bit word VALUE to PORT, _outp32() writes the 32-bit word VALUE
    to PORT.

    You have to call _portaccess() first to enable access to a range
    of ports.  To make your program work under DOS, you have to use
    emx option -ai, see `þhpt{Using emx options}'.  Under OS/2, your
    program requires emxio.dll in a directory listed in LIBPATH.

þseealso _portaccess() _inp8() _outps8()


þfunction _outps8() _outps16() _outps32() _outps8dac()
þcompat emx *
þheaders
#include <sys/hw.h>
þendheaders

þparam PORT SRC COUNT
þprototype
void _outps8 (unsigned PORT, const unsigned char *SRC, unsigned COUNT);
void _outps16 (unsigned PORT, const unsigned short *SRC, unsigned COUNT);
void _outps32 (unsigned PORT, const unsigned short *SRC, unsigned COUNT);
void _outps8dac (unsigned PORT, const unsigned char *SRC, unsigned COUNT);
þendprototype

    These functions write multiple bytes or words to a hardware port.
    _outps8() writes COUNT bytes from the array pointed to by SRC to
    PORT.  _outps16() writes COUNT 16-bit words from the array pointed
    to by SRC to PORT.  _outps32() writes COUNT 32-bit words from the
    array pointed to by SRC to PORT.

    The COUNT argument of _outps8() must not exceed 65535.

    The array pointed to by SRC of _outps16() must be aligned on a
    16-bit boundary, that is, the address must be even.  COUNT must
    not exceed 32768.

    The array pointed to by SRC of _outps32() must be aligned on a
    32-bit boundary, that is, the address must be a multiple of four.
    COUNT must not exceed 65536.

    _outps8dac() is a slowed-down version of _outps8() suitable for
    writing to the VGA palette registers.

    You have to call _portaccess() first to enable access to a range
    of ports.  To make your program work under DOS, you have to use
    emx option -ai, see `þhpt{Using emx options}'.  Under OS/2, your
    program requires emxio.dll in a directory listed in LIBPATH.

þseealso _portaccess() _inps8() _outp8()


þfunction _path()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam DST NAME
þprototype
int _path (char *DST, const char *NAME);
þendprototype

    Find an executable file.  If the string pointed to by NAME
    contains a colon, a slash or a backslash, only that name will be
    tried.  If the string pointed to by NAME does not contain colons,
    slashes or backslashes, the file will be sought in the directories
    listed in the EMXPATH and PATH environment variables.  If the file
    is not found, the empty string will be stored to the array pointed
    to by DST, errno will be ENOENT and -1 will be returned.  If the
    file is found, the path name will be copied to the array pointed
    to by DST and 0 will be returned.  No default extension is used.

þreturnvalue

    See above.

þseealso getenv() _searchenv()


þfunction pathconf() fpathconf()
þcompat POSIX.1
þheaders
#include <unistd.h>
þendheaders

þparam PATH HANDLE NAME
þprototype
long pathconf (const char *PATH, int NAME);
long fpathconf (int HANDLE, int NAME);
þendprototype

    Return the current value of the configurable limit or option NAME
    associated with the file or directory associated with HANDLE or
    whose name is in the string pointed to by PATH.  NAME is one of
    the following constants:

þdescription
þitem _PC_LINK_MAX

    corresponds to LINK_MAX (maximum value of a file's link count)

þitem _PC_MAX_CANON

    corresponds to MAX_CANON (maximum number of bytes in a terminal
    canonical input line)

þitem _PC_MAX_INPUT

    corresponds to MAX_INPUT (maximum number of bytes for which space
    will be available in a terminal input queue)

þitem _PC_NAME_MAX

    corresponds to NAME_MAX (maximum number of bytes in a file name)

þitem _PC_PATH_MAX

    corresponds to PATH_MAX (maximum number of bytes in a path name)

þitem _PC_PIPE_BUF

    corresponds to PIPE_BUF (maximum number of bytes that can be
    written atomically to a pipe)

þitem _PC_CHOWN_RESTRICTED

    corresponds to _POSIX_CHOWN_RESTRICTED (see POSIX.1 for details)

þitem _PC_NO_TRUNC

    corresponds to _POSIX_NO_TRUNC (path name components longer than
    NAME_MAX generate an error)

þitem _PC_VDISABLE

    corresponds to _POSIX_VDISABLE (terminal special characters can be
    disabled using this character value, if it is defined)

þenddescription

    See POSIX.1 for more details.

þreturnvalue

    If NAME is invalid, pathconf() and fpathconf() set errno to EINVAL
    and return -1.  If the value associated with NAME has no limit for
    the path or handle, pathconf() and fpathconf() return -1 without
    changing errno.  If the implementation needs to use PATH or HANDLE
    to determine the value of NAME and the implementation does not
    support the association of NAME with the file specified by PATH or
    HANDLE, respectively, or if HANDLE is an invalid file descriptor,
    pathconf() and fpathconf() set errno and return -1.  Otherwise,
    pathconf() and fpathconf() return the current value of the
    variable.

þrestrictions

    pathconf() and fpathconf() currently return just the POSIX.1
    minimum values.

þseealso sysconf()


þfunction pause()
þcompat UNIX
þheaders
#include <signal.h>
þendheaders

þprototype
int pause (void);
þendprototype

    Wait until a signal is received.  The process is suspended until
    delivery of a signal for which a signal handler is installed.
    pause() returns after the signal handler returns.

    The process will be terminated (and pause() won't return) if
    an uncaught signal is delivered which terminates the process.

þreturnvalue

    pause() returns -1 and sets errno to EINTR (if it returns at
    all).

þrestrictions

    pause() is not implemented under DOS.

þseealso alarm() kill() raise() sigaction() signal() sigsuspend()


þfunction pclose()
þcompat UNIX
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
int pclose (FILE *STREAM);
þendprototype

    Close a pipe created by popen().  pclose() waits until the child
    process started by popen() ends and then closes STREAM.  The
    termination status of the child process is returned.  See
    þhpt{wait()} for details about the return value.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þrestrictions

    pclose() is not implemented under DOS.

þseealso popen() wait()


þfunction perror()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STRING
þprototype
void perror (const char *STRING);
þendprototype

    Print an appropriate error message for the current errno value to
    stderr.  If STRING is NULL or points to the empty string þtt{""},
    just the error message is printed.  Otherwise, the string pointed
    to by STRING and a colon precede the error message.

þseealso errno strerror() sys_errlist sys_nerr


þfunction pipe()
þcompat UNIX
þheaders
#include <io.h>
þendheaders

þparam TWO_HANDLES
þprototype
int pipe (int *TWO_HANDLES);
þendprototype

    Create an unnamed pipe.  The handle used for reading from the pipe
    is stored to þpa{TWO_HANDLES}þtt{[0]}, the handle used for writing
    to the pipe is stored to þpa{TWO_HANDLES}þtt{[1]}.  Both handles
    are in text mode; use þtt{setmode()} if you want to switch to
    binary mode.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þrestrictions

    pipe() is implemented for OS/2 only.

þseealso close() dup() popen() setmode()


þfunction popen()
þcompat UNIX
þheaders
#include <stdio.h>
þendheaders

þparam COMMAND MODE
þprototype
FILE *popen (const char *COMMAND, const char *MODE);
þendprototype

    Start a child process and connect one end of a pipe to it.
    popen() runs the command whose name is in the string pointed to by
    COMMAND by starting a command processor.  See þhpt{system()} for
    details on locating and running the command processor.  MODE must
    point to a string starting with þtt{r} or þtt{w}.  If the string
    starts with þtt{r}, standard output of the command will be
    redirected, you can get the output by reading from the stream
    returned by popen().  If the mode string starts with þtt{w},
    standard input of the command will be redirected, you can send
    data to the command by writing to the stream returned by popen().
    Append þtt{b} for binary mode or þtt{t} for text mode to the mode
    string.  The default is text mode, see also þhpt{fopen()}.  If an
    error occurs, popen() returns NULL.  Otherwise, popen() returns a
    stream which is connected to the local end of the pipe.  Use
    pclose() to close the stream.

þreturnvalue

    popen() returns a new stream.  On error, popen() returns NULL.

þrestrictions

    popen() is not implemented under DOS.

þseealso pclose() pipe() system()


þfunction _portaccess()
þcompat emx
þheaders
#include <sys/hw.h>
þendheaders

þparam FIRST LAST
þprototype
int _portaccess (unsigned FIRST, unsigned LAST);
þendprototype

    Gain access to hardware ports.  To access hardware ports, you have
    to call _portaccess().  FIRST is the address of the first port,
    LAST is the address of the last port.  emx option -ai must be used
    to enable _portaccess() under DOS, see `þhpt{Using emx options}'.

    _portaccess() always succeeds under OS/2.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso _memaccess() _inp8() _outp8() _wait0()

þsamplefile /emx/test/hw_io.c


þfunction pow() powl()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X Y
þprototype
double pow (double X, double Y);
long double powl (long double X, long double Y);
þendprototype

    Raise X to the power of Y and return the result.  If pow() is
    undefined for a given pair of X and Y, pow() returns an
    implementation-defined value and sets errno to EDOM.  On overflow,
    pow() returns HUGE_VAL and sets errno to ERANGE.

    pow() returns 1.0 for all values of X if Y is zero.

    powl() uses the þtt{long double} format.

þreturnvalue

    pow() returns þpa{X}^þpa{Y}.

þseealso cbrt() exp() ldexp() log() sqrt()


þfunction printf()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam FORMAT <flags> <width> <precision> <size> <type>
þprototype
int printf (const char *FORMAT, ...);
þendprototype

    printf() performs formatted output to the stdout stream.  On
    success, the number of characters written to stdout is returned.
    Otherwise, EOF is returned.

    Characters in the string pointed to by FORMAT are copied
    unmodified to the destination unless a format specification is
    hit.  A format specification has the following format:

þindent
  þsy{%[<flags>][<width>][.<precision>][<size>]<type>}
þendindent

    where items in brackets are optional.  For each format
    specification an argument of the specified type is taken from the
    argument list, is formatted according to the format specification
    and written to the destination.  To include one percent sign in
    the output, put two percent signs (þtt{%%}) into the FORMAT string.

    A <flag> character can be specified to modify the formatting. The
    following <flags> characters are available:

þlist
þitem þtt{-}

    Left-justify the converted value in the field.  Without this flag,
    the value is right-justified.  The value will be padded with
    blanks on the right (note that þtt{-} overrides þtt{0}).  If
    þtt{-} is not given, the value is padded on the left with blanks
    or zeros, according to the þtt{0} flag and the <type>.

þitem þtt{+}

    Always insert sign (þtt{+} or þtt{-}) for the conversion of a
    signed number (that is, <type> being þtt{d}, þtt{e}, þtt{E},
    þtt{f}, þtt{g}, þtt{G} or þtt{i}).  þtt{+} is ignored for all
    other conversions.  þtt{+} overrides space.  If þtt{+} is not
    specified, the sign is printed only for negative numbers and for
    -0.0.

þitem space

    Insert a space if the conversion of a signed number (that is,
    <type> being þtt{d}, þtt{e}, þtt{E}, þtt{f}, þtt{g}, þtt{G} or
    þtt{i}) doesn't start with a sign (þtt{+} or þtt{-}).  For all
    other conversions, space is ignored.  If both þtt{+} and space are
    given, space is ignored.

þitem þtt{0}

    Pad numbers with þtt{'0'} characters instead of blanks.  This flag
    is ignored for non-numeric conversions, if þtt{-} is used, or if
    <precision> is given.

þitem þtt{#}

    Use alternate conversion.  For the þtt{o} conversion, the
    precision will be increased to force the first digit of the result
    to be a zero.  For the þtt{x} and þtt{X} conversions, the number
    will be prefixed with þtt{0x} unless it is zero.  For the þtt{e},
    þtt{E}, þtt{f}, þtt{g} and þtt{G} conversions, a decimal point
    will always be printed, even if no digits follow it.  For the
    þtt{g} and þtt{G} conversions, trailing zeros are not removed.

þendlist

    If the length of the converted value is less than <width>, it is
    padded with blanks or þtt{'0'} characters.  Unless the þtt{-} flag
    is used, the field is padded on the left.  Padding is done with
    zeros for numeric conversions if the þtt{0} flag is given, the
    þtt{-} flag is not given and <precision> is not given.  Otherwise,
    blanks are used for padding.  If the length of the converted value
    is greater than <width>, the field is not truncated.  <width> is
    either a decimal number or a þtt{*} character.  In the latter
    case, the width is taken from the argument list.

    <precision> specifies the number of decimal digits after the
    decimal point of a floating point number when using the þtt{e},
    þtt{E} or þtt{f} conversions.  For the þtt{g} and þtt{G}
    conversions, <precision> specifies the maximum number of
    significant digits.  The number will be rounded according to
    <precision> for the floating point conversions.  For the þtt{d},
    þtt{i}, þtt{o}, þtt{u}, þtt{x} and þtt{X} conversions, <precision>
    specifies the minimum number of digits to print.  If the number
    has less digits, it will be padded with zeros on the left.  If the
    precision is 0 and the integer is 0, no output will be produced
    for this field (except for the þtt{o} conversion if the þtt{#}
    flag is given).  For the þtt{s} conversion, <precision> specifies
    the maximum string length.  For all other conversions, <precision>
    is ignored.  <precision> is either a decimal number or a þtt{*}
    character.  In the latter case, the precision is taken from the
    argument list.  If a decimal point without <precision> is given,
    the precision will be 0.

    <size> is either þtt{h} for a þtt{short} type (þtt{h} is available
    for the þtt{d}, þtt{i}, þtt{o}, þtt{u}, þtt{x}, and þtt{X}
    conversions and for þtt{n}) or þtt{l} for a þtt{long} type (þtt{l}
    is available for the þtt{d}, þtt{i}, þtt{o}, þtt{u}, þtt{x}, and
    þtt{X} conversions and for þtt{n}) or þtt{L} for the þtt{long
    double} type (þtt{L} is available for the þtt{e}, þtt{E}, þtt{f},
    þtt{g}, and þtt{G} conversions).  If <size> is not specified, the
    default size is used.

    <type> (the conversion type) is one of the following characters:

þlist
þitem þtt{c}

    Character.  The argument (þtt{char}, þtt{signed char},
    þtt{unsigned char} or þtt{int}) is converted to an þtt{unsigned
    char} and that character code will be printed.  <size> is ignored.

þitem þtt{d}

    Signed decimal number.  The argument is converted to a signed
    integer and printed in decimal notation.  Use þtt{%hd} to print a
    þtt{short int}, þtt{%ld} to print a þtt{long int} and þtt{%Ld} to
    print a þtt{long long int}.

þitem þtt{e}

    Floating-point number (þtt{double}), using þtt{e} as exponent
    sign: þtt{-#.###e+##}.  There's exactly one digit before the
    decimal point.  The number of digits after the decimal point is
    specified by <precision>.  If <precision> is missing, 6 digits are
    printed after the decimal point.  If <precision> is zero, no
    decimal point is printed unless the þtt{#} flag is given.  The
    exponent has at least 2 digits.  If the number is zero, the
    exponent is þtt{00}.  The decimal point character of the current
    locale is used.  A NaN is printed as `þtt{nan}', infinity as
    `þtt{inf}'.

þitem þtt{E}

    Floating-point number (þtt{double}); same as þtt{e}, except for
    þtt{E} being used instead of þtt{e} to introduce the exponent, and
    `þtt{NAN}' and `þtt{INF}' being printed instead of `þtt{nan}' and
    `þtt{inf}', respectively.

þitem þtt{f}

    Floating-point number (þtt{double}) printed in fixed-point format.
    The number of digits after the decimal point is specified by
    <precision>.  If <precision> is missing, 6 digits are printed.  If
    <precision> is specified as zero, no decimal point is printed
    unless the þtt{#} flag is given.  There's always at least one
    digit before the decimal point.  The decimal point character of
    the current locale is used.  A NaN is printed as `þtt{nan}',
    infinity as `þtt{inf}'.

þitem þtt{F}

    Floating-point number (þtt{double}); same as þtt{f}, except for
    `þtt{NAN}' and `þtt{INF}' being printed instead of `þtt{nan}' and
    `þtt{inf}', respectively.

þitem þtt{g}

    Floating-point number (þtt{double}).  The number is printed in
    exponential or fixed-point format, depending on the magnitude.  If
    the number is an integer, it is printed as integer, without
    decimal point (unless the þtt{#} flag is used).  If the exponent
    (of þtt{e} format output) is less than -4 or greater than
    <precision> (the default is 6), type þtt{e} is used.  Otherwise,
    type þtt{f} is used.  In both cases, trailing zeros (and the
    decimal point, if it isn't followed by any digits) will be removed
    unless the þtt{#} flag is used.  <precision> specifies the number
    of significant digits to print.  If <precision> is missing, 6
    significant digits are printed.  If <precision> is zero, a
    precision of 1 will be used instead.  The decimal point character
    of the current locale is used.  A NaN is printed as `þtt{nan}',
    infinity as `þtt{inf}'.

þitem þtt{G}

    Floating-point number (þtt{double}); same as þtt{g}, except for
    þtt{E} being used instead of þtt{e} to introduce the exponent, and
    `þtt{NAN}' and `þtt{INF}' being printed instead of `þtt{nan}' and
    `þtt{inf}', respectively.

þitem þtt{i}

    Signed decimal number.  Same as þtt{d}.

þitem þtt{n}

    Store the number of characters formatted up to this point in the
    FORMAT string (þtt{int *}).  This `conversion' does not create any
    output.  Use þtt{%hn} when passing a pointer to a þtt{short int},
    þtt{%ln} when passing a pointer to a þtt{long int} and þtt{%Ln}
    when passing a pointer to a þtt{long long int}.

þitem þtt{o}

    Unsigned octal number.  The argument is converted to an unsigned
    integer and printed in octal notation.  Use þtt{%ho} to print an
    þtt{unsigned short int}, þtt{%lo} to print an þtt{unsigned long
    int} and þtt{%Lo} to print an þtt{unsigned long long int}.  If the
    þtt{#} flag is given, the precision will be increased to force the
    first digit of the result to be a zero.  If the number is zero and
    the precision is zero (after taking the þtt{#} flag into account),
    the result will be empty.

þitem þtt{p}

    Pointer (þtt{void *}).  The output format of a pointer is
    implementation-dependent.  In this implementation, þtt{p} is
    equivalent to þtt{x}.

þitem þtt{s}

    String (þtt{char *}).  Print characters of the string until a null
    character is reached or <precision> (if specified) is exhausted.
    If <precision> is not specified, the string must have a
    terminating null character.  If <precision> is specified, the
    string length is limited by <precision>.

þitem þtt{u}

    Unsigned decimal number.  The argument is converted to an unsigned
    integer and printed in decimal notation.  Use þtt{%hu} to print an
    þtt{unsigned short int}, þtt{%lu} to print an þtt{unsigned long
    int} and þtt{%Lu} to print an þtt{unsigned long long int}.

þitem þtt{x}

    Unsigned hexadecimal number.  The argument is converted to an
    unsigned integer and printed in hexadecimal notation, using
    lower-case letters.  Use þtt{%hx} to print an þtt{unsigned short
    int}, þtt{%lx} to print an þtt{unsigned long int} and þtt{%Lx} to
    print an þtt{unsigned long long int}.  If the þtt{#} flag is given
    and the number is non-zero, þtt{0x} is prepended.

þitem þtt{X}

    Hexadecimal number (þtt{unsigned int}); same as þtt{x}, except for
    upper-case letters being used instead of lower-case letters.

þendlist

    The behavior for other <type> characters is undefined, except for
    þtt{%} immediately following þtt{%}.

þreturnvalue

    printf() returns the number of characters written to stdout.  On
    error, printf() returns EOF.

þimplementation

    The þtt{#} flag is ignored for the þtt{c}, þtt{d}, þtt{i},
    þtt{n}, þtt{p}, þtt{s} and þtt{u} conversions.

    <size> can be þtt{L} for the þtt{long long} type (þtt{L} is
    available for the þtt{d}, þtt{i}, þtt{o}, þtt{u}, þtt{x}, and
    þtt{X} conversions and for þtt{n}).  þtt{ll} is an alternate
    spelling for þtt{L}.

þrestrictions

    The output could be more accurate for floating point values.

þhints

    Note that þtt{%lf} is not a valid conversion specifier, use
    þtt{%f} instead.  Contrast with scanf().

þseealso fopen() fwrite() _itoa() scanf() setlocale() strftime()

þsamplecode
int year, month, day;
...
printf ("%d/%.2d/%.2d\n", year, month, day);
þendsamplecode


þfunction profil()
þcompat UNIX *
þheaders
#include <unistd.h>
þendheaders

þparam BUFF BUFSIZ OFFSET SCALE
þprototype
int profil (void *BUFF, unsigned BUFSIZ, unsigned OFFSET, unsigned SCALE);
þendprototype

    Sampling profiler.  This function is very experimental, therefore
    no documentation is provided.  profil() might disappear in the future.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þimplementation

  The sampling frequency is 1024Hz under DOS, 1000Hz under OS/2.
  Counters are 32-bit words (under Unix, counters usually are 16-bit
  words).

þrestrictions

  When an attempt to update a counter causes an exception, the program
  will be terminated (under OS/2) or the system will be stopped (under
  DOS).

  Under OS/2, SCALE must be þtt{0x4000}, þtt{0x8000}, or þtt{0x10000}.

  Under OS/2, profil() uses an unsupported and undocumented OS/2 API
  which has several bugs and may be dropped in future versions.  It
  has been tested on OS/2 3.0 only.

  profil() is not available with the system call library sys.lib
  (þhpt{-Zsys}).


þfunction ptrace()
þcompat SysV *
þheaders
#include <sys/ptrace.h>
þendheaders

þparam REQUEST PID ADDR DATA
þprototype
int ptrace (int REQUEST, int PID, int ADDR, int DATA);
þendprototype

    Debug a child process.  The child process is identified by PID.
    The following REQUEST codes are defined:

þdescription

þitem PTRACE_TRACEME

    Not implemented -- use þtt{spawn (P_DEBUG)} instead


þitem PTRACE_PEEKTEXT

    Read a 32-bit word from the text space of the child process.
    ADDR is the address of the word.  The word at ADDR is returned.

þitem PTRACE_PEEKDATA

    See PTRACE_PEEKTEXT.  On machines with separate data and text
    space, this request will read from the data space.

þitem PTRACE_PEEKUSER

    Read a 32-bit word from the process table of the child process.
    This can be used to read the registers of the child process.  See
    <sys/user.h> for details.

þitem PTRACE_POKETEXT

    Write the 32-bit word DATA to address ADDR of the text space of
    the child process.

þitem PTRACE_POKEDATA

    See PTRACE_POKETEXT.  On machines with separate data and text
    space, this request will write to the data space.

þitem PTRACE_POKEUSER

    Write a 32-bit word to the process table of the child process.
    This can be used to alter the registers of the child process.  See
    <sys/user.h> for details.  Not all registers can be modified.

þitem PTRACE_RESUME

    Resume the child process.  All pending signals will be canceled.
    If DATA is non-zero, the child process will continue as if it had
    received that signal.  The child process will run until another
    signal occurs.

þitem PTRACE_EXIT

    Kill the child process.

þitem PTRACE_STEP

    Execute the next instruction of the child process.  All pending
    signals will be canceled.  If DATA is non-zero, the child process
    will continue as if it had received that signal.  If
    _UF_PTRACE_MULTITHREAD is selected and PID includes a thread ID, one
    instruction of that thread only will be executed.  Otherwise, one
    instruction of any of the ready threads will be executed.

þitem PTRACE_SESSION

    If DATA is 0, select the session of the calling process.  If DATA
    is 1, select the child session.  If DATA is 2, the child session
    is automatically selected by the next PTRACE_STEP (on þtt{CALL}
    instructions only) or PTRACE_RESUME command.  This request is emx
    specific and is ignored under DOS.

þitem PTRACE_NOTIFICATION

    Return the last notification and store data associated with that
    notification to the buffer pointed to by ADDR.  DATA is the size
    of the buffer.  If ADDR is NULL or if the size is too small, data
    won't be stored.  See below for notification codes and data
    structures.  This request is emx specific and is ignored under
    DOS.

þitem PTRACE_CONT

    Continue after a notification has been reported.  The previous
    PTRACE_RESUME or PTRACE_STEP request will be continued.  This
    request is emx specific and is ignored under DOS.

þitem PTRACE_THAW

    Thaw (enable) the thread identified by PID (which contains both a
    process ID and a thread ID).  This request is emx specific and is
    ignored under DOS.

þitem PTRACE_FREEZE

    Freeze (disable) the thread identified by PID (which contains both
    a process ID and a thread ID).  Note that an attempt to apply
    PTRACE_STEP to a frozen thread will result in an error.  This
    request is emx specific and is ignored under DOS.

þitem PTRACE_ATTACH

    Attach a debugger to the process identified by PID.  That process
    must be a direct or indirect child process of a process started
    with the P_DEBUGDESC flag set (see þhpt{spawn*()}) and the
    debugger process debugging the direct parent process of the
    process identified by PID must still exist (and must continue to
    exist while the process identified by PID is being debugged).  For
    each process of this kind, at most one process (debugger) can
    attach to that process.

þitem PTRACE_DETACH

    Detach a debugger from the process identified by PID.  That
    process must have been attached to with PTRACE_ATTACH by the same
    process.  ADDR must be either 0 or 1.  If ADDR is 0, the process
    identified by PID will remain stopped (allowing another process to
    attach).  If ADDR is 1, the process identified by PID will resume
    execution.  The debugger process debugging the direct parent
    process of the process identified by PID must continue to exist
    during the entire lifetime of the process identified by PID,
    otherwise that process will be terminated prematurely or may
    block.

þenddescription

    If _UF_PTRACE_NOTIFY or _UF_PTRACE_MULTITHREAD has been set with
    _uflags(), ptrace() will report creation and termination of
    threads and loading and freeing of modules (DLLs).  If a
    notification is pending, wait() and waitpid() report the child
    process as having been stopped by SIGPTRACENOTIFY.  In that case,
    use the PTRACE_NOTIFICATION request of ptrace() to get more
    information.  If successful, the PTRACE_NOTIFICATION request of
    ptrace() will report one of the following values:

þdescription

þitem PTN_THREAD_NEW

    Creation of a new thread.  To obtain the thread ID, pass a pointer
    to an object of type þtt{struct ptn_thread} in ADDR.  That
    structure is defined as follows:

þexample
struct ptn_thread
{
  unsigned tid;
  unsigned long reserved[31];
};
þendexample

    The þtt{tid} member will be set to the thread ID.  Creation of the
    initial thread (thread 1) is also reported.

þitem PTN_THREAD_END

    Termination of a thread.  To obtain the thread ID, pass a pointer
    to an object of type þtt{struct ptn_thread} in ADDR.  The þtt{tid}
    member of that structure will be set to the thread ID.
    Termination of the initial thread (thread 1) is also reported.

þitem PTN_MODULE_LOAD

    Loading of a module.  To obtain the module handle and the full
    path name of the module, pass a pointer to an object of type
    þtt{struct ptn_module} in ADDR.  That structure is defined as
    follows:

þexample
struct ptn_module
{
  unsigned long hmte;
  unsigned long text_start;
  unsigned long text_size;
  unsigned long data_start;
  unsigned long data_size;
  unsigned long bss_start;
  unsigned long bss_size;
  unsigned long flags;
  unsigned long reserved[24];
  char name[260];
};
þendexample

    The þtt{hmte} member will be set to the module handle.  The
    þtt{text_start} member will be set to the start address of the
    text segment, the þtt{text_size} member will be set to the size of
    the text segment.  The þtt{data_start} member will be set to the
    start address of the initialized data segment, the þtt{data_size}
    member will be set to the size of the initialized data segment.
    The þtt{bss_start} member will be set to the start address of the
    uninitialized data segment, the þtt{bss_size} member will be set
    to the size of the uninitialized data segment.  The þtt{flags}
    member will have zero or more of the following flags set:
    PTNMOD_DLL means that the module is a DLL (otherwise, it's the
    executable file of the program being debugged), PTNMOD_AOUT means
    that the module has been created with ld and emxbind (otherwise,
    it has been created with LINK386).  The þtt{name} member will be
    set to the full path name of the module.

þitem PTN_MODULE_FREE

    Free a module (DLL).  To obtain the module handle and the full
    path name of the DLL, pass a pointer to an object of type
    þtt{struct ptn_module} in ADDR.  The þtt{hmte} member of that
    structure will be set to the module handle, the þtt{name} member
    will be set to the full path name of the DLL.

þitem PTN_PROC_NEW

    Descendant process started.  This notification occurs only for
    processes started with the P_DEBUGDESC flag of þhpt{spawn*()} and
    for child processes of such processes.  The notification is
    reported to the debugger process debugging the parent process of
    the new process.  To obtain the process ID and the full path name
    of the executable file of the descendant process, pass a pointer
    to an object of type þtt{struct ptn_proc} in ADDR.  That structure
    is defined as follows:

þexample
struct ptn_proc
{
  unsigned pid;
  unsigned long flags;
  unsigned long fork_addr;
  unsigned long reserved[29];
  char name[260];
};
þendexample

    The þtt{pid} member of that structure will be set to the process
    ID of the descendant.  The þtt{flags} member will have zero or
    more of the following flags set: PTNPROC_FORK means that the
    descendant has been created with fork(), PTNPROC_AOUT means that
    the executable file has been created with ld and emxbind
    (otherwise, it has been created with LINK386).  If PTNPROC_FORK is
    set, þtt{fork_addr} will contain the return address of the
    þtt{__fork()} system call, that is, the address at which the
    parent and child processes will continue.  If that address cannot
    be determined (should not happen), þtt{fork_addr} will be zero.
    The þtt{name} member will be set to the full path name of the
    executable file.

    The descendant process will block until a debugger process
    attaches to the descendant process with PTRACE_ATTACH.  To let the
    descendant process continue without being debugged, apply
    PTRACE_ATTACH and then PTRACE_DETACH to the descendant process.
    If the descendant process has been created with fork(), the parent
    process also blocks until the startup code of the descendant
    process has been executed.

þenddescription

    If _UF_PTRACE_MULTITHREAD has been selected with _uflags(),
    ptrace() supports debugging of multithread procdesses.  In that
    case, the PID argument of ptrace() contains both a process ID and
    a thread ID.  The PTRACE_PEEKUSER, PTRACE_POKEUSER, and
    PTRACE_STEP requests apply to the specified thread only.
    Moreover, wait() and waitpid() will return both a process ID and a
    thread ID.  The following macros are used to deal with combined
    process IDs and thread IDs:

þdescription

þitem PTRACE_GETPID

    Extract the process ID from the value passed as argument.

þitem PTRACE_GETTID

    Extract the thread ID from the value passed as argument.

þitem PTRACE_PIDTID

    Build the PID argument for ptrace(): the first argument is the
    process ID, the second argument is the thread ID.

þenddescription

þreturnvalue

    See above.  As -1 is a legal return value for the þtt{PTRACE_PEEK}
    requests, you should set errno to 0 before calling ptrace() and
    check errno after the call.

þrestrictions

    Under DOS, a process can debug only one child process.  ptrace()
    is not available with the system call library sys.lib
    (þhpt{-Zsys}).  Under OS/2, the only signal number which can be
    passed in DATA for PTRACE_RESUME and PTRACE_STEP is the one of the
    signal by which the child process has been stopped.
    Notifications, multithread processes, and debugging of descendants
    are not supported under DOS.  PTRACE_ATTACH works only under
    certain circumstances defined above.

þseealso spawn*() _uflags() wait() waitpid()


þfunction putc()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam C STREAM
þprototype
int putc (int C, FILE *STREAM);
þendprototype

    Write the character C (converted to an þtt{unsigned char}) to the
    output stream STREAM and advance the file position indicator of
    the stream (if defined).

    putc() may be implemented as macro, in contrast to fputc().  In
    consequence, putc() may evaluate its arguments more than once.

þreturnvalue

    putc() returns the character written.  On error, putc() sets the
    error indicator of the stream and returns EOF.

þimplementation

    putc() is implemented as in-line function for single-thread
    programs.

þhints

    Use putc() instead of fputc() if you want to write a lot of
    characters.

    The arguments of putc() should not be expressions with side
    effects.

þseealso fputc() putchar()


þfunction putchar()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam C
þprototype
int putchar (int C);
þendprototype

    þtt{putchar (c)} is equivalent to þtt{putc (c, stdout)}.

þreturnvalue

    putchar() returns the character written.  On error, putchar() sets
    the error indicator of stdout and returns EOF.

þimplementation

    putchar() is implemented as in-line function for single-thread
    programs.

þhints

    Use putchar() instead of fputc() if you want to write a lot of
    characters to stdout.

    The argument of putchar() should not be an expression with side
    effects.

þseealso fputc() putc()


þfunction putenv()
þcompat BSD
þheaders
#include <stdlib.h>
þendheaders

þparam STRING NAME VALUE
þparam STRING
þprototype
int putenv (const char *STRING);
þendprototype

    Put a value into the environment of the calling process.  STRING
    is a pointer to a string of the form

þtypewriter
  "þpa{NAME}=þpa{VALUE}"
þendtypewriter

    where NAME is the name of the environment variable and VALUE is
    the value of the environment variable.  If the environment
    variable NAME already exists, the current value is replaced by the
    new value, VALUE.  If NAME is not already in the environment,
    STRING is put into the environment.  Do not free or reuse the
    string pointed to by STRING after calling putenv().  Using an auto
    variable is also a bad idea.  After calling putenv(), do not use
    the þpa{ENVP} argument of main().  Use environ instead.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso getenv()


þfunction puts()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STRING
þprototype
int puts (const char *STRING);
þendprototype

    Write the string pointed to by STRING followed by a newline (LF)
    character (which is translated to CR/LF if stdout is in text mode)
    to the stdout stream.

þreturnvalue

    On failure, puts() returns EOF.  Otherwise, puts() returns a
    non-negative value.

þseealso fputs() fgets()


þfunction putw()
þcompat UNIX
þheaders
#include <stdio.h>
þendheaders

þparam X STREAM
þprototype
int putw (int X, FILE *STREAM);
þendprototype

    Write the word (þtt{int}) X to STREAM and return it.  Avoid using
    this function.

þreturnvalue

    putw() returns X.  On error, getw() returns -1.  As -1 is also a
    possible word value, you have to use ferror() to recognize an
    error condition.

þseealso getw() fwrite()


þfunction qsort()
þcompat C90

þheaders
#include <stdlib.h> /* use this */
#include <search.h> /* or this */
þendheaders

þparam BASE NUM WIDTH COMPARE X1 X2
þprototype
void qsort (void *BASE, size_t NUM, size_t WIDTH,
            int (*COMPARE)(const void *X1, const void *X2));
þendprototype

   Sort an array.  BASE is a pointer to the beginning of the array.
   The array contains NUM elements of WIDTH bytes each.  COMPARE is
   called to compare the two elements pointed to by X1 and X2.
   COMPARE should return a negative value, if element X1 is less than
   element X2, zero, if element X1 equals element X2, and a positive
   value if element X1 is greater than element X2.

   þbf{Note:} qsort() is not stable: the order of equal elements is
   undefined.  To make qsort() stable, add a field to the sort key
   which holds the index of the element.


þfunction raise()
þcompat C90
þheaders
#include <signal.h>
þendheaders

þparam SIG
þprototype
int raise (int SIG);
þendprototype

    Generate the signal SIG.  If the signal SIG is blocked, the signal
    will be made pending, to be delivered when it is unblocked.

    Each thread has its own set of signal handlers.  raise() generates
    the signal in the thread in which it is called.  Use kill() to
    send the signal to the main thread (thread 1).

    See section þref{signal processing} for details on
    þhpt{signal processing}.

þreturnvalue

    If successful, raise() returns 0.  Otherwise -1 is returned and
    errno is set.

þerrors
þdescription
þitem EINVAL
    SIG is not a valid signal number
þenddescription

þseealso abort() kill() sigaction() signal()


þfunction rand() srand()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam SEED
þprototype
int rand (void);
void srand (unsigned int SEED);
þendprototype

    rand() returns a pseudo-random number in the range 0 through
    RAND_MAX (32767).  RAND_MAX is defined in <stdlib.h>.  srand()
    initializes the sequence of random numbers.  The initial SEED
    value (if srand() is not called) is 1.

    The quality of the random numbers generated by rand() is poor,
    though it is not as poor as in other implementations of rand().
    If you need good random numbers, you should use random(), which is
    in the BSD library.

    In programs linked with the multithread libraries (-Zmt, -Zmts, or
    -Zmtd), rand() will generate identical sequences of random numbers
    in all the threads and srand() will affect only the thread in
    which it is called.  The behavior of rand() is undefined in
    multithread programs linked with single-thread libraries.

    You must not call rand() or srand() in a thread created by
    DosCreateThread.

þreturnvalue

    See above.

þif text
þc þseealso _beginthread() emxbsd.doc
þelse
þc þseealso _beginthread() random()
þendif


þfunction read()
þcompat UNIX
þheaders
#include <io.h>
þendheaders

þparam HANDLE BUF NBYTE
þprototype
int read (int HANDLE, void *BUF, size_t NBYTE);
þendprototype

    Read up to NBYTE characters from file HANDLE to the buffer BUF.
    The number of characters read is returned.  If there is an error,
    -1 is returned.  The return value may be less than NBYTE.  For
    instance, this happens if the end of the file is reached.  See
    also `þhpt{General terminal interface}'.  If HANDLE is 0 and
    HANDLE refers to the keyboard and O_NONBLOCK (alias O_NDELAY) has
    been set with fcntl() for HANDLE and the IDEFAULT and ICANON bits
    have been reset with ioctl() for HANDLE, -1 is returned and errno
    is set to EAGAIN if the call to read() would block.  Even if there
    is some data available, but not enough with respect to VMIN, -1 is
    returned.

    If HANDLE has been opened in text mode, CR/LF pairs are translated
    to newline characters and a Ctrl-Z character is discarded if it is
    the last character of the file.

þreturnvalue

    See above.

þseealso open() setmode() write()


þfunction _read_kbd()
þcompat emx *
þheaders
#include <stdlib.h>
#include <sys/kbdscan.h>  /* optional, for extended scan codes */
þendheaders

þparam ECHO WAIT SIG
þprototype
int _read_kbd (int ECHO, int WAIT, int SIG);
þendprototype

    Get a character from the keyboard.  Extended codes are preceded by
    a null character (call _read_kbd() again!), the scan codes are
    defined in <sys/kbdscan.h>.  If ECHO is non-zero, input will be
    echoed, if WAIT is non-zero, _read_kbd() will wait until a
    character is available, if WAIT is zero and no character is
    available, _read_kbd() will return -1, if SIG is zero, Ctrl-C will
    be ignored.  Examples (taken from <conio.h>):

þexample
#define getch()  _read_kbd (0, 1, 0)
#define getche() _read_kbd (1, 1, 0)
þendexample

    Please use the þhpt{general terminal interface} instead.

    It's important to call _read_kbd() again if _read_kbd() returns 0.
    To see what happens if you don't, type Ctrl-S F10 under DOS.

þreturnvalue

    See above.

þc þseealso ioctl() read() <conio.h>
þseealso ioctl() read()


þfunction realloc()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam MEM SIZE
þprototype
void *realloc (void *MEM, size_t SIZE);
þendprototype

    Reallocate the block of memory pointed to by MEM, making it big
    enough to hold SIZE bytes.  If MEM is NULL, a new block of memory
    is allocated by calling malloc().  Otherwise, MEM must be a
    pointer returned by calloc(), malloc(), realloc(), _ucalloc(),
    _umalloc(), or _utcalloc().  In this case, the size
    of the block pointer to by MEM is changed to SIZE.  If the block
    pointed to by MEM cannot be expanded in-place, it is moved.  If
    MEM is non-þtt{NULL} and SIZE is zero, the block is freed and NULL
    is returned.  A pointer to the new, resized block of memory is
    returned.  If there is not enough memory available, NULL is
    returned.

þreturnvalue

    realloc() returns MEM (if the block could be resized without
    moving), a pointer to a newly allocated block of memory, or NULL
    (if there wasn't enough memory, or if MEM is non-þtt{NULL} and
    SIZE is zero).

þimplementation

    Some implementations of realloc() can be applied to blocks freed
    by free() as long as calloc(), malloc(), and realloc() have not
    been called since freeing the block.  This implementation of
    realloc() cannot be applied to freed blocks.

    If MEM is not NULL and the block cannot be moved, realloc() will
    allocate the new block in MEM's heap.  If MEM is NULL, realloc()
    will allocate memory from the default heap of the current thread.

þseealso malloc() _mheap() _trealloc() _udefault()


þfunction _remext()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam PATH
þprototype
void _remext (char *PATH);
þendprototype

    Remove the extension from the file name pointed to by PATH.  If
    the last member of the string starts with a dot
    (þtt{"/usr/mattes/.profile"}, for instance) the string isn't
    modified.

    _remext() properly handles DBCS characters.

þseealso _defext() _getext() _nls_init() _splitpath()


þfunction remove()
þcompat C90

þheaders
#include <stdio.h>      /* use this */
#include <io.h>         /* or this */
þendheaders

þparam NAME
þprototype
int remove (const char *NAME);
þendprototype

    Delete a file.  NAME is a pointer to a string containing the name
    of the file to be deleted.  Under OS/2 and DOS, remove() and
    unlink() are equivalent.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þimplementation

    If the read-only attribute of the file is set, remove() sets errno
    to EPERM and returns -1.

    If the file is open in any process, remove() sets errno to EACCES
    and returns -1.

þseealso unlink()


þfunction rename()
þcompat C90

þheaders
#include <stdio.h>      /* use this */
#include <io.h>         /* or this */
þendheaders

þparam OLD_NAME NEW_NAME
þprototype
int rename (const char *OLD_NAME, const char *NEW_NAME);
þendprototype

    Rename the file or directory whose name is in the string pointed
    to by OLD_NAME to the name pointed to by NEW_NAME.  Moving a file
    to a different directory on the same drive is possible.  If a file
    or directory with the name pointed to by NEW_NAME already exists,
    rename() fails.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þimplementation

    If the file is open in any process, rename() sets errno to EACCES
    and returns -1.

þrestrictions

    rename() may set errno to EACCES instead of EEXIST if a file or
    directory with the name pointed to by NEW_NAME already exists.
    (Why does OS/2 return ERROR_ACCESS_DENIED instead of
    ERROR_FILE_EXISTS?)

þfunction _response()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam ARGCP ARGVP
þprototype
void _response (int *ARGCP, char ***ARGVP);
þendprototype

    Expand response files.  If you want response files
    (þtt{@filename}, the file þtt{filename} contains a list of
    arguments, one per line) to be expanded, call

þexample
_response (&argc, &argv);
þendexample

    at the beginning of main().  Response file arguments enclosed in
    double quotes won't be expanded.  If a response file cannot be
    opened, the argument is kept unchanged.

þseealso _envargs() main() _wildcard()


þfunction rewind()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM
þprototype
void rewind (FILE *STREAM);
þendprototype

    Move the file pointer of STREAM to the beginning of the file and
    clear the error and end-of-file indicators.

þseealso fseek()


þfunction rindex()
þcompat BSD
þheaders
#include <strings.h>
þendheaders

þparam STRING C
þprototype
char *rindex (const char *STRING, int C);
þendprototype

    Return a pointer to the last occurrence of the character C in the
    null-terminated string pointed to by STRING.  If there is no
    character C in the string pointed to by STRING, NULL is returned.
    If C is 0, a pointer to the terminating null character of the
    string pointed to by STRING is returned.

þreturnvalue

    See above.

þseealso index() strrchr()


þfunction rint() rintl()
þcompat C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
double rint (double X);
long double rintl (long double X);
þendprototype

    Return as floating-point number the integer that is nearest to X.
    þtt{rint (}þpa{X}þtt{)} is even if there's a tie, that is if

    rintl() uses the þtt{long double} format.

þtypewriter
  fabs (rint (þpa{X}) - þpa{X}) == 0.5
þendtypewriter

þreturnvalue

    See above.

þseealso ceil() floor() trunc()


þfunction rmdir()
þcompat BSD
þheaders
#include <stdlib.h>
þendheaders

þparam NAME
þprototype
int rmdir (const char *NAME);
þendprototype

    Remove the directory whose name is in the string pointed to by
    NAME.  Only one directory is removed in one step.  If the
    directory (or a subdirectory thereof) is the current working
    directory of a process, it cannot be removed.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso mkdir()


þfunction _rmtmp()
þcompat UNIX
þheaders
#include <stdio.h>
þendheaders

þprototype
int _rmtmp (void);
þendprototype

    Close and delete the files created by tmpfile() in the current
    working directory.  It must be used only in the directory in which
    tmpfile() created the temporary files.

þreturnvalue

    _rmtmp() returns the number of closed (and deleted) files.

þseealso tmpfile()


þfunction _rmutex_available()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
#include <sys/rmutex.h>
þendheaders

þparam SEM
þprototype
int _rmutex_available (_rmutex *SEM);
þendprototype

    Check if the _rmutex semaphore pointed to by SEM is available or
    owned, without changing the state of the semaphore and without
    blocking.  Return zero if the semaphore is owned, return a
    non-zero value if the semaphore is available.  Note that
    _rmutex_available() just returns a snapshot of the state of the
    semaphore; in presence of other threads or, in case of a shared
    semaphore, other processes, the state may change at any time, even
    before _rmutex_available() returns. This function can be used to
    avoid deadlock.

þreturnvalue

    _rmutex_available() returns a non-zero value if the semaphore is
    available.  _rmutex_available() returns 0 if the semaphore is
    owned.  The return value is undefined if the object pointed to by
    SEM has not been initialized by _rmutex_create().

þseealso _fmutex_available() _rmutex_close() _rmutex_create() _rmutex_open() _rmutex_release() _rmutex_request()


þfunction _rmutex_close() _rmutex_checked_close()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
#include <sys/rmutex.h>
þendheaders

þparam SEM
þprototype
unsigned _rmutex_close (_rmutex *SEM);
void _rmutex_checked_close (_rmutex *SEM);
þendprototype

    Close an _rmutex semaphore.  SEM should point to an _rmutex object
    initialized by _rmutex_create().  If there have been þpa{N} calls
    to þhpt{_rmutex_open()} for this semaphore, þpa{N}+1 calls to
    _rmutex_close() are required to destroy the semaphore, one call
    for þhpt{_rmutex_create()} and one call per _rmutex_open().  The
    semaphore can no longer be used after it has been destroyed.

    _rmutex_checked_close() does not return an error code; it calls
    abort() on failure.

þreturnvalue

    _rmutex_close() returns 0 if successful.  Otherwise,
    _rmutex_close() returns an OS/2 error code defined in <os2.h> such
    as ERROR_INVALID_HANDLE.  Under DOS, _rmutex_close() always
    returns 0.

þseealso abort() atexit() _fmutex_close() _rmutex_available() _rmutex_create() _rmutex_open() _rmutex_release() _rmutex_request()


þfunction _rmutex_create() _rmutex_checked_create()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
#include <sys/rmutex.h>
þendheaders

þparam SEM FLAGS
þprototype
unsigned _rmutex_create (_rmutex *SEM, unsigned FLAGS);
void _rmutex_checked_create (_rmutex *SEM, unsigned FLAGS);
þendprototype

    Create an _rmutex semaphore.  SEM points to the _rmutex object to
    be initialized.  The semaphore is local to the process if FLAGS is
    0.  The semaphore can be shared by multiple processes if FLAGS is
    _FMC_SHARED.  A shared _rmutex semaphore must be located in shared
    memory (that is, SEM must point to an object in shared memory).

    _rmutex_checked_create() does not return an error code; it calls
    abort() on failure.

þreturnvalue

    _rmutex_create() returns 0 if successful.  Otherwise,
    _rmutex_create() returns an OS/2 error code defined in <os2.h>
    such as ERROR_TOO_MANY_HANDLES.  Under DOS, _rmutex_create()
    always returns 0.

þseealso abort() _fmutex_create() _rmutex_available() _rmutex_close() _rmutex_dummy() _rmutex_open() _rmutex_release() _rmutex_request()


þfunction _rmutex_dummy()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
#include <sys/rmutex.h>
þendheaders

þparam SEM
þprototype
void _rmutex_dummy (_rmutex *SEM);
þendprototype

    Create a dummy _rmutex semaphore.  SEM points to the _rmutex
    object to be initialized.  Behavior is undefined if ownership of a
    dummy _rmutex semaphore is requested when the semaphore is owned.
    _rmutex_close() must not be called on a dummy _rmutex semaphore.

þseealso _fmutex_dummy() _rmutex_create()


þfunction _rmutex_open() _rmutex_checked_open()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
#include <sys/rmutex.h>
þendheaders

þparam SEM
þprototype
unsigned _rmutex_open (_rmutex *SEM);
void _rmutex_checked_open (_rmutex *SEM);
þendprototype

    Open an _rmutex semaphore.  SEM should point to an _rmutex object
    initialized by þhpt{_rmutex_create()}.  _rmutex_open() is used to
    obtain access to a shared _rmutex semaphore created by another
    process.  All threads of the process which called _rmutex_create()
    have access to the semaphore without calling _rmutex_open().  Call
    þhpt{_rmutex_close()} when you no longer need access to the
    semaphore.

    _rmutex_checked_open() does not return an error code; it calls
    abort() on failure.

þreturnvalue

    _rmutex_open() returns 0 if successful.  Otherwise, _rmutex_open()
    returns an OS/2 error code defined in <os2.h> such as
    ERROR_INVALID_HANDLE.  Under DOS, _rmutex_open() always returns 0.

þseealso abort() atexit() _fmutex_open() _rmutex_available() _rmutex_close() _rmutex_create() _rmutex_release() _rmutex_request()


þfunction _rmutex_release() _rmutex_checked_release()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
#include <sys/rmutex.h>
þendheaders

þparam SEM
þprototype
unsigned _rmutex_release (_rmutex *SEM);
void _rmutex_checked_release (_rmutex *SEM);
þendprototype

    Relinquish ownership of the _rmutex semaphore pointed to by SEM.
    If another thread blocks in þhpt{_rmutex_request()} for this
    semaphore, _rmutex_release() will unblock one of the blocking
    threads.  The semaphore should be owned when _rmutex_release() is
    called.  Though not strictly necessary, ownership of the semaphore
    should have been requested by the same thread.

    _rmutex_checked_release() does not return an error code; it calls
    abort() on failure.  Note that _rmutex_checked_release() is slower
    than _rmutex_release() because it is not inlined.

þreturnvalue

    _rmutex_release() returns 0 if successful.  Otherwise,
    _rmutex_release() returns an OS/2 error code defined in <os2.h>
    such as ERROR_TOO_MANY_HANDLES.

þseealso abort() __cxchg() _fmutex_release() _rmutex_available() _rmutex_close() _rmutex_create() _rmutex_open() _rmutex_request()


þfunction _rmutex_request() _rmutex_checked_request()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/fmutex.h>
#include <sys/rmutex.h>
þendheaders

þparam SEM FLAGS
þprototype
unsigned _rmutex_request (_rmutex *SEM, unsigned FLAGS);
void _rmutex_checked_request (_rmutex *SEM, unsigned FLAGS);
þendprototype

    Request ownership of the _rmutex semaphore pointed to by SEM.  If
    FLAGS is 0, _rmutex_request() returns ERROR_INTERRUPT if
    interrupted by a signal while blocking.  FLAGS is zero or a set of
    flags combined with the þtt{|} operator.  If FLAGS includes
    _FMR_IGNINT, _rmutex_request() does not return if a signal occurs
    while blocking.  If FLAGS includes _FMR_NOWAIT and the semaphore
    is owned, _rmutex_request() returns immediately ERROR_MUTEX_OWNED.

    _rmutex_checked_request() does not return an error code; it calls
    abort() on failure.  Note that _rmutex_checked_request() is slower
    than _rmutex_request() because it is not inlined.

    If the semaphore is available, it will be set to owned and
    _rmutex_request() will return immediately.  If the semaphore is
    owned, _rmutex_request() will block while the semaphore is owned.
    When þhpt{_rmutex_release()} is called for the semaphore, one of
    the threads blocking in _rmutex_request() for this semaphore will
    wake up and gain ownership of the semaphore.

    Note that ownership of an _rmutex semaphore is not tied to a
    thread, that is, it's not a thread which owns the semaphore.  This
    is in contrast to OS/2's mutex semaphores (HMTX).  Deadlock will
    occur if _rmutex_request() is called twice for the same semaphore
    by the same thread without an intervening call to
    _rmutex_release().  This fact is important to keep in mind in
    presence of signals.  Signal handlers must not request semaphores
    which can be owned by the interrupted code.  You might want to
    block signals before requesting ownership of an _rmutex semaphore.

þreturnvalue

    _rmutex_request() returns 0 if successful.  Otherwise,
    _rmutex_request() returns an OS/2 error code defined in <os2.h>
    such as ERROR_INTERRUPT.

þrestrictions

    Under DOS, _rmutex_request() and _rmutex_checked_request() crash
    if the semaphore is already owned.

þseealso abort() __cxchg() _fmutex_request() _rmutex_available() _rmutex_close() _rmutex_create() _rmutex_open() _rmutex_release()


þfunction sbrk()
þcompat UNIX
þheaders
#include <stdlib.h>
þendheaders

þparam INCR
þprototype
void *sbrk (int INCR);
þendprototype

    Change memory allocation by INCR bytes.  If INCR is positive, the
    memory limit is increased.  If INCR is negative, the memory limit
    is decreased.  On success, sbrk() returns the previous memory
    limit.  Otherwise, -1 cast as pointer is returned and errno set to
    ENOMEM.  Please don't use sbrk() -- use malloc() instead for
    memory allocation.

    If non-contiguous memory allocation with monotonous addresses
    (_UF_SBRK_MONOTONOUS) has been enabled with _uflags(), sbrk() may
    allocate non-contiguous memory.  In that case, sbrk() with
    non-negative argument returns the base address of the newly added
    memory area.  Any memory in the gap between the previous memory
    limit and the base address returned by sbrk() is not accessible.
    Setting back the memory limit into a gap is not possible.  If
    non-contiguous memory allocation with arbitrary addresses
    (_UF_SBRK_ARBITRARY) has been enabled with _uflags(), sbrk() may
    allocate non-contiguous memory; the memory object may even be at a
    lower address than the previous one.  In both cases, at most one
    memory object can be deallocated with sbrk() at a time, that is,
    you cannot reset the break address with sbrk() to an address
    outside the most recently allocated memory object.  However, you
    can deallocate the most recently allcoated memory object by
    resetting the break address to the start of the that memory
    object; after doing so, sbrk(0) will return the break address of
    the memory object which became the top one.

    Currently, there are some restrictions when using a non-contiguous
    memory: emxbind cannot create a preloaded executable with more
    than one heap object.  fork() fails if there is more than one heap
    object.

þreturnvalue

    See above.

þseealso brk() fork() malloc() _uflags() ulimit()

þsamplecode
/* Allocate memory with sbrk().  This function fails if sbrk()
   does not return contiguous memory.  Return a pointer to the
   new memory area.  Return NULL on error.  This function assumes
   that no other thread calls sbrk(). */

void *more_memory (size_t n)
{
  oid *prev, *base;

  if ((int)n < 0)               /* Check for overflow */
    return NULL;
  prev = sbrk (0);              /* Get current memory limit */
  if (prev == (void *)-1)
    return NULL;                /* Error */
  base = sbrk ((int)n);         /* Allocate memory */
  if (base == (void *)-1)
    return NULL;                /* Error */
  if (prev != base)             /* Non-contiguous? */
    {
      sbrk (-(int)n);           /* Free non-contiguous memory */
      return NULL;              /* Failure */
    }
  return base;                  /* Success */
}
þendsamplecode


þfunction scanf()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam FORMAT <width> <size> <type>
þprototype
int scanf (const char *FORMAT, ...);
þendprototype

    The stdin stream is read and input is parsed according to the
    format string pointed to by FORMAT.  For each field in the format
    string there must be a pointer to the location receiving the
    value.  The pointers are passed after the FORMAT argument.

    Whitespace (any number of spaces) in the format string matches
    whitespace (any number of spaces, including zero) in the input.
    All other characters except for þtt{%} are compared to the input.
    Parsing ends when a mismatch is encountered.  þtt{%%} in the
    format string matches þtt{%} in the input.  A þtt{%} which is not
    followed by another þtt{%} or the end of the string starts a field
    specification.  The field in the input is interpreted according to
    the field specification.  For most field types, whitespace is
    ignored at the start of a field.  Field specifications have the
    format

þindent
  þsy{%[*][<width>][<size>]<type>}
þendindent

    where items in brackets are optional.  If the þtt{*} is present, the
    value is not assigned.  No pointer will be fetched from the
    argument list and the value is ignored.

    <width> is a positive integral decimal number specifying the maximum
    field width.  At most this many characters are read for this
    field.

    <size> is either þtt{h} for a þtt{short} type (þtt{h} is available
    for the þtt{d}, þtt{i}, þtt{o}, þtt{u}, and þtt{x} conversions and
    for þtt{n}), þtt{l} for a þtt{long} type (þtt{l} is available for
    the þtt{d}, þtt{i}, þtt{o}, þtt{u}, and þtt{x} conversions and for
    þtt{n}) or the þtt{double} type (þtt{l} is also available for the
    þtt{e}, þtt{f}, and þtt{g} conversions) or þtt{L} for the þtt{long
    double} type (þtt{L} is available for the þtt{e}, þtt{f}, and
    þtt{g} conversions).  If <size> is omitted, the default size is
    used.

    <type> is one of the following characters:

þlist
þitem þtt{c}

    Character (þtt{char}).  Whitespace is not skipped.  If a field
    width is specified, that many characters are read and assigned,
    without a terminating null character (þtt{char[]}).  If no field
    width is specified, one character will be read and assigned.

þitem þtt{d}

    Signed decimal integer (þtt{int}).  þtt{%hd} is used for þtt{short
    int}, þtt{%ld} is used for þtt{long int} and þtt{%Ld} is used for
    þtt{long long int}.

þitem þtt{e f g E F G}

    Floating-point number (þtt{float}).  þtt{%le} etc. is used for
    þtt{double}, þtt{%Le} etc. is used for þtt{long double}.  scanf()
    accepts the same format of float-point numbers as þhpt{strtod()}.
    The decimal point character of the current locale is used.

þitem þtt{i}

    Decimal, octal or hexadecimal signed integer (þtt{int}).  þtt{%hi}
    is used for þtt{short int}, þtt{%li} is used for þtt{long int} and
    þtt{%Li} is used for þtt{long long}.  The base is 16 if the number
    begins with þtt{0x} or þtt{0X}.  The base is 8 if the number
    begins with þtt{0} (not followed by an þtt{x} or þtt{X}).
    Otherwise, the base is 10.

þitem þtt{n}

    Number of characters read so far (þtt{int}).  No input is taken.
    The number of characters read so far is assigned to the integer
    (unless assignment is suppressed with the þtt{*} flag).  Use
    þtt{%hn} to assign to a þtt{short int}, þtt{%ln} to assign to a
    þtt{long int} or þtt{%Ln} to assign to a þtt{long long int}.

þitem þtt{o}

    Octal unsigned integer (þtt{unsigned}).  þtt{%ho} is used for
    þtt{unsigned short}, þtt{%lo} is used for þtt{unsigned long int}
    and þtt{%Lo} is used for þtt{unsigned long long int}.
    The input may contain a sign character.

þitem þtt{p}

    Pointer (þtt{void *}).  The input format of a pointer is
    implementation-dependent.  In this implementation, þtt{p} is equivalent
    to þtt{x}.

þitem þtt{s}

    Read and assign characters until the field width is exhausted or
    hitting whitespace (þtt{char[]}).  The destination array must be
    big enough to hold all the characters.  Note that initial
    whitespace is skipped.  Perhaps you want to use þtt{%[...]}
    instead of þtt{%s}.

þitem þtt{u}

    Unsigned decimal integer (þtt{unsigned int}).  þtt{%hu} is used
    for þtt{unsigned short int}, þtt{%lu} is used for þtt{unsigned
    long int} and þtt{%Lu} is used for þtt{unsigned long long int}.
    The input may contain a sign character.

þitem þtt{x}

    hexadecimal integer (þtt{unsigned int}).  þtt{%hx} is used for
    þtt{unsigned short int}, þtt{%lx} is used for þtt{unsigned long
    int} and þtt{%Lx} is used for þtt{unsigned long long int}. The
    input may contain a sign character.

þitem þtt{[}

    Null-terminated string (þtt{char[]}).  White space is not skipped.
    þtt{[} is followed by a set of characters which is delimited by
    þtt{]}.  The field ends at the first character not in the
    character set þtt{[...]}.  If þtt{[^...]} is used, the field ends
    at the first character in that set.  The field also ends when the
    field width is exhausted.  The set contains all characters listed
    in the brackets.  To include a þtt{]} in the set, make it the
    first character of the set.  You can specify a range of characters
    by listing the first and the last character, separated by a
    þtt{-}.  To include a þtt{-} in the set, make it the last
    character of the set.  The destination array must be big enough to
    hold all the characters.

þendlist

    scanf() puts back into the stream at most one conflicting
    character.  In consequence, some character sequences acceptable to
    strtod(), strtof(), strtol(), strtold(), and strtoul() are not
    acceptable to scanf().

þreturnvalue

    If successful, scanf() returns the number of fields converted.  On
    error, scanf() returns EOF.

þimplementation

    <size> can be þtt{L} for þtt{long long} types (þtt{L} is available
    for the þtt{d}, þtt{i}, þtt{o}, þtt{u}, and þtt{x} conversions and
    for þtt{n})).

þhints

    To read user input, you should use fgets() and sscanf() instead of
    scanf() because scanf() doesn't stop reading at the end of the
    line.

    Use þtt{%lf} for variables of type þtt{double}.  Contrast with
    printf().

þseealso fgets() fread() fscanf() printf() setlocale() sscanf() strptime() strtod() strtol() vscanf()

þsamplecode
int year, month, day;
...
if (scanf ("%d/%d/%d", &year, &month, &day) == 3)
  {
    ...
  }
þendsamplecode


þfunction _scrsize()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam DST
þprototype
void _scrsize (int *DST);
þendprototype

    Retrieve the screen (window) size.  The number of text columns
    (width) is stored to þpa{DST}þtt{[0]}, the number of text rows
    (height) is stored to þpa{DST}þtt{[1]}.

þseealso v_dimen()


þfunction _searchenv()
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þparam NAME VAR PATH
þprototype
void _searchenv (const char *NAME, const char *VAR, char *PATH);
þendprototype

    Search a file in the directories listed in an environment
    variable.  First, the file name pointed to by NAME is tried as is.
    If that file does not exist, the directories listed in the
    environment variable whose name is in the string pointed to by VAR
    are searched.  If the file is found, the constructed path name
    (either the string pointed to by NAME or a directory plus the
    string pointed to by NAME) will be copied to the array pointed to
    by PATH.  If the file is not found, the empty string will be
    stored to the array pointed to by PATH.

    _searchenv() properly handles DBCS characters.

þseealso getenv() _nls_init() _path()


þfunction _seek_hdr()
þcompat emx
þheaders
#include <io.h>
þendheaders

þparam HANDLE
þprototype
int _seek_hdr (int HANDLE);
þendprototype

    Move the file pointer of HANDLE to the a.out header of an
    executable file (a.out or bound .exe).  _seek_hdr() assumes that
    the file pointer points to the beginning of the header (ie, the
    beginning of the file).  If no header is found, the file pointer
    will be repositioned to the original position.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error (errno is set)
þenddescription

þseealso _fseek_hdr()


þfunction select()
þcompat UNIX *
þheaders
#include <sys/select.h>
þendheaders

þparam NFDS READFDS WRITEFDS EXCEPTFDS TIMEOUT
þprototype
int select (int NFDS, fd_set *READFDS, fd_set *WRITEFDS, fd_set *EXCEPTFDS,
            struct timeval *TIMEOUT);
þendprototype

    Wait for a file handle to become ready for reading, writing, or
    until an exceptional situation exists for a file handle, or until
    a time-out expires.  `Ready for reading' means that a call to
    read() in blocking mode (O_NONBLOCK not being set) will return
    immediately, that is, will transfer data and return a positive
    number, will transfer no data and return zero, or will report an
    error (except EAGAIN alias EWOULDBLOCK) by returning -1.  `Ready
    for writing' means that a call to write() in blocking mode will
    return immediately, that is, will transfer data and return a
    positive number, will transfer no data and return zero, or will
    report an error (except EAGAIN alias EWOULDBLOCK) by returning -1.
    `Exceptional situations' means pending errors for sockets.  No
    other exceptional situations are currently defined.

    select() returns as soon as any handle in the set pointed to by
    READFDS is ready for reading, or a handle in the set pointed to by
    WRITEFDS is ready for writing, or an exceptional situation exists
    for a handle in the set pointed to by EXCEPTFDS.  READFDS,
    WRITEFDS, and EXCEPTFDS can each be NULL.  If TIMEOUT is NULL,
    select() waits indefinitely.  Otherwise, waiting terminates after
    the time-out pointed to by TIMEOUT expired.  NFDS is the number of
    handles to be checked.

    select() updates the objects pointed to by READFDS, WRITEFDS, and
    EXCEPTFDS to include only the handles which are ready for reading,
    writing, or for which an exceptional situation exists,
    respectively, and returns the number of those handles.

    Some implementations of select() update the object pointed to by
    TIMEOUT to reflect the amount of time remaining.  The emx
    implementation of select() currently doesn't do this and probably
    won't do this.

    The following macros are available for handling the bitstrings
    used by select():

þlist

þitem þtt{FD_ZERO(}þpa{S}þtt{)}

    clear all bits of þpa{S}

þitem þtt{FD_SET(}þpa{N}þtt{,}þpa{S)}

    set bit þpa{N} in þpa{S}

þitem þtt{FD_CLR(}þpa{N}þtt{,}þpa{S}þtt{)}

    clear bit þpa{N} in þpa{S}

þitem þtt{FD_ISSET(}þpa{N}þtt{,}þpa{S)}

    return a non-zero value iff bit þpa{N} is set in þpa{S}

þendlist

    The FD_SETSIZE macro specifies the number of file handles in an
    fd_set object.  The default value is 256.  To increase the number
    of file descriptors in fd_set, define FD_SETSIZE before including
    <sys/types.h> and <sys/select.h>.  The FD_ZERO macro and
    assignment of fd_set objects use the size of the object; in
    consequence, you must be careful when passing pointers to fd_set
    objects between modules which have been compiled with different
    values for FD_SETSIZE (libraries!).

    select() is implemented for the following types of handles:

þitemize

þitem

    Standard input handles (keyboard) with IDEFAULT not set (DOS:
    handle 0 only).  Note that if ICANON is set, read() has to wait
    until the line is completed.  If IDEFAULT is set (that's the
    initial setting), standard input handles are reported as being
    ready

þitem

    Pseudo TTYs of xf86sup.sys

þitem

    Named pipes.  Named pipes are always reported to be ready for
    writing

þitem

    Pipes created with pipe() by programs using emx.dll; such pipes
    are always reported to be ready for writing

þitem

    Sockets under OS/2

þitem
    ASYNC devices (such as þtt{COM1}) under OS/2

þitem

    All file handles under DOS; regular files are reported to be ready
    for reading if the file pointer is not at the end of the file --
    this behavior may change in the future: regular files should be
    reported to be always ready for reading

þenditemize

    All handle types not supported by select() are reported to be
    ready for reading and ready for writing and having no exceptional
    situation pending.

    The þtt{timeval} structure is defined as follows:

þexample
struct timeval
{
  long tv_sec;
  long tv_usec;
};
þendexample

    þtt{tv_sec} and þtt{tv_usec} are the number of seconds and
    microseconds, respectively.

þreturnvalue
þdescription
þitem >0
    number of ready handles
þitem 0
    time out
þitem -1
    error
þenddescription

þrestrictions

    select() is not available with the system call library sys.lib
    (þhpt{-Zsys}).

þseealso ioctl() pipe()


þfunction setbuf()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM BUFFER
þprototype
int setbuf (FILE *STREAM, char *BUFFER);
þendprototype

    Associate the buffer of size BUFSIZ pointed to by BUFFER with
    STREAM.  This must be done before the file has been read or
    written.  If BUFFER is NULL, the file is unbuffered.  You should
    use setvbuf() instead.

þreturnvalue

þdescription
þitem 0
    success
þitem EOF
    error
þenddescription

    BSD setbuf() seems to have an þtt{int} return value, therefore emx
    setbuf() has an þtt{int} return value.  This should not break
    programs which expect þtt{void setbuf()}.

þseealso setbuffer() setvbuf()


þfunction setbuffer()
þcompat UNIX
þheaders
#include <stdio.h>
þendheaders

þparam STREAM BUFFER SIZE
þprototype
int setbuffer (FILE *STREAM, char *BUFFER, size_t SIZE);
þendprototype

    Associate the buffer of size SIZE pointed to by BUFFER with
    STREAM.  This must be done before the file has been read or
    written.  If BUFFER is NULL, the file is unbuffered.  You should
    use setvbuf() instead.

þreturnvalue

þdescription
þitem 0
    success
þitem EOF
    error
þenddescription

    BSD setbuffer() seems to have an þtt{int} return value, therefore
    emx setbuffer() has an þtt{int} return value.  This should not
    break programs which expect þtt{void setbuffer()}.

þseealso setvbuf()


þfunction setjmp()
þcompat C90
þheaders
#include <setjmp.h>
þendheaders

þparam HERE
þprototype
int setjmp (jmp_buf HERE);
þendprototype

    Save the current stack context in HERE and return 0.  Later, you
    can continue at this point by calling longjmp().  When execution
    continues at setjmp() after calling longjmp(), the second argument
    of longjmp() is returned, which is always non-zero (if zero is
    used as second argument of longjmp(), it will be turned into 1).

    setjmp() may be implemented as macro.  setjmp() can be used only
    in the following contexts:

þitemize
þitem
  the entire controlling expression of a þtt{do}, þtt{if},
  þtt{switch}, or þtt{while} statement
þitem
  the operand to the þtt{!} operator if the resulting expression is
  the entire controlling expression of one of the statements listed
  above
þitem
  the operand of a relational or equality operator if the resulting
  expression is the entire controlling expression of one of the
  statements listed above and the other operand is an integral
  constant expression
þitem
  the entire expression of an expression statement.
þenditemize

þreturnvalue

    setjmp() returns 0 when directly called.  When returning from a
    call to longjmp(), setjmp() returns a non-zero value (supplied by
    the call to longjmp()).

þimplementation

    The restrictions on the contexts in which setjmp() can be used do
    not apply.

þhints

    As jmp_buf is an array type, the þtt{&} operator need not be
    applied.

þseealso longjmp() siglongjmp() sigsetjmp()


þfunction setlocale()
þcompat C90
þheaders
#include <locale.h>
þendheaders

þparam CATEGORY LOCALE
þprototype
char *setlocale (int CATEGORY, const char *LOCALE);
þendprototype

    Select a locale.  Either the entire locale or a portion of the
    locale is set, depending on CATEGORY:

þlist
þitem LC_ALL

    Set the entire locale, including categories LC_COLLATE, LC_CTYPE,
    LC_MONETARY, LC_NUMERIC and LC_TIME.

þitem LC_COLLATE

    Control the behavior of strcoll() and strxfrm().

þitem LC_CTYPE

    Control the behavior of isalnum(), isalpha(), iscntrl(),
    isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(),
    tolower(), toupper(), mblen(), mbstowcs(), mbtowc(), wcstombs()
    and wctomb().  This also affects the interpretation of multibyte
    character format strings by printf(), scanf() and strftime().
    Note that isdigit() and isxdigit() are not affected.

þitem LC_MONETARY

    Set the information related to formatting of monetary quantities.
    This affects the contents of the structure returned by
    localeconv().

þitem LC_NUMERIC

    Select the decimal point character for atof(), _atofl(), gcvt(),
    printf(), scanf(), strtod(), strtof(), and strtold().  Set the
    information related to formatting of numeric quantities.  This
    affects the contents of the structure returned by localeconv().

þitem LC_TIME

    Control the behavior of strftime().

þendlist

    If LOCALE points to the empty string þtt{""}, the value of the
    environment variable LANG is taken instead.  If LANG is not set,
    þtt{"C"} is used for LOCALE.  þtt{"C"} is the initial locale at
    program startup.  It provides the usual C conversions.

    Other possible values of LOCALE are þtt{LC_C_FRANCE},
    þtt{LC_C_GERMANY}, þtt{LC_C_ITALY}, þtt{LC_C_SPAIN}, þtt{LC_C_UK},
    þtt{LC_C_USA}, þtt{"de_de"}, þtt{"en_us"}, and þtt{"en_gb"}.

    If LOCALE is a null pointer, a pointer to the string associated
    with CATEGORY for the currently selected locale is returned.  That
    string can be used as LOCALE with CATEGORY for restoring that
    locale.  If CATEGORY is LC_ALL and different locale strings are
    associated with the categories, a pointer to a string is returned
    which selects those locales when used with LC_ALL.

    All threads of a process share the same locale.

þreturnvalue

    setlocale() returns NULL on error.  Otherwise, it returns a
    pointer to the string associated with CATEGORY for the new locale
    (or the current one if LOCALE is NULL).  The string must not be
    modified by the program; it may be overwritten by a subsequent
    call to setlocale().

þrestrictions

    Currently, information associated with LC_COLLATE and LC_CTYPE is
    ignored.  Moreover, strftime() always assumes that code page 850
    is in effect.

þseealso isupper() localeconv() mbtowc() strcoll() strftime() strxfrm()


þfunction setmode()
þcompat PC
þheaders
#include <io.h>
#include <fcntl.h>
þendheaders

þparam HANDLE MODE
þprototype
int setmode (int HANDLE, int MODE);
þendprototype

    Change the text/binary mode of a file handle.  MODE must be either
    O_BINARY or O_TEXT.

    þbf{Note:} Use _fsetmode() to change the mode of a stream.

þreturnvalue

  If there's an error, setmode() returns -1 and sets errno to EBADF or
  EINVAL otherwise setmode() returns the previous mode, that is,
  O_BINARY or O_TEXT.

þseealso _fsetmode() open()


þfunction _setsyserrno()
þcompat emx *
þheaders
#include <stdlib.h>
þendheaders

þparam CODE
þprototype
int _setsyserrno (int CODE);
þendprototype

    Make the next _syserrno() call return CODE.  This function returns
    the OS/2 or DOS error code for the last system call of the current
    thread, like _syserrno().

þreturnvalue

    See above.  If _setsyserrno() is not implemented, -1 will returned
    without setting errno.

þrestrictions

    _setsyserrno() is not implemented under DOS.  _setsyserrno() is
    not supported with the system call library sys.lib (þhpt{-Zsys}).

þseealso errno _syserrno()

þfunction settimeofday()
þcompat BSD
þheaders
#include <sys/time.h>
þendheaders

þparam TP TZP
þprototype
int settimeofday (const struct timeval *TP, const struct timezone *TZP);
þendprototype

    Set the system time and timezone.  If TP is not NULL, the system
    time is set to the time (Coordinated Universal Time) specified by
    the structure pointed to by TP.  If TZP is not NULL, the timezone
    is set according to the structure pointed to by TZP.

    The þtt{timeval} structure is defined as follows:

þexample
struct timeval
{
  long tv_sec;
  long tv_usec;
};
þendexample

    þtt{tv_sec} and þtt{tv_usec} are the number of seconds and
    microseconds, respectively, elapsed since 00:00:00 1-Jan-1970 UTC.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þrestrictions

    Setting the timezone is not implemented, TZP must be a null
    pointer.  The real time clock is not set under DOS versions
    earlier than 3.3.

þseealso gettimeofday() ftime() time()


þfunction setvbuf()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STREAM BUFFER MODE SIZE
þprototype
int setvbuf (FILE *STREAM, char *BUFFER, int MODE, size_t SIZE);
þendprototype

    Set the buffering mode of STREAM to MODE.  The array of SIZE bytes
    pointed to by BUFFER may be used instead of a buffer allocated by
    setvbuf() if BUFFER is not NULL.  Available modes are:

þdescription

þitem _IONBF

    the file is unbuffered, BUFFER and SIZE are always ignored

þitem _IOFBF

    the file is full buffered

þitem _IOLBF

    the file is line buffered

þenddescription

    The file must not have been read or written since it was opened.

þreturnvalue

    On success, setvbuf() returns 0.  On failure, setvbuf() returns a
    non-zero value.

þimplementation

    This implementation of setvbuf() uses BUFFER unless MODE is _IONBF
    or SIZE is invalid.  If SIZE is invalid, a buffer of BUFSIZ bytes
    is used.

    For reading a file, _IOFBF and _IOLBF are equivalent.  Each time a
    newline character is written to a line-buffered file, the buffer
    is flushed.  The buffer is also flushed if it becomes full while
    writing.  The buffer is filled by reading from the disk file (or
    device) if the buffer becomes empty while reading.

þseealso fflush() fputs() fwrite()


þfunction sigaction()
þcompat POSIX.1 *
þheaders
#include <signal.h>
þendheaders

þparam SIG IACT OACT
þprototype
int sigaction (int SIG, const struct sigaction *IACT,
               struct sigaction *OACT);
þendprototype

    Examine and/or specify the action associated with the signal SIG.
    If IACT is not NULL, it points to a structure specifying the
    action to be associated with the signal SIG.  If IACT is NULL, the
    action for signal SIG won't be changed.  If OACT is not NULL, the
    previous action for signal SIG will be stored to the object
    pointed to by OACT.

    The þtt{sigaction} structure is defined as follows:

þexample
struct sigaction
{
  void (*sa_handler)(int sig);
  sigset_t sa_mask;
  int sa_flags;
};
þendexample

    sa_handler can be SIG_DFL (to get the default action), SIG_IGN (to
    ignore the signal), or the address of a signal-catching function
    (signal handler).

    sa_mask is a set of signals to be blocked prior to calling the
    signal-catching function.  sa_mask is ignored for the `emx' and
    `System V' signal models.

    Every object of type sigset_t should be initialized at least once
    with either sigemptyset() or sigfillset() before any use.  When
    using an uninitialized object of type sigset_t, the results are
    undefined.

    sa_flags is a set of flag bits used to modify the behavior of the
    signal SIG.  The following flag bits are available:

þdescription
þitem SA_NOCLDSTOP

    Do not generate SIGCHLD when a child process stops.

þitem SA_SYSV

    Use the `System V' signal model for the signal SIG: before calling
    a signal-catching function, reset the signal action to SIG_DFL,
    don't block the signal, and ignore sa_mask.

þitem SA_ACK

    Use the `emx' signal model for the signal SIG: ignore sa_mask, use
    SIG_ACK for unblocking the signal.

þenddescription

    In a multithread program, sigaction() examines and sets the
    signal action for the thread in which it is called.  Signal action
    settings are private to each thread.

    If the previous signal action for signal SIG has been set by
    signal(), the value of the object pointed to by OACT is
    unspecified; however, if that object is subsequently used for
    setting the signal action with sigaction(), handling of the signal
    is as if the original call to signal() were repeated.

    See section þref{signal processing} for details on
    þhpt{signal processing}.

þreturnvalue

    If successful, sigaction() returns 0.  Otherwise sigaction()
    sets errno and returns -1.

þerrors

þdescription
þitem EINVAL

    SIG is not a valid signal number or an attempt was made to catch a
    signal that cannot be caught or to ignore a signal that cannot be
    ignored.

þenddescription

þimplementation

    The SA_ACK and SA_SYSV flag bits of sa_flags are emx extensions.

þrestrictions

    The SA_NOCLDSTOP flag bit of sa_flags is ignored as stopped
    processes are not supported (except for ptrace()).

þseealso raise() kill() sigemptyset() signal() sigpending() sigprocmask()

þsamplecode
void sig_cleanup (int signo)
{
  cleanup ();
  printf ("Process terminated by signal %d\n", signo);
  exit (99);
}

void sig_init (void)
{
  struct sigaction sa;

  sa.sa_handler = sig_cleanup;
  sa.sa_flags = 0;
  sigemptyset (&sa.sa_mask);
  sigaction (SIGINT, &sa, NULL);
}
þendsamplecode


þfunction sigaddset() sigdelset()
þcompat POSIX.1 *
þheaders
#include <signal.h>
þendheaders

þparam SET SIG
þprototype
int sigaddset (sigset_t *SET, int SIG);
int sigdelset (sigset_t *SET, int SIG);
þendprototype

    sigaddset() adds the signal SIG to the set of signals pointed to
    by SET.

    sigdelset() deletes the signal SIG from the set of signals pointed
    to by SET.

    Every object of type sigset_t should be initialized at least once
    with either sigemptyset() or sigfillset() before any use.  When
    using an uninitialized object of type sigset_t, the results are
    undefined.

þreturnvalue

    If successful, sigaddset() and sigdelset() return 0.  Otherwise,
    these functions set errno and return -1.

þerrors

þdescription
þitem EINVAL

    SIG is not a valid signal number.

þenddescription

þseealso sigemptyset() sigfillset() sigismember()


þfunction sigemptyset() sigfillset()
þcompat POSIX.1 *
þheaders
#include <signal.h>
þendheaders

þparam SET
þprototype
int sigemptyset (sigset_t *SET);
int sigfillset (sigset_t *SET);
þendprototype

    sigemptyset() initializes the object pointed to by SET to an empty
    set of signals.

    sigfillset() initializes the object pointed to by SET to a signal
    set which includes all signals.

    Every object of type sigset_t should be initialized at least once
    with either sigemptyset() or sigfillset() before any use.  When
    using an uninitialized object of type sigset_t, the results are
    undefined.

þreturnvalue

    If successful, sigemptyset() and sigfillset() return 0.  Otherwise,
    these functions set errno and return -1.

þseealso sigaction() sigaddset() sigdelset() sigprocmask() sigismember()


þfunction sigismember()
þcompat POSIX.1 *
þheaders
#include <signal.h>
þendheaders

þparam SET SIG
þprototype
int sigismember (const sigset_t *SET, int SIG);
þendprototype

    sigismember() tests whether the signal SIG is a member of the set
    of signals pointed to by SET.

    Every object of type sigset_t should be initialized at least once
    with either sigemptyset() or sigfillset() before any use.  When
    using an uninitialized object of type sigset_t, the results are
    undefined.

þreturnvalue

    sigismember() returns 1 if the signal SIG is a member of the set
    of signals pointed to by SET, or 0 if the signal SIG is not a
    member of the set of signals pointed to by SET.  On error,
    sigismember() sets errno and returns -1.

þerrors

þdescription
þitem EINVAL

    SIG is not a valid signal number.

þenddescription

þseealso sigaddset() sigdelset() sigemptyset() sigfillset()


þfunction siglongjmp()
þcompat POSIX.1
þheaders
#include <setjmp.h>
þendheaders

þparam THERE N SAVEMASK
þprototype
void siglongjmp (sigjmp_buf THERE, int N);
þendprototype

    Restore the context saved in THERE by sigsetjmp() and -- if the
    SAVEMASK argument of sigsetjmp() was non-zero -- restore the
    signal mask saved by sigsetjmp() .  siglongjmp() does a non-local
    þtt{goto}, causing execution to continue at the sigsetjmp() call
    which most recently saved a stack context in THERE.  sigsetjmp()
    will return N.  If N is 0, sigsetjmp() will return 1.  When
    calling siglongjmp() in a signal handler or in a function called
    by a signal handler (that is, while a signal handler is active),
    the signal handler will be unwound, that is, it is assumed that
    the signal handler doesn't return.  siglongjmp() must be called in
    the same thread as the most recent call to sigsetjmp() for THERE.
    Moreover, the function which most recently called sigsetjmp() to
    save a stack context in THERE must still be active.  Don't expect
    local variables to be preserved unless declared volatile.

    As sigjmp_buf is an array type, the þtt{&} operator need not be
    applied.

þseealso longjmp() setjmp() sigaction() sigprocmask() sigsetjmp() signal()


þfunction signal()
þcompat C90
þheaders
#include <signal.h>
þendheaders

þparam SIG HANDLER
þprototype
void (*signal (int SIG, void (*HANDLER)()))(int SIG);
þendprototype

    Set the signal action associated with signal SIG.  HANDLER can be
    SIG_DFL (to get the default action), SIG_IGN (to ignore the
    signal), or the address of a signal-catching function (signal
    handler).

    On delivery of the signal, the signal number is passed as the only
    argument to the signal-catching function.  Before the
    signal-catching funcion is called, the signal is blocked or the
    signal action is reset to SIG_DFL, depending on the signal
    processing model.

    The action associated with SIGKILL cannot be changed.

    In a multithread program, signal() sets a signal handler for
    the thread in which it is called.  The set of signal handlers is
    private to each thread.

    On delivery, the signal is blocked before calling the signal
    handler, if the `emx' signal model is used and the signal is
    caught (that is, a signal handler is installed).  To unblock the
    signal SIG, call

þexample
signal (sig, SIG_ACK)
þendexample

    See section þref{signal processing} for details on
    þhpt{signal processing}.

þreturnvalue

    If successful, signal() returns the previous signal action
    (SIG_IGN or SIG_DFL or the address of a signal handler) associated
    with signal SIG.  On failure, signal() returns SIG_ERR.  If
    HANDLER is SIG_ACK, signal() returns the current signal action
    associated with the signal SIG.

þseealso abort() kill() raise() sigaction() sigprocmask()


þfunction signbit()
þcompat C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
int signbit (float X);
int signbit (double X);
int signbit (long double X);
þendprototype

    Determine the sign of X.  The argument X must be of a
    floating-point type.

þreturnvalue

    signbit() returns a non-zero value if the sign of X is negative;
    signbit() returns 0 otherwise.

þseealso copysign() fpclassify() isfinite() isnan() isnormal()


þfunction sigpending()
þcompat POSIX.1 *
þheaders
#include <signal.h>
þendheaders

þparam SET
þprototype
int sigpending (sigset_t *SET);
þendprototype

    Store in the object pointed to by SET the set of signals that
    are blocked and pending.

    Every object of type sigset_t should be initialized at least once
    with either sigemptyset() or sigfillset() before any use.  When
    using an uninitialized object of type sigset_t, the results are
    undefined.

þreturnvalue

    If successful, sigpending() returns 0.  Otherwise sigpending()
    returns -1 and sets errno.

þseealso kill() raise() sigaction() sigprocmask() sigismember()

þsamplecode
int poll_sigint (void)
{
  sigset_t s;

  sigemptyset (&s);
  return (sigprocmask (&s) == 0
          && sigismember (&s, SIGINT) == 1);
}
þendsamplecode


þfunction sigprocmask()
þcompat POSIX.1 *
þheaders
#include <signal.h>
þendheaders

þparam HOW ISET OSET
þprototype
int sigprocmask (int HOW, const sigset_t *ISET, sigset_t *OSET);
þendprototype

    Examine and/or change the signal mask (set of blocked signals) of
    the calling process.  If ISET is not NULL, it points to a set of
    signals used to change the signal mask.  The following values are
    available for HOW to indicate how to modify the signal mask:

þdescription
þitem SIG_BLOCK

    Add the signals of the set pointed to by ISET to the set of
    blocked signals.  The resulting signal mask will be the union of
    the current signal mask and the signal set pointed to by ISET.

þitem SIG_UNBLOCK

    Remove the signals of the set pointed to by ISET from the set of
    blocked signals.  The resulting signal mask will be the
    intersection of the current signal mask and the complement of the
    signal set pointed to by ISET.

þitem SIG_SETMASK

    Replace the current signal mask with the signal set pointed to by
    ISET.

þenddescription

    SIGKILL cannot be blocked; any attempt to block SIGKILL is ignored
    by sigprocmask() without indication of an error.

    If ISET is NULL, the signal mask won't be changed.

    If OSET is not NULL, the previous signal mask will be stored in
    the object pointed to by OSET.

    If any unblocked signal is pending, at least one unblocked pending
    signal will be delivered before sigprocmask() returns.

    Every object of type sigset_t should be initialized at least once
    with either sigemptyset() or sigfillset() before any use.  When
    using an uninitialized object of type sigset_t, the results are
    undefined.

þreturnvalue

    If successful, sigprocmask() returns 0.  Otherwise sigprocmask()
    returns -1 and sets errno.

þerrors
þdescription
þitem EINVAL
    HOW is not SIG_BLOCK, SIG_UNBLOCK, or SIG_SETMASK
þenddescription

þseealso kill() raise() sigaction() sigemptyset() sigismember() siglongjmp() sigpending() sigsetjmp()

þsamplecode
void block_sigint (void)
{
  sigset_t s;

  sigemptyset (&s);
  sigaddset (&s, SIGINT);
  sigprocmask (SIG_BLOCK, &s, NULL);
}
þendsamplecode


þfunction sigsetjmp()
þcompat POSIX.1
þheaders
#include <setjmp.h>
þendheaders

þparam HERE SAVEMASK
þprototype
int sigsetjmp (sigjmp_buf HERE, int SAVEMASK);
þendprototype

    Save the current stack context in HERE and return 0.  If SAVEMASK
    is non-zero, also save the current signal mask (set of blocked
    signals) to HERE.  Later, you can continue at this point by
    calling siglongjmp().  When execution continues at sigsetjmp()
    after calling siglongjmp(), the second argument of siglongjmp() is
    returned, which is always non-zero (if zero is used as second
    argument of siglongjmp(), it will be turned into 1).

    sigsetjmp() must not be used in compliated expressions.

    As sigjmp_buf is an array type, the þtt{&} operator need not be
    applied.

þreturnvalue

    sigsetjmp() returns 0 when directly called.  When returning from a
    call to siglongjmp(), sigsetjmp() returns a non-zero value
    (supplied by the call to siglongjmp()).

þseealso longjmp() setjmp() siglongjmp() sigprocmask()


þfunction sigsuspend()
þcompat POSIX.1 *
þheaders
#include <signal.h>
þendheaders

þparam MASK
þprototype
int sigsuspend (const sigset_t *MASK);
þendprototype

    Replace the signal mask with the set of signals pointed to by MASK
    and then suspend the process until delivery of a signal for which
    a signal handler is installed.  sigsuspend() returns after the
    signal handler returns.  Before returning, sigsuspends() restores
    the signal mask to the set that existed prior to the sigsuspend()
    call.

    The process will be terminated (and sigsuspend() won't return) if
    an uncaught signal is delivered which terminates the process.

    SIGKILL cannot be blocked; any attempt to block SIGKILL is ignored
    by sigsuspend() without indication of an error.

    Every object of type sigset_t should be initialized at least once
    with either sigemptyset() or sigfillset() before any use.  When
    using an uninitialized object of type sigset_t, the results are
    undefined.

þreturnvalue

    sigsuspend() sets errno to EINTR and returns -1.

þrestrictions

    sigsuspend() is not implemented under DOS.

þseealso alarm() kill() pause() sigaction() sigemptyset() sigprocmask()


þfunction sleep()
þcompat POSIX.1
þheaders
#include <stdlib.h>
þendheaders

þparam SEC
þprototype
unsigned sleep (unsigned SEC);
þendprototype

    Suspend the calling process for SEC seconds or until an unblocked
    signal is caught.  SEC should not exceed 4294967.

þreturnvalue

    If interrupted by a caught signal, sleep() returns the number of
    remaining seconds.  Otherwise, sleep() returns 0.

þimplementation

    alarm() and SIGALRM don't interfer with the operation of sleep().

þrestrictions

    sleep() is also interrupted by ignored signals and, under OS/2, by
    blocked signals.

þseealso alarm() sigaction() signal() sigprocmask() _sleep2()


þfunction _sleep2()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam MILLISEC
þprototype
unsigned _sleep2 (unsigned MILLISEC);
þendprototype

    Suspend the calling process for MILLISEC milliseconds.  As the
    system clock is used for timing, the actual duration of the time
    interval depends on the granularity of the system clock.  The time
    interval is rounded up to the next clock tick.  Also note that
    calling _sleep2() involves an overhead.

    Delivery of a signal which is caught interrupts _sleep2().

þreturnvalue

    _sleep2() returns 0.

þrestrictions

    Under OS/2, sleep() is also interrupted by ignored signals and by
    blocked signals.  Under DOS, sleep() is not interrupted by
    signals.

þseealso alarm() sigaction() signal() sigprocmask() sleep()


þfunction _smutex_available()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/smutex.h>
þendheaders

þparam SEM
þprototype
int _smutex_available (volatile _smutex *SEM);
þendprototype

    Check if the _smutex semaphore pointed to by SEM is available or
    owned, without changing the state of the semaphore and without
    blocking.  Return zero if the semaphore is owned, return a
    non-zero value if the semaphore is available.  Note that
    _smutex_available() just returns a snapshot of the state of the
    semaphore; in presence of other threads or other processes having
    access to the semaphore, the state may change at any time, even
    before _smutex_available() returns. This function can be used to
    avoid deadlock.

þreturnvalue

    _smutex_available() returns a non-zero value if the semaphore is
    available.  _smutex_available() returns 0 if the semaphore is
    owned.

þseealso _smutex_release() _smutex_request()


þfunction _smutex_release()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/smutex.h>
þendheaders

þparam SEM
þprototype
void _smutex_release (volatile _smutex *SEM);
þendprototype

    Relinquish ownership of the _smutex semaphore pointed to by SEM.
    Unblocking any process blocking in þhpt{_smutex_request()} for
    this semaphore won't occur before the current time slice ends.

þseealso __cxchg() _smutex_available() _smutex_request()


þfunction _smutex_request()
þcompat emx
þheaders
#include <sys/builtin.h>
#include <sys/smutex.h>
þendheaders

þparam SEM FLAGS
þprototype
void _smutex_request (volatile _smutex *SEM);
þendprototype

    Request ownership of the _smutex semaphore pointed to by SEM.  If
    the semaphore is available, it will be set to owned and
    _smutex_request() will return immediately.

    If the semaphore is owned, _smutex_request() will suspend the
    current thread, periodically checking whether the semaphore is
    available or still owned.  If the semaphore is available, it will
    be set atomically to owned and _smutex_request() will return.
    Otherwise, _smutex_request() will continue polling.
    _smutex_request() does not return if a signal occurs while
    blocking.

    Note that ownership of an _smutex semaphore is not tied to a
    thread, that is, it's not a thread which owns the semaphore.  This
    is in contrast to OS/2's mutex semaphores (HMTX).  Deadlock will
    occur if _smutex_request() is called twice for the same semaphore
    by the same thread without an intervening call to
    _smutex_release().  This fact is important to keep in mind in
    presence of signals.  Signal handlers must not request semaphores
    which can be owned by the interrupted code.  You might want to
    block signals before requesting ownership of an _smutex semaphore.

þrestrictions

    Under DOS, _smutex_request() crashes if the semaphore is already
    owned.

þseealso __cxchg() _fmutex_create() _rmutex_create() _smutex_available() _smutex_release()


þfunction snprintf()
þcompat BSD
þheaders
#include <stdio.h>
þendheaders

þparam BUFFER N FORMAT
þprototype
int snprintf (char *BUFFER, size_t N, const char *FORMAT, ...);
þendprototype

    Formatted output to the string pointed to by BUFFER.  If N is
    zero, BUFFER may be NULL and nothing is written.  Otherwise, up to
    þpa{N}-1 characters and a terminating null character will be
    written to BUFFER.  If formatting yields more than þpa{N}-1
    characters, output will be truncated.  The terminating null
    character will be put into BUFFER even if output is truncated.

þreturnvalue

    On success, snprintf() returns the number of characters (excluding
    the terminating null character) that would have been written to
    BUFFER if N had been sufficiently large.  That is, output is
    truncated iff the returned value is greater than or equal to N.
    On error, snprintf() returns EOF.

þseealso sprintf() vsnprintf()


þfunction sopen()
þcompat PC
þheaders
#include <io.h>
#include <share.h>
þendheaders

þparam NAME OFLAG SHFLAG PMODE ISIZE
þprototype
int sopen (const char *NAME, int OFLAG, int SHFLAG);
int sopen (const char *NAME, int OFLAG, int SHFLAG, int PMODE);

int sopen (const char *NAME, int OFLAG, int SHFLAG,
           unsigned long ISIZE);
int sopen (const char *NAME, int OFLAG, int SHFLAG, int PMODE,
           unsigned long ISIZE);
þendprototype

    Open a file or device with an explicit sharing mode.  NAME points
    to the name of the file or device.  OFLAG contains one or more of
    the following values, combined by the þtt{|} operator:

þdescription

þitem O_RDONLY

    Open for reading.  Writing is not allowed

þitem O_WRONLY

    Open for writing.  Reading is not allowed

þitem O_RDWR

    Open for reading and writing

þitem O_APPEND

    Move the file pointer to the end of file before any write
    operation takes place.  This is used for appending to a file

þitem O_CREAT

    Create the file if it does not exist.  If this flag is set, the
    PMODE argument is required

þitem O_TRUNC

    Truncate the size of the file to 0

þitem O_EXCL

    Fail if the O_CREAT is used and the file already exists

þitem O_NONBLOCK alias O_NDELAY

    Currently ignored

þitem O_BINARY

    Binary mode, no translation.  See below

þitem O_TEXT

    Text mode, translate CR/LF to newline.  See below

þitem O_NOINHERIT

    Child processes won't inherit the file handle

þitem O_SYNC

    Write operations are synchronous, that is, write() waits until
    file data has been physically written

þitem O_SIZE

    Set the initial size of the file to ISIZE if the file is a new
    file (O_CREAT) or an existing file truncated (O_TRUNC).  If this
    flag is set, the ISIZE argument is required.  O_SIZE is ignored
    under DOS

þenddescription

    If a new file is created, PMODE (modified by the umask value), is
    used to set the file permissions.  S_IREAD grants read access,
    S_IWRITE grants write access.  S_IREAD is ignored (DOS and OS/2
    limitation).

    There are two additional OFLAG flags: O_TEXT for text mode,
    O_BINARY for binary mode.  Text mode, which is the default,
    translates each CR/LF pair to a newline character on input and
    translates newline characters to CR/LF pairs on output.  If the last
    character of a file is Ctrl-Z, it is discarded on input.  Binary
    mode disables these transformations.

    If the file or device cannot be opened, open() sets errno and
    returns -1.  If open() succeeds, the file handle is returned.  The
    file handle is always greater than -1.

    The mode þtt{O_TRUNC|O_RDONLY} is not implemented.  A Ctrl-Z at
    the end of the file is removed only when opening a file for
    appending in text mode.  Ctrl-Z at the end of the file is
    obsolete, anyway.

    The sharing mode of the file is given by SHFLAG.  The following
    sharing modes are available:

þdescription

þitem SH_DENYRW

    Deny read and write access

þitem SH_DENYRD

    Deny read access (permit write access)

þitem SH_DENYWR

    Deny write access (permit read access)

þitem SH_DENYNO

    Deny nothing (permit read and write access)

þenddescription

þreturnvalue

    sopen() returns a file handle for the file.  On error, sopen()
    sets errno and returns -1.

þimplementation

    O_SIZE is an emx extension.  It's the caller's responsibility to
    truncate the file if its size should be less than ISIZE bytes.
    O_SIZE is ignored under DOS.

þrestrictions

    Under DOS, the O_NOINHERIT flag is currently ignored for child
    processes which are DOS programs (vs. emx programs).  Under DOS,
    the O_SYNC and O_SIZE flags are ignored.

þseealso close() fcntl() fdopen() ftruncate() open()


þfunction spawn*() spawnl() spawnle() spawnlp() spawnlpe() spawnv() spawnve() spawnvp() spawnvpe()
þcompat PC *
þheaders
#include <process.h>
þendheaders

þparam MODE NAME ARG0 ARGV ENVP
þprototype
int spawnl (int MODE, const char *NAME, const char *ARG0, ...);
int spawnle (int MODE, const char *NAME, const char *ARG0, ...);
int spawnlp (int MODE, const char *NAME, const char *ARG0, ...);
int spawnlpe (int MODE, const char *NAME, const char *ARG0, ...);
int spawnv (int MODE, const char *NAME, char * const ARGV[]);
int spawnve (int MODE, const char *NAME,char * const ARGV[],
             char * const ENVP[]);
int spawnvp (int MODE, const char *NAME, char * const ARGV[]);
int spawnvpe (int MODE, const char *NAME, char * const ARGV[],
              char * const ENVP[]);
þendprototype

    Run a program.  NAME points to the name of the executable file to
    run.

    Use spawnl(), spawnle(), spawnlp() or spawnlpe() for passing a
    fixed number of arguments.  ARG0 points to a string containing the
    0th argument which is the program name, by convention.  Following
    ARG0, pointers to the arguments are passed.  After the last
    argument pointer, a null pointer cast to `þtt{char *}' must be
    following.  At least ARG0 must be specified.

    Use spawnv(), spawnve(), spawnvp() or spawnvpe() for passing a
    variable number of arguments.  ARGV points to an array of pointers
    to strings.  The first entry is the program name, by convention.
    The last argument pointer must be followed by a null pointer.

    spawnl(), spawnlp(), spawnv() and spawnvp() pass the environment
    of the current process to the child process.  To pass a different
    environment to the child process pass a pointer to an array of
    strings after the null argument pointer of spawnle() and
    spawnlpe() or pass the pointer in the ENVP argument of spawnve()
    and spawnvpe().  The last string pointer in the array must be
    followed by a null pointer.

    If both the child process and the parent process use emx.exe or
    emx.dll, the child process will inherit the signal actions of the
    parent process: Signals set to SIG_IGN in the parent process will
    be set to SIG_IGN in the child process, signals set to SIG_DFL in
    the parent process will be set to SIG_DFL in the child process,
    signals caught in the parent process will be set to SIG_DFL in the
    child process.

    The MODE argument specifies how to run the child process.  You
    have to include exactly one of the following values:

þdescription

þitem P_WAIT

    run the process synchronously, that is, control returns to the
    parent process after the child process finishes

þitem P_NOWAIT

    run the process asynchronously, that is in parallel with the
    parent process.  Use wait() to wait for completion of the child
    process and to get its termination status.  Under DOS, the process
    is run synchronously

þitem P_OVERLAY

    replace the parent process, that is, run the child process and
    terminate the parent process

þitem P_DEBUG

    run the process in debugging mode, that is, under control of the
    parent process.  Use ptrace() to control the child process

þitem P_DETACH

    run the process detached, that is, without input and output.
    P_DETACH is not available under DOS

þitem P_SESSION

    run the process in a separate session.  P_SESSION is not available
    under DOS.

þitem P_PM

    the process is a Presentation Manager program.  P_PM is not
    available under DOS.

þenddescription

    Additional flags are available for P_SESSION, which can be added
    by using the þtt{|} operator:

þdescription

þitem P_QUOTE

    Quote all the arguments, that is, suppress expansion of command
    line arguments by þhpt{_wildcard()} and þhpt{_response()} in the
    child process.  Without P_QUOTE, arguments are not quoted

þitem P_TILDE

    Use the `MKS Korn shell' method for passing command line arguments
    (OS/2, only; this was the default in emx 0.8h and earlier).  That
    method passes the arguments in the third and following strings of
    DosExecPgm.  The tilde character is used as flag at the start of
    the third string

þenddescription

    Use one of the following flags for selecting the session type:

þdescription

þitem P_DEFAULT

    let the operating system choose the session type

þitem P_FULLSCREEN

    start a full-screen session

þitem P_WINDOWED

    start a windowed session

þenddescription

    These flags (which can be used with P_SESSION and P_PM) control
    the initial appearance of the window:

þdescription

þitem P_MINIMIZE

    minimize the window

þitem P_MAXIMIZE

    maximize the window

þenddescription

    Additionally, you can use the following flags with P_SESSION and
    P_PM:

þdescription

þitem P_BACKGROUND

    start the session in the background

þitem P_FOREGROUND

    start the session in the foreground.  This works only if the
    calling session is in the foreground.  P_FOREGROUND is the default

þitem P_NOCLOSE

    don't close the window automatically when the process ends
    (ignored for P_PM)

þitem P_UNRELATED

    create an independent session.  SIGCHLD won't be raised when the
    session terminates.  wait() and waitpid() cannot be used on that
    session.  spawn*() returns zero (instead of a process ID) on
    success.

þenddescription

    Additional flags are available for P_DEBUG, which can be added
    by using the þtt{|} operator:

þdescription

þitem P_NOSESSION

    don't run debuggee in a separate session.  The same effect can be
    achieved with the -E emx option.

þitem P_DEBUGDESC

    enable debugging of descendant processes of the debuggee; see
    þhpt{ptrace()} for details.  P_DEBUGDESC cannot be used if
    _UF_PTRACE_STANDARD is in effect, see þhpt{_uflags()} for details.

þenddescription

    When the new process terminates, SIGCHLD is sent to the process
    which started that process.  You should use wait() or waitpid() to
    get the return code of the process.  If you don't retrieve the
    return code for asynchronous child processes, the return codes
    fill up memory.  All this does not apply to P_WAIT, P_OVERLAY and
    P_DETACH.

þreturnvalue

    These functions return the return value of the child process
    (P_WAIT), or the process ID of the child process (P_NOWAIT,
    P_DEBUG, P_SESSION and P_PM), or zero (P_UNRELATED) if successful.
    On error they return -1.

þrestrictions

    The command line length is restricted to 126 characters when
    running DOS programs.  DOS programs can only be run in P_WAIT or
    P_NOWAIT mode.  P_NOWAIT runs processes synchronously under DOS.
    The termination status of only one process will be kept for wait()
    under DOS.  The default extension is .exe; if you want to run a
    .com file, explicitly add .com.  Currently, DOS seems to crash if
    you try to spawn a .com file without using emx option -p, see
    `þhpt{Using emx options}'.  (The machine crashes on the second
    attempt.)  With the system call library sys.lib (þhpt{-Zsys}),
    only modes P_WAIT, P_NOWAIT and P_OVERLAY are currently available.

þseealso exit() ptrace() system() wait()


þfunction _splitargs()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam STRING COUNT
þprototype
char **_splitargs (char *STRING, int *COUNT);
þendprototype

    Parse the string pointed to by STRING like a command line and
    build a vector of pointers to the arguments.  The vector is
    terminated by a NULL pointer.  The number of arguments is stored
    to the variable pointed to by COUNT unless COUNT is NULL.  The
    string pointed to by STRING is modified by _splitargs(), the
    pointers in the resulting vector point into the string pointed to
    by STRING.  _splitargs() allocates the vector using malloc().  If
    you no longer need the vector, use free() to deallocate it.  On
    error, _splitargs() sets errno and returns NULL.

    Arguments in the string pointed to by STRING are separated by
    whitespace (one or more blanks, tabs and linefeeds).  Whitespace
    at the start of the string is skipped.  To include blanks, tabs or
    linefeeds in an argument, the argument must be quoted using double
    quotation marks.  To remove the special meaning of a double quote,
    precede it with a backslash.  To remove the special meaning of a
    backslash in front of a double quote, precede the backslash with a
    backslash.  The backslash character doesn't have a special meaning
    unless it precedes a double quote or any number of backslashes
    followed by a double quote.

    In other words: If there are n backslashes (\) immediately
    preceding a double quote character ("), floor(n/2) backslashes are
    put into the argument.  If n is odd, the double quote character is
    put into the argument.  If n is even (including zero), the double
    quote character is used for quoting, that is, spaces are not
    treated as argument delimiters until the next `quoting' double
    quote character (ie, a double quote character immediately preceded
    by an even number (including zero) of backslashes) is found.
    Backslashes not preceding a quote character are always read as
    backslashes.

þreturnvalue

    See above.


þfunction _splitpath()
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þparam SRC DRIVE DIR FNAME EXT
þprototype
void _splitpath (const char *SRC, char *DRIVE, char *DIR, char *FNAME,
                 char *EXT);
þendprototype

    Split the path name pointed to by SRC into its components.  The
    drive name (including the colon) is stored to the array pointed to
    by DRIVE.  The directory (including the final slash or backslash)
    is copied to the array pointed to by DIR, the file name without
    extension is copied to the array pointed to by FNAME, the
    extension (including the dot) is copied to the array pointed to by
    EXT.  The arrays should be of size _MAX_DRIVE, _MAX_DIR,
    _MAX_FNAME and _MAX_EXT, respectively.  These constants include
    the terminating null characters.  If one of the pointers (except
    for SRC) is NULL, that component is not stored.

    _splitpath() properly handles DBCS characters.

þseealso _fngetdrive() _getext() _getname() _makepath() _nls_init()

þsamplecode
char drive[_MAX_DRIVE], dir[_MAX_DIR];
char fname[_MAX_FNAME], ext[_MAX_EXT];
char *path = "c:/files/more/test.file.c";

_splitpath (path, drive, dir, fname, ext);
þendsamplecode

    Results of the example:

þexample
drive = "c:"
dir   = "/files/more/"
fname = "test.file"
ext   = ".c"
þendexample


þfunction sprintf()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam BUFFER FORMAT
þprototype
int sprintf (char *BUFFER, const char *FORMAT, ...);
þendprototype

    Formatted output to the string pointed to by BUFFER.  The string
    must be big enough to hold the output.  See þhpt{printf()} for details.

þreturnvalue

    On success, sprintf() returns the number of characters copied to
    BUFFER (excluding the terminating null character).  On error,
    sprintf() returns EOF.

þseealso gcvt() _itoa() _mfopen() printf() sscanf() snprintf()


þfunction sqrt() sqrtl()
þcompat C90 C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
double sqrt (double X);
long double sqrtl (long double X);
þendprototype

    Compute the square root of X.

    sqrtl() uses the þtt{long double} format.

þreturnvalue

    sqrt() returns the square root of X.  If X is negative, a NaN is
    returned and errno set to EDOM.

þseealso cbrt() pow()


þfunction _srotl() _srotr()
þcompat VAC++
þheaders
#include <sys/builtin.h>
þendheaders

þparam VALUE SHIFT
þprototype
unsigned short _srotl (unsigned short VALUE, int SHIFT);
unsigned short _srotr (unsigned short VALUE, int SHIFT);
þendprototype

    _srotl() returns VALUE (16 bits) rotated left by SHIFT bits.  If
    SHIFT is 1, bit 14 is returned as bit 15, bit 13 is returned as bit
    14, and so on, bit 0 is returned as bit 1, and bit 15 is
    returned as bit 0.

    _srotr() returns VALUE (16 bits) rotated right by SHIFT bits.  If
    SHIFT is 1, bit 1 is returned as bit 0, bit 2 is returned as bit
    1, and so on, bit 7 is returned as bit 6, and bit 0 is returned as
    bit 7.

    SHIFT should be 0 through 15.

    These functions are implemented as inline functions.

þseealso _crotl() _crotr() _lrotl() _lrotr()


þfunction sscanf()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam BUFFER FORMAT
þprototype
int sscanf (const char *BUFFER, const char *FORMAT, ...);
þendprototype

    Parse the string pointed to by BUFFER according to the format
    string pointed to by FORMAT.  For each field in the format string
    there must be a pointer to the location receiving the value.  The
    pointers are passed after the FORMAT argument.

þreturnvalue

    If successful, sscanf() returns the number of fields converted.
    On error, sscanf() returns EOF.

þseealso scanf() sprintf() strptime()

þsamplecode
char inp[512];
int year, month, day;
...
if (fgets (inp, sizeof (inp), stdin) != NULL
    && sscanf (inp, "%d/%d/%d", &year, &month, &day) == 3)
  {
    ...
  }
þendsamplecode


þfunction stat()
þcompat UNIX
þheaders
#include <io.h>
#include <sys/types.h>
#include <sys/stat.h>
þendheaders

þparam NAME BUFFER
þprototype
int stat (const char *NAME, struct stat *BUFFER);
þendprototype

    Retrieve information about a file or directory.  NAME is a pointer
    to the name of the file or directory.  stat() will put the data
    into the structure pointed to by BUFFER:

þexample
struct stat
{
  dev_t   st_dev;       /* Device number */
  ino_t   st_ino;       /* Inode number */
  mode_t  st_mode;      /* Protection mode, S_IREAD etc. */
  nlink_t st_nlink;     /* Number of links -- always 1 */
  uid_t   st_uid;       /* User ID of owner -- always 0 (root) */
  gid_t   st_gid;       /* Group ID of owner -- always 0 (root) */
  dev_t   st_rdev;      /* Always 0 */
  off_t   st_size;      /* Size of file */
  time_t  st_atime;     /* Time of last access */
  time_t  st_mtime;     /* Time of last modification */
  time_t  st_ctime;     /* Time of creation */
  long    st_attr;      /* File attributes (OS/2 and DOS style) */
  long    st_reserved;  /* Currently not used */
};
þendexample

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error (errno is set)
þenddescription

þrestrictions

    st_dev and st_rdev are set to zero.  Each call to stat() returns a
    different value for st_ino.

þseealso fstat()


þfunction _status87()
þcompat PC
þheaders
#include <float.h>
þendheaders

þprototype
unsigned _status87 (void);
þendprototype

    Return the coprocessor status word.

þreturnvalue

    See above.

þseealso _clear87() _control87()


þfunction strcat()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2
þprototype
char *strcat (char *STRING1, const char *STRING2);
þendprototype

    Append the null-terminated string pointed to by STRING2 to the
    null-terminated array pointed to by STRING1.  The objects must
    not overlap.

þreturnvalue

    strcat() returns STRING1.

þseealso strcpy()


þfunction strchr()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING C
þprototype
char *strchr (const char *STRING, int C);
þendprototype

    Return a pointer to the first occurrence of the character C in the
    null-terminated string pointed to by STRING.  If there is no
    character C in that string, NULL is returned.  If C is the null
    character (0), a pointer to the terminating null character of that
    string is returned.

þreturnvalue

    See above.

þseealso index() memchr() strrchr() strstr()


þfunction strcmp()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2
þprototype
int strcmp (const char *STRING1, const char *STRING2);
þendprototype

    Compare the null-terminated strings pointed to by STRING1 and
    STRING2.  If the string pointed to by STRING1 is less than the
    string pointed to by STRING2, a negative value is returned.  If
    the string pointed to by STRING1 is equal to the string pointed to
    by STRING2, zero is returned.  If the string pointed to by STRING1
    is greater than the string pointed to by STRING2, a positive value
    is returned.

þreturnvalue
þdescription
þitem <0
   1st string < 2nd string
þitem =0
   1st string = 2nd string
þitem >0
   1st string > 2nd string
þenddescription

þseealso memcmp() stricmp() strncmp()


þfunction strcoll()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2
þprototype
int strcoll (const char *STRING1, const char *STRING2);
þendprototype

    Compare the null-terminated strings pointed to by STRING1 and
    STRING2 according to the LC_COLLATE category of the current
    locale.  If the string pointed to by STRING1 is less than the
    string pointed to by STRING2, a negative value is returned.  If
    the string pointed to by STRING1 is equal to the string pointed to
    by STRING2, zero is returned.  If the string pointed to by STRING1
    is greater than the string pointed to by STRING2, a positive value
    is returned.

þreturnvalue
þdescription
þitem <0
   1st string < 2nd string
þitem =0
   1st string = 2nd string
þitem >0
   1st string > 2nd string
þenddescription

þrestrictions

    Currently, locale is ignored: strcoll() is equivalent to strcmp().

þseealso setlocale() strcmp()


þfunction strcpy()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2
þprototype
char *strcpy (char *STRING1, const char *STRING2);
þendprototype

    Copy the null-terminated string pointed to by STRING2 to the array
    pointed to by STRING1.  The objects must not overlap.

þreturnvalue

    strcpy() returns STRING1.

þseealso memccpy() memcpy() strcat() strncpy()


þfunction strcspn()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2
þprototype
size_t strcspn (const char *STRING1, const char *STRING2);
þendprototype

    Return the length of the initial substring of the string pointed
    to by STRING1 which consists of characters not in the string
    pointed to by STRING2.  That is, the index of the first character
    in the string pointed to by STRING1 which also occurs in the
    string pointed to by STRING2 is returned.  If all characters of
    the string pointed to by STRING1 are not in the string pointed to
    by STRING2, the length of the string pointed to by STRING1 is
    returned.

þreturnvalue

    See above.

þseealso strpbrk() strspn()


þfunction strdup()
þcompat UNIX
þheaders
#include <string.h>
þendheaders

þparam STRING
þprototype
char *strdup (const char *STRING);
þendprototype

    Creates a duplicate of the string pointed to by STRING by using
    malloc() to allocate storage and copying the string pointed to by
    STRING.

þreturnvalue

    strdup() returns a pointer to the new string.  If there is not
    enough memory, strdup() returns NULL.

þseealso malloc() strcpy()


þfunction strerror()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam ERRNUM
þprototype
char *strerror (int ERRNUM);
þendprototype

    Return a pointer to a an error message according to the error
    number ERRNUM.  You must not write to the string returned by
    strerror().  The string may get changed by the next call to
    strerror().

þreturnvalue

    See above.

þseealso errno perror() sys_errlist


þfunction strftime()
þcompat C90
þheaders
#include <time.h>
þendheaders

þparam STRING SIZE FORMAT T
þprototype
size_t strftime (char *STRING, size_t SIZE, const char *FORMAT,
                 const struct tm *T);
þendprototype

    Format time.  The output string is written to the array of SIZE
    characters pointed to by STRING, including the terminating null
    character.  Like sprintf(), strftime() copies the string pointed
    to by FORMAT to the array pointed to by STRING, replacing format
    specifications with formatted data from T.  Ordinary characters
    are copied unmodified.  The following format specifications are
    available:

þdescription
þitem %%

    percent sign

þitem %a

    locale's abbreviated weekday name

þitem %A

    locale's full weekday name

þitem %b

    locale's abbreviated month name

þitem %B

    locale's full month name

þitem %c

    locale's date and time

þitem %d

    day of month (01-31)

þitem %D

    date, this is equivalent to %m/%d/%y

þitem %e

    day of month ( 1-31), blank padded

þitem %h

    locale's abbreviated month name

þitem %H

    hour (00-23)

þitem %I

    hour (01-12)

þitem %j

    day of year (001-366)

þitem %m

    month (01-12)

þitem %M

    minute (00-59)

þitem %n

    newline character

þitem %p

    locale's equivalent to AM or PM, as appropriate

þitem %r

    time in AM/PM notation, this is equivalent to %I:%M:%S %p

þitem %S

    second (00-59)

þitem %t

    TAB character

þitem %T

    time, this is equivalent to %H:%M:%S

þitem %U

    week number of the year, the first day of the week is Sunday
    (00-53)

þitem %w

    weekday, the first day of the week is Sunday (0-6)

þitem %W

    week number of the year, the first day of the week is Monday
    (00-53)

þitem %x

    locale's date representation

þitem %X

    locale's time representation

þitem %y

    year without century (00-99)

þitem %Y

    year with century (1970-2106)

þitem %Z

    timezone name or no characters if no time zone is determinable

þenddescription

    If % is followed by a character not listed above, the results are
    undefined.

þreturnvalue

    On success, strftime() returns the number of characters copied to
    the array pointed to by STRING, excluding the terminating null
    character.  On failure (SIZE exceeded), strftime() returns 0.

þseealso asctime() setlocale() sprintf() strptime() tzset()


þfunction stricmp()
þcompat PC
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2
þprototype
int stricmp (const char *STRING1, const char *STRING2);
þendprototype

    Compare the strings pointed to by STRING1 and STRING2, ignoring
    letter case.  If the strings are equal, 0 is returned.  Otherwise,
    a positive value is returned if the string pointed to by STRING1
    is greater than the string pointed to by STRING2 (after conversion
    to lower case).  A negative value is returned if the string
    pointed to by STRING1 is less than the string pointed to by
    STRING2 (after conversion to lower case).  The strings are not
    modified.

þreturnvalue
þdescription
þitem <0
   1st string < 2nd string
þitem =0
   1st string = 2nd string
þitem >0
   1st string > 2nd string
þenddescription

þseealso strcmp() tolower()


þfunction strlen()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING
þprototype
size_t strlen (const char *STRING);
þendprototype

    Compute the length (number of characters) of the string pointed to
    by STRING.  The length does not include the terminating null
    character.

þreturnvalue

    strlen() returns the length of the string pointed to by STRING,
    that is, the number of characters preceding the terminating null
    character.

þseealso strchr()


þfunction strlwr()
þcompat PC
þheaders
#include <string.h>
þendheaders

þparam STRING
þprototype
char *strlwr (char *STRING);
þendprototype

    Convert the string pointed to by STRING to lower case.  The
    characters þtt{'A'} through þtt{'Z'} are mapped to the characters
    þtt{'a'} through þtt{'z'}.  All other characters are not changed.

þreturnvalue

    strlwr() returns STRING.

þseealso _fnlwr() strupr()


þfunction strncat()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2 COUNT
þprototype
char *strncat (char *STRING1, const char *STRING2, size_t COUNT);
þendprototype

    Append the null-terminated string pointed to by STRING2 to the
    null-terminated string pointed to by STRING1.  At most COUNT
    characters of the string pointed to by STRING2 are appended to the
    string pointed to by STRING1.  strncat() terminates the new string
    pointed to by STRING1 with a null character.

þreturnvalue

    strncat() returns STRING1.

þseealso strcat() strncpy()


þfunction strncmp()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2 COUNT
þprototype
int strncmp (const char *STRING1, const char *STRING2, size_t COUNT);
þendprototype

    Compare the null-terminated strings pointed to by STRING1 and
    STRING2.  At most the first COUNT characters are compared.  If the
    string pointed to by STRING1 is less than the string pointed to by
    STRING2, a negative value is returned.  If the string pointed to
    by STRING1 is equal to the string pointed to by STRING2, zero is
    returned.  If the string pointed to by STRING1 is greater than the
    string pointed to by STRING2, a positive value is returned.

þreturnvalue
þdescription
þitem <0
   1st string < 2nd string
þitem =0
   1st string = 2nd string
þitem >0
   1st string > 2nd string
þenddescription

þseealso memcmp() strcmp() strnicmp()


þfunction strncpy()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2 COUNT
þprototype
char *strncpy (char *STRING1, const char *STRING2, size_t COUNT);
þendprototype

    Copy the null-terminated string pointed to by STRING2 to the array
    pointed to by STRING1.  The objects must not overlap.  At most the
    first COUNT characters of the string pointed to by STRING2 are
    copied.  If the string pointed to by STRING2 is shorter than COUNT
    characters, the string pointed to by STRING1 will be padded with
    null characters to COUNT characters.  If the length of the string
    pointed to by STRING2 is equal to or greater than COUNT, a
    terminating null character will not be appended.

þreturnvalue

    strncpy() returns STRING1.

þseealso strcpy() strncat()


þfunction _strncpy()
þcompat emx
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2 SIZE
þprototype
char *_strncpy (char *STRING1, const char *STRING2, size_t SIZE);
þendprototype

    Copy the null-terminated string pointed to by STRING2 to the array
    pointed to by STRING1.  The objects must not overlap.  At most
    SIZE characters, including the terminating null character, are
    copied to the array pointed to by STRING1.  A terminating null
    character is always appended, even if the string pointed to by
    STRING2 is too long.

þreturnvalue

    _strncpy() returns STRING1.

þseealso strcpy() strncpy()


þfunction strnicmp()
þcompat PC
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2 COUNT
þprototype
int strnicmp (const char *STRING1, const char *STRING2, size_t COUNT);
þendprototype

    Compare the null-terminated strings pointed to by STRING1 and
    STRING2 ignoring letter case.  At most the first COUNT characters
    are compared.  If the string pointed to by STRING1 is equal to the
    string pointed to by STRING2, zero is returned.  If the string
    pointed to by STRING1 is less than the string pointed to by
    STRING2 (after conversion to lower case), a negative value is
    returned.  If the string pointed to by STRING1 is greater than the
    string pointed to by STRING2 (after conversion to lower case), a
    positive value is returned.  The strings are not modified.

þreturnvalue
þdescription
þitem <0
   1st string < 2nd string
þitem =0
   1st string = 2nd string
þitem >0
   1st string > 2nd string
þenddescription

þseealso memicmp() strcmp() strncmp() tolower()


þfunction strnset()
þcompat PC
þheaders
#include <string.h>
þendheaders

þparam STRING C COUNT
þprototype
char *strnset (char *STRING, int C, size_t COUNT);
þendprototype

    Set, at most, the first COUNT characters of the string pointed to
    by STRING to the character C.  If the length of the string pointed
    to by STRING is less than COUNT, strnset() stops at the
    terminating null character.

þreturnvalue

    strnset() returns STRING.

þseealso memset() strset()


þfunction strpbrk()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2
þprototype
char *strpbrk (const char *STRING1, const char *STRING2);
þendprototype

    Return a pointer to the first occurrence in the string pointed to
    by STRING1 of a character of the string pointed to by STRING2.
    The terminating null character is not included in the search.  If
    no character of the string pointed to by STRING2 can be found in
    the string pointed to by STRING1, NULL is returned.

þreturnvalue

    See above.

þseealso strchr() strcspn()


þfunction strptime()
þcompat UNIX
þheaders
#include <time.h>
þendheaders

þparam BUFFER FORMAT T
þprototype
char *strptime (const char *BUFFER, const char *FORMAT, struct tm *T);
þendprototype

    Parse a time specification in the input string pointed to by
    BUFFER according to the format string pointed to by FORMAT,
    updating the structure pointed to by T.

    Whitespace (any number of spaces) in the format string matches
    whitespace (any number of spaces, including zero) in the input
    string.  All other characters except for þtt{%} are compared to
    the input.  Parsing ends (with an error being indicated) when a
    mismatch is encountered.  þtt{%%} in the format string matches
    þtt{%} in the input string.  A þtt{%} which is not followed by
    another þtt{%} or the end of the string starts a field
    specification.  The field in the input is interpreted according to
    the field specification.  For all field types, whitespace is
    ignored at the start of a field.  Field specifications matching
    numbers skip leading zeros.  Case is ignored when comparing
    strings.  The field width is not restricted, that is, as many
    characters as possible are matched.  The following field
    specifications are available:

þdescription
þitem %%

    percent sign (see above)

þitem %a

    locale's abbreviated weekday name, tm_wday

þitem %A

    locale's full weekday name, update tm_wday

þitem %b

    locale's abbreviated month name, update tm_mon.  %h is a synonym
    for %b

þitem %B

    locale's full month name, update tm_mon

þitem %c

    locale's date and time, update tm_year, tm_mon, tm_mday, tm_hour,
    tm_min, and tm_sec

þitem %C

    date and time, equivalent to %x %X, update tm_year, tm_mon,
    tm_mday, tm_hour, tm_min, and tm_sec

þitem %d

    day of month (1-31), update tm_mday

þitem %D

    date, this is equivalent to %m/%d/%y, update tm_year, tm_mon, and
    tm_mday

þitem %e

    day of month (1-31), update tm_mday

þitem %H

    hour (0-23), update tm_hour (%k is a synonym for %H)

þitem %I

    hour (1-12), update tm_hour (%l is a synonym for %I)

þitem %j

    day of year (1-366), update tm_yday

þitem %m

    month (1-12), update tm_mon

þitem %M

    minute (0-59), update tm_min

þitem %n

    newline character

þitem %p

    locale's equivalent to AM or PM, as appropriate (for use with %I),
    update tm_hour

þitem %r

    time in AM/PM notation, this is equivalent to %I:%M:%S %p, update
    tm_hour, tm_min, and tm_sec

þitem %R

    hour and minutes, equivalent to %H:%M, update tm_hour and tm_min

þitem %S

    second (0-59), update tm_sec

þitem %t

    TAB character

þitem %T

    time, equivalent to %H:%M:%S, update tm_hour, tm_min, tm_sec

þitem %U

    week number of the year, the first day of the week is Sunday
    (0-53), currently ignored

þitem %w

    weekday, the first day of the week is Sunday (0-6), update tm_wday

þitem %W

    week number of the year, the first day of the week is Monday
    (0-53), currently ignored

þitem %x

    locale's date representation, update tm_year, tm_mon, and tm_mday

þitem %X

    locale's time representation, update tm_hour, tm_min, and tm_sec

þitem %y

    year without century (0-99, mapping 0-68 to 2000-2068 and 69-99 to
    1969-1999), update tm_year

þitem %Y

    year with century (1970-2106), update tm_year

þenddescription

    If % is followed by a character not listed above, the results are
    undefined.

þrestrictions

    Case is currently not ignored for non-ASCII characters.  %p must
    currently come after %I in the format string.

    As behavior of other implementations of strptime() is quite
    varying, this implementation of strptime() does not behave like
    most other implementations of strptime().  strptime() is not
    portable.

þreturnvalue

    If successful, strptime() returns a pointer to the character
    following the last character parsed.  On error, strptime() returns
    NULL.

þseealso setlocale() sscanf() strftime()


þfunction strrchr()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING C
þprototype
char *strrchr (const char *STRING, int C);
þendprototype

    Return a pointer to the last occurrence of the character C in the
    null-terminated string pointed to by STRING.  If there is no
    character C in that string, NULL is returned.  If C is the null
    character (0), a pointer to the terminating null character of that
    string is returned.

þreturnvalue

    See above.

þseealso _memrchr() rindex() strchr()


þfunction strrev()
þcompat PC
þheaders
#include <string.h>
þendheaders

þparam STRING
þprototype
char *strrev (char *STRING);
þendprototype

    Reverse the order of the characters in the string pointed to by
    STRING.  The terminating null character remains in place.

þreturnvalue

    strrev() returns STRING.


þfunction strset()
þcompat PC
þheaders
#include <string.h>
þendheaders

þparam STRING C
þprototype
char *strset (char *STRING, int C);
þendprototype

    Replace all the characters of the string pointed to by STRING with
    the character C.  The terminating null character is not changed.

þreturnvalue

    strset() returns STRING.

þseealso memset() strnset()


þfunction strspn()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2
þprototype
size_t strspn (const char *STRING1, const char *STRING2);
þendprototype

    Return the length of the initial substring of the string pointed
    to by STRING1 which consists entirely of characters in the string
    pointed to by STRING2.  That is, the index of the first character
    in the string pointed to by STRING1 which does not occur in the
    string pointed to by STRING2 is returned.  If all characters in
    the string pointed to by STRING1 also occur in the string pointed
    to by STRING2, the length of the string pointed to by STRING1 is
    returned.

þreturnvalue

    See above.

þseealso strcspn() strpbrk()


þfunction strstr()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2
þprototype
char *strstr (const char *STRING1, const char *STRING2);
þendprototype

    Return a pointer to the first occurrence of the string pointed to
    by STRING2 in the string pointed to by STRING1.  If the length of
    the string pointed to by STRING2 is zero, STRING1 is returned.  If
    the string pointed to by STRING2 is not a substring of the string
    pointed to by STRING1, NULL is returned.

þreturnvalue

    See above.

þseealso strchr()


þfunction strtod() strtof() strtold()
þcompat C90 C9X
þheaders
#include <stdlib.h>
þendheaders

þparam STRING END_PTR
þprototype
double strtod (const char *STRING, char **END_PTR);
float strtof (const char *STRING, char **END_PTR);
long double strtold (const char *STRING, char **END_PTR);
þendprototype

    strtod() converts a character string to a þtt{double}.  Leading
    white space is skipped.  strtod() stops at the first character
    that cannot be converted.  The string pointed to by STRING is
    expected to have one of the following forms:

þindent
  þsy{[<whitespace>] [+|-] [<digits>] [.<digits>] [[d|D|e|E] [+|-] <digits>]} þbreak
  þsy{[<whitespace>] [+|-] INF} þbreak
  þsy{[<whitespace>] [+|-] INFINITY} þbreak
  þsy{[<whitespace>] [+|-] NAN} þbreak
  þsy{[<whitespace>] [+|-] NAN(...)}
þendindent

    The decimal point character of the current locale is used.  Letter
    case is ignored for INF, INFINITY, and NAN.  Digits, letters, and
    the underscore character can occur in the parentheses following
    `NAN'.

    If END_PTR is not NULL and the conversion has been performed, a
    pointer to the first character which cannot be converted is stored
    to the object pointed to by END_PTR.  If END_PTR is not NULL and
    no conversion has been performed, STRING is stored to the object
    pointed to by END_PTR.

    If no conversion could be performed, strtod() doesn't change errno
    and returns 0.0 (you can examine the pointer stored to the object
    pointed to by END_PTR to recognize this case).  On overflow,
    strtod() sets errno to ERANGE and returns HUGE_VAL or
    -þtt{HUGE_VAL}, depending on the sign of the number.  On
    underflow, strtod() sets errno to ERANGE and returns 0.0.

    The strtold() function proposed for C9X uses the þtt{long double}
    format.  On overflow, strtold() returns HUGE_VALL or
    -þtt{HUGE_VALL}, depending on the sign of the number.

    The strtof() function proposed for C9X uses the þtt{float}
    format.  On overflow, strtof() returns HUGE_VALF or
    -þtt{HUGE_VALF}, depending on the sign of the number.

þreturnvalue

    strtod(), strtof(), and strtold() return the converted value.  If
    no number is recognized, strtod(), strtof(), and strtold() return
    0.0.  On overflow, strtod() returns HUGE_VAL or -þtt{HUGE_VAL}.
    On overflow, strtof() returns HUGE_VALF or -þtt{HUGE_VALF}.  On
    overflow, strtold() returns HUGE_VALL or -þtt{HUGE_VALL}.  On
    underflow, strtod(), strtof(), and strtold() return 0.0.

þseealso atof() setlocale() sscanf() strtol()


þfunction strtok()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2
þprototype
char *strtok (char *STRING1, const char *STRING2);
þendprototype

    Return a pointer to the next token in the string pointed to by
    STRING1.  The characters of the string pointed to by STRING2 are
    the set of delimiting characters.  Tokens in the string pointed to
    by STRING1 are separated by one or more characters from the string
    pointed to by STRING2.

    The first call to strtok() for STRING1 skips leading delimiters
    and returns a pointer to the first token.  To get the next token
    of the string pointed to by STRING1, call strtok() with a NULL
    argument for STRING1.  The set of delimiters pointed to by STRING2
    as well as the pointer STRING2 may be different on subsequent calls.

    strtok() modifies the string pointed to by STRING1 by inserting
    null characters for terminating tokens.  Thus, the pointer
    returned by strtok() points to a null-terminated token.

    If there are no more tokens, NULL is returned.

þreturnvalue

    See above.

þseealso strpbrk()


þfunction strtol()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam STRING END_PTR RADIX
þprototype
long strtol (const char *STRING, char **END_PTR, int RADIX);
þendprototype

    Convert a character string to a signed long integer.  The string
    pointed to by STRING should have the following format:

þindent
  þsy{[<whitespace>] [+|-] [|0|0x|0X] <digits>}
þendindent

    Leading white space (as defined by isspace()) is skipped.  RADIX
    is the number base used for conversion.  It must either be between
    2 and 36 or be zero.

    If RADIX is 0, the number base is derived from the format of the
    number: If the number starts with þtt{0x}, base 16 is used.  If
    the number starts with þtt{0} (not followed by þtt{x}), base 8 is
    used.  If the number does not start with þtt{0}, base 10 is used.

    strtol() stops at the first character that cannot be converted.
    If END_PTR is not NULL and the conversion has been performed, a
    pointer to the first character which cannot be converted is stored
    to the object pointed to by END_PTR.  If END_PTR is not NULL and
    no conversion has been performed, STRING is stored to the object
    pointed to by END_PTR.

    strtol() doesn't change errno and returns 0 if no conversion could
    be performed (you can examine the pointer stored to the object
    pointed to by END_PTR to recognize this case).  On overflow,
    strtol() sets errno to ERANGE and returns LONG_MIN or LONG_MAX
    (depending on the sign character).  If RADIX is out of range,
    strtol() sets errno to EDOM and returns 0.

þreturnvalue

    strtol() returns the converted value.  If no number is recognized
    or if RADIX is invalid, strtol() returns 0.  On overflow, strtol()
    returns LONG_MIN or LONG_MAX.

þseealso atol() isspace() _ltoa() _strtoll() strtoul() sscanf()

þsamplecode
int read_long (char **ptr, long *dst)
{
  char *p;
  long n;

  errno = 0;
  n = strtol (*ptr, &p, 0);
  if (errno != 0 || p == *ptr)
    return 0;                   /* Failure */
  *dst = n; *ptr = p;
  return 1;                     /* Success */
}
þendsamplecode


þfunction _strtoll()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam STRING END_PTR RADIX
þprototype
long long _strtoll (const char *STRING, char **END_PTR, int RADIX);
þendprototype

    Convert a character string to a signed long long integer.  The
    string pointed to by STRING should have the following format:

þindent
  þsy{[<whitespace>] [+|-] [|0|0x|0X] <digits>}
þendindent

    Leading white space (as defined by isspace()) is skipped.  RADIX
    is the number base used for conversion.  It must either be between
    2 and 36 or be zero.

    If RADIX is 0, the number base is derived from the format of the
    number: If the number starts with þtt{0x}, base 16 is used.  If
    the number starts with þtt{0} (not followed by þtt{x}), base 8 is
    used.  If the number does not start with þtt{0}, base 10 is used.

    _strtoll() stops at the first character that cannot be converted.
    If END_PTR is not NULL and the conversion has been performed, a
    pointer to the first character which cannot be converted is stored
    to the object pointed to by END_PTR.  If END_PTR is not NULL and
    no conversion has been performed, STRING is stored to the object
    pointed to by END_PTR.

    _strtoll() doesn't change errno and returns 0 if no conversion
    could be performed (you can examine the pointer stored to the
    object pointed to by END_PTR to recognize this case).  On
    overflow, _strtoll() sets errno to ERANGE and returns
    LONG_LONG_MIN or LONG_LONG_MAX (depending on the sign character).
    If RADIX is out of range, _strtoll() sets errno to EDOM and
    returns 0.

þreturnvalue

    _strtoll() returns the converted value.  If no number is
    recognized or if RADIX is invalid, strtol() returns 0.  On
    overflow, _strtoll() returns LONG_LONG_MIN or LONG_LONG_MAX.

þseealso _atoll() isspace() _lltoa() strtol() _strtoull() sscanf()


þfunction strtoul()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam STRING END_PTR RADIX
þprototype
unsigned long strtoul (const char *STRING, char **END_PTR, int RADIX);
þendprototype

    Convert a character string to an unsigned long integer.  The
    string pointed to by STRING should have the following format:

þindent
  þsy{[<whitespace>] [+|-] [|0|0x|0X] <digits>}
þendindent

    Leading white space (as defined by isspace()) is skipped.  RADIX
    is the number base used for conversion.  It must either be between
    2 and 36 or be zero.

    If RADIX is 0, the number base is derived from the format of the
    number: If the number starts with þtt{0x}, base 16 is used.  If
    the number starts with þtt{0} (not followed by þtt{x}), base 8 is
    used.  If the number does not start with þtt{0}, base 10 is used.

    strtoul() stops at the first character that cannot be converted.
    If END_PTR is not NULL and the conversion has been performed, a
    pointer to the first character which cannot be converted is stored
    to the object pointed to by END_PTR.  If END_PTR is not NULL and
    no conversion has been performed, STRING is stored to the object
    pointed to by END_PTR.

    strtoul() returns 0 if no conversion could be performed (errno will
    not be changed).  On overflow, strtoul() sets errno to ERANGE and
    returns ULONG_MAX.  If RADIX is out of range, strtoul() sets errno
    to EDOM and returns 0.


þreturnvalue

    strtoul() returns the converted value.  If no number is recognized
    or if RADIX is invalid, strtoul() returns 0.  On overflow, strtoul()
    returns ULONG_MAX.

þseealso isspace() strtol() _strtoull() sscanf() _ultoa()


þfunction _strtoull()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam STRING END_PTR RADIX
þprototype
unsigned long long _strtoull (const char *STRING, char **END_PTR, int RADIX);
þendprototype

    Convert a character string to an unsigned long long integer.  The
    string pointed to by STRING should have the following format:

þindent
  þsy{[<whitespace>] [+|-] [|0|0x|0X] <digits>}
þendindent

    Leading white space (as defined by isspace()) is skipped.  RADIX
    is the number base used for conversion.  It must either be between
    2 and 36 or be zero.

    If RADIX is 0, the number base is derived from the format of the
    number: If the number starts with þtt{0x}, base 16 is used.  If
    the number starts with þtt{0} (not followed by þtt{x}), base 8 is
    used.  If the number does not start with þtt{0}, base 10 is used.

    _strtoull() stops at the first character that cannot be converted.
    If END_PTR is not NULL and the conversion has been performed, a
    pointer to the first character which cannot be converted is stored
    to the object pointed to by END_PTR.  If END_PTR is not NULL and
    no conversion has been performed, STRING is stored to the object
    pointed to by END_PTR.

    _strtoull() returns 0 if no conversion could be performed (errno
    will not be changed).  On overflow, _strtoull() sets errno to
    ERANGE and returns ULONG_LONG_MAX.  If RADIX is out of range,
    _strtoull() sets errno to EDOM and returns 0.

þreturnvalue

    _strtoull() returns the converted value.  If no number is recognized
    or if RADIX is invalid, _strtoull() returns 0.  On overflow, _strtoull()
    returns ULONG_LONG_MAX.

þseealso isspace() _strtoll() strtoul() sscanf() _ulltoa()


þfunction strupr()
þcompat PC
þheaders
#include <string.h>
þendheaders

þparam STRING
þprototype
char *strupr (char *STRING);
þendprototype

    Convert the string pointed to by STRING to upper case.  The
    characters þtt{'a'} through þtt{'z'} are mapped to the characters
    þtt{'A'} through þtt{'Z'}.  All other characters are not changed.

þreturnvalue

    strupr() returns STRING.

þseealso strlwr()


þfunction strxfrm()
þcompat C90
þheaders
#include <string.h>
þendheaders

þparam STRING1 STRING2 N
þprototype
size_t strxfrm (char *STRING1, const char *STRING2, size_t N);
þendprototype

    Transform the string pointed to by STRING2 according to the
    LC_COLLATE category of the current locale and copy the result to
    the array pointed to by STRING1.  After applying strxfrm(), you
    can use strcmp() for comparing the strings; applying strcmp() to
    strings transformed by strxfrm() is equivalent to calling
    strcoll() on the original strings.  At most N characters
    (including the terminating null character) are stored to the array
    pointed to by STRING1.  STRING1 can be NULL if N is zero.

þreturnvalue

    strxfrm() returns the number of characters in the transformed
    string (excluding the terminating null character), even if that
    number exceeds N.  If the return value is equal to or greater than
    N, the contents of the string pointed to by STRING1 are
    indeterminate.

þrestrictions

    Currently, locale is ignored: strxfrm() copies the characters
    without modifications.

þseealso setlocale() strcoll()

þsamplecode
/* Transform a string, allocating memory with malloc(). */
char *xfrm (const char *s)
{
  size_t len = strxfrm (NULL, s, 0);
  char *t = malloc (len + 1);
  if (t != NULL)
    strxfrm (t, s, len + 1);
  return t;
}
þendsamplecode


þfunction swab()
þcompat UNIX
þheaders
#include <stdlib.h>
þendheaders

þparam SRC DST N
þprototype
void swab (const void *SRC, void *DST, size_t N);
þendprototype

    Copy N bytes from SRC to DST, swapping each pair of adjacent
    bytes.  N must be even.


þfunction _swchar()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þprototype
char _swchar (void);
þendprototype

    Retrieve the current switch character.  If the switch character
    has been changed to þtt{'-'}, _swchar() returns þtt{'-'}.
    Otherwise, _swchar() returns 0.  In this case, you should use the
    standard switch character þtt{'/'}.

þreturnvalue

    See above.

þseealso getopt()


þfunction sysconf()
þcompat POSIX.1
þheaders
#include <unistd.h>
þendheaders

þparam NAME
þprototype
long sysconf (int NAME);
þendprototype

    Return the current value of the configurable system limit or
    option NAME.  NAME is one of the following constants:

þdescription
þitem _SC_ARG_MAX

    corresponds to ARG_MAX (length of arguments and environment for
    þtt{exec*()}, in bytes)

þitem _SC_CHILD_MAX

    corresponds to CHILD_MAX (number of simultaneous processes per
    real user ID)

þitem _SC_CLK_TCK

    number of clock ticks per second, for times()

þitem _SC_NGROUPS_MAX

    corresponds to NGROUPS_MAX (maximum number of simultaneous
    supplementary group IDs per process)

þitem _SC_OPEN_MAX

    corresponds to OPEN_MAX (number of files that one process can have
    open at one time)

þitem _SC_STREAM_MAX

    corresponds to STREAM_MAX (number of streams that one process can
    have open at one time)

þitem _SC_TZNAME_MAX

    corresponds to TZNAME_MAX (number of bytes supported for the name
    of a time zone)

þitem _SC_JOB_CONTROL

    corresponds to _POSIX_JOB_CONTROL (defined if the implementation
    supports job control -- emx doesn't)

þitem _SC_SAVED_IDS

    corresponds to _POSIX_SAVED_IDS (defined if each process has a
    saved set-user-ID and a saved set-group-ID -- not true for emx)

þitem _SC_VERSION

    corresponds to _POSIX_VERSION (the integer 199009L)

þenddescription

    See POSIX.1 for more details.

þreturnvalue

    If NAME is invalid, sysconf() sets errno to EINVAL and returns -1.
    If NAME is associated with functionality that is not supported by
    the system, sysconf() returns -1 and does not change errno.
    Otherwise, sysconf() returns the current value of the variable.

þrestrictions

    sysconf() currently returns just the POSIX.1 minimum values.

þseealso fpathconf() pathconf()


þfunction _syserrno()
þcompat emx *
þheaders
#include <stdlib.h>
þendheaders

þprototype
int _syserrno (void);
þendprototype

    Return the OS/2 or DOS error code for the last system call of the
    current thread.  If there was no error, 0 is returned.  If the
    last system call hasn't called an OS/2 or DOS function, 0 is
    returned.

þreturnvalue

    See above.

þrestrictions

    _syserrno() is not implemented under DOS.  _syserrno() is not
    supported with the system call library sys.lib (þhpt{-Zsys}).

þseealso errno _setsyserrno()

þfunction system()
þcompat C90
þheaders
#include <process.h>
þendheaders

þparam NAME
þprototype
int system (const char *NAME);
þendprototype

    Execute a command by passing it to the command interpreter.  NAME
    is a pointer to a string containing the command name.  system()
    uses the COMSPEC environment variable for locating cmd.exe or
    command.com, respectively.  The COMSPEC environment variable can
    be overriden by setting the EMXSHELL environment variable.  The
    PATH environment variable is not used for locating cmd.exe.  If
    the argument is þtt{""}, an interactive shell will be started.  If
    the argument is NULL, system() only checks whether cmd.exe or
    command.com, respectively, can be found.

    As command.com is used under DOS, the command line is restricted
    to about 123 characters.  If you don't need a command shell, use
    spawn*() instead of system().  It's a bad idea to run emx programs
    using system() -- not tested.  You must use the -p emx option when
    using system() under DOS, see `þhpt{Using emx options}'.

    The system() function passes the þtt{/c} option to the command
    processor if COMSPEC (or EMXSHELL) points to cmd.exe,
    þtt{4os2.exe}, command.com or þtt{4dos.com}.  Otherwise,
    system() assumes that a Unix-like shell is to be used and passes
    the þtt{-c} option.

þreturnvalue

    If system() fails, errno is set and -1 is returned.  If the
    argument is NULL and the command processor can be found, 0 is
    returned.  In all other cases, the return code of the command
    processor is returned.  The return code of the program run by the
    command processor is returned by cmd.exe but not by command.com.
    command.com always returns 0.

þseealso popen() spawn*()


þfunction _tcalloc()
þcompat OS/2
þheaders
#include <stdlib.h>
þendheaders

þparam ELEMENTS SIZE
þprototype
void *_tcalloc (size_t ELEMENTS, size_t SIZE);
þendprototype

    Allocate a block of memory big enough for holding ELEMENTS
    elements of SIZE bytes each.  The block will not cross a 64 KByte
    boundary unless SIZE is greater than 65536.  If SIZE is greater
    than 65536, the block will be aligned on a 64 KByte boundary.
    _tcalloc() fills the block with zeros.  If there is an error,
    _tcalloc() returns NULL.

þreturnvalue

    _tcalloc() returns a pointer to a newly allocated block of
    memory.  On error, _tcalloc() returns NULL.

þrestrictions

    If you replace the emx malloc() implementation with a malloc()
    implementation (GNU malloc, for instance) that has not _tmalloc()
    etc. built in, you have to link with the þtt{tmalloc} library
    (-ltmalloc), which implements _tmalloc() etc. on top of malloc()
    etc.

þseealso calloc() _tfree() _tmalloc() _utcalloc() _utdefault()


þfunction tcdrain()
þcompat POSIX.1 *
þheaders
#include <termios.h>
þendheaders

þparam HANDLE
þprototype
int tcdrain (int HANDLE);
þendprototype

    tcdrain() waits until all output written to the terminal
    associated with the file descriptor HANDLE has been transmitted.

þreturnvalue

    tcdrain() returns 0 if successful.  Otherwise, tcdrain()
    sets errno and returns -1.

þerrors
þdescription
þitem EBADF
  HANDLE is not a valid open file descriptor.
þitem ENOTTY
  HANDLE is not associated with a terminal.
þenddescription

þimplementation

    tcdrain() currently does nothing and always succeeds.

þrestrictions

    tcdrain() is not available with the system call library sys.lib
    (þhpt{-Zsys}).

þseealso tcflow() tcflush() tcsendbreak() tcsetattr()


þfunction tcflow()
þcompat POSIX.1 *
þheaders
#include <termios.h>
þendheaders

þparam HANDLE ACTION
þprototype
int tcflow (int HANDLE, int ACTION);
þendprototype

    tcflow() suspends or resumes transmission or reception of data on
    the terminal associated with the file descriptor HANDLE, depending
    on ACTION:

þdescription
þitem TCIOFF
  Transmit a VSTOP character to suspend input.
þitem TCION
  Transmit a VSTART character to resume suspended input.
þitem TCOOFF
  Suspend output.
þitem TCOON
  Resume suspended output.
þenddescription

    See `þhpt{General terminal interface}' for details.

þreturnvalue

    tcflow() returns 0 if successful.  Otherwise, tcflow()
    sets errno and returns -1.

þerrors
þdescription
þitem EBADF
  HANDLE is not a valid open file descriptor.
þitem ENOTTY
  HANDLE is not associated with a terminal.
þenddescription

þimplementation

    tcflow() currently does nothing and always succeeds.

þrestrictions

    tcflow() is not available with the system call library sys.lib
    (þhpt{-Zsys}).

þseealso tcdrain() tcflush() tcsendbreak() tcsetattr()


þfunction tcflush()
þcompat POSIX.1 *
þheaders
#include <termios.h>
þendheaders

þparam HANDLE QUEUE
þprototype
int tcflush (int HANDLE, int QUEUE);
þendprototype

    tcflush() flushes the input and/or output queues of the terminal
    associated with the file descriptor HANDLE, depending on QUEUE:

þdescription
þitem TCIFLUSH
  Flush the input queue.
þitem TCOFLUSH
  Flush the output queue.
þitem TCIOFLUSH
  Flush the both the input and output queues.
þenddescription

þreturnvalue

    tcflush() returns 0 if successful.  Otherwise, tcflush()
    sets errno and returns -1.

þerrors
þdescription
þitem EBADF
  HANDLE is not a valid open file descriptor.
þitem EINVAL
  QUEUE is not valid.
þitem ENOTTY
  HANDLE is not associated with a terminal.
þenddescription

þimplementation

    tcflush() currently works on the keyboard, only.

þrestrictions

    tcflush() is not available with the system call library sys.lib
    (þhpt{-Zsys}).

    Under DOS, the value of the HANDLE argument must be 0.

þseealso tcdrain() tcflow() tcsendbreak() tcsetattr()


þfunction tcgetattr()
þcompat POSIX.1 *
þheaders
#include <termios.h>
þendheaders

þparam HANDLE PTERMIOS
þprototype
int tcgetattr (int HANDLE, struct termios *PTERMIOS);
þendprototype

    Store the parameters of the terminal associated with the file
    descriptor HANDLE to the object pointed to by PTERMIOS.

    See `þhpt{General terminal interface}' for details.

þreturnvalue

    tcgetattr() returns 0 if successful.  Otherwise, tcgetattr() sets
    errno and returns -1.

þerrors
þdescription
þitem EBADF
  HANDLE is not a valid open file descriptor.
þitem ENOTTY
  HANDLE is not associated with a terminal.
þenddescription

þimplementation

    Currently, errno is set to ENOTTY instead of EBADF if HANDLE is
    out of range.

þrestrictions

    tcgetattr() is not available with the system call library sys.lib
    (þhpt{-Zsys}).

    Under DOS, the value of the HANDLE argument must be 0.

þseealso cfgetispeed() cfgetospeed() tcsetattr()


þfunction tcsendbreak()
þcompat POSIX.1 *
þheaders
#include <termios.h>
þendheaders

þparam HANDLE DURATION
þprototype
int tcsendbreak (int HANDLE, int DURATION);
þendprototype

    tcsendbreak() sends a `break' on an asynchronous line.  The
    duration of the `break' is controlled by DURATION in a
    not-yet-specified way.  If applied to a handle which is not
    associated with an asynchronous line, tcsendbreak() does nothing.

þreturnvalue

    tcsendbreak() returns 0 if successful.  Otherwise, tcsendbreak()
    sets errno and returns -1.

þerrors
þdescription
þitem EBADF
  HANDLE is not a valid open file descriptor.
þitem ENOTTY
  HANDLE is not associated with a terminal.
þenddescription

þimplementation

    tcsendbreak() currently does nothing and always succeeds.

þrestrictions

    tcsendbreak() is not available with the system call library
    sys.lib (þhpt{-Zsys}).

þseealso tcdrain() tcflow() tcflush() tcsetattr()


þfunction tcsetattr()
þcompat POSIX.1 *
þheaders
#include <termios.h>
þendheaders

þparam HANDLE OPTIONS PTERMIOS
þprototype
int tcsetattr (int HANDLE, int OPTIONS, const struct termios *PTERMIOS);
þendprototype

    Set the parameters of the terminal associated with the file
    descriptor HANDLE from the object pointed to by PTERMIOS.  OPTIONS
    must be one of the following symbols:

þdescription
þitem TCSANOW
  The change is performed immediately.
þitem TCSADRAIN
  The change is performed after all output has been transmitted.
þitem TCSAFLUSH
  The change is performed after all output has been transmitted.
  The input queue is flushed before performing the change.
þenddescription

    See `þhpt{General terminal interface}' for details.

þreturnvalue

    tcsetattr() returns 0 if successful.  Otherwise, tcsetattr() sets
    errno and returns -1.

þerrors
þdescription
þitem EBADF
  HANDLE is not a valid open file descriptor.
þitem EINVAL
  OPTIONS is not valid or an attempt was made to change an attribute
  to an unsupported value.
þitem ENOTTY
  HANDLE is not associated with a terminal.
þenddescription

þimplementation

    Currently, errno is set to ENOTTY instead of EBADF if HANDLE is
    out of range.

þrestrictions

    tcsetattr() is not available with the system call library sys.lib
    (þhpt{-Zsys}).

    Under DOS, the value of the HANDLE argument must be 0.

þseealso cfsetispeed() cfsetospeed() tcdrain() tcflush() tcgetattr()


þfunction tell()
þcompat PC
þheaders
#include <io.h>
þendheaders

þparam HANDLE
þprototype
long tell (int HANDLE);
þendprototype

    tell() returns the current position of the file pointer of HANDLE.
    If there is an error, tell() returns -1.

þreturnvalue

    See above.

þseealso lseek()


þfunction tempnam()
þcompat UNIX
þheaders
#include <stdio.h>
þendheaders

þparam DIR PREFIX
þprototype
char *tempnam (const char *DIR, const char *PREFIX);
þendprototype

    Generate a file name suitable for a temporary file without
    overwriting an existing file.  tempnam() returns a pointer to a
    string allocated by malloc().  If the TMP environment variable is
    set and the directory specified by TMP exists, that directory is
    used.  Otherwise, the DIR argument is used.  If DIR is NULL or the
    directory whose name is in the string pointed to by DIR does not
    exist, P_tmpdir as defined in <stdio.h> is used.  If even this
    fails, NULL is returned.  The name of the file will start with the
    string pointed to by PREFIX.  The string pointed to by PREFIX must
    not be longer than 5 characters.

þreturnvalue

    See above.

þseealso tmpnam()


þfunction _tfree()
þcompat OS/2
þheaders
#include <stdlib.h>
þendheaders

þparam MEM
þprototype
void _tfree (void *MEM);
þendprototype

    Deallocate a block of memory allocated by _tmalloc(), _tcalloc()
    or _trealloc().  MEM points to the block of memory.  MEM must have
    been returned by _tmalloc(), _tcalloc() or _trealloc().  Do not
    use MEM after calling _tfree().  If MEM is NULL, _tfree() does
    nothing.

þrestrictions

    If you replace the emx malloc() implementation with a malloc()
    implementation (GNU malloc), for instance) that has not _tmalloc()
    etc. built in, you have to link with the þtt{tmalloc} library
    (-ltmalloc), which implements _tmalloc() etc. on top of malloc()
    etc.

þseealso free() _tcalloc() _tmalloc() _trealloc()


þfunction _theapmin()
þcompat VAC++
þheaders
#include <malloc.h>
þendheaders

þprototype
int _theapmin (void);
þendprototype

    The _theapmin() function returns unused memory of the tiled
    default heap to the operating system.  The heap is never made
    smaller than its initial size.  Calling _theapmin() is equivalent
    to calling _uheapmin() for the tiled default heap.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso brk() _heapchk() sbrk() _heapmin() _uheapmin() _utdefault()


þfunction _threadstore()
þcompat OS/2
þheaders
#include <stdlib.h>
þendheaders

þparam PTR
þprototype
void **_threadstore (void);
þendprototype

    The _threadstore() function returns the address of a pointer to
    thread-specific user-defined data.  Initially, that pointer is
    NULL.  To create thread-specific data, allocate a memory object
    (using malloc(), for instance) and assign the address of that
    memory object to the location returned by _threadstore():

þexample
p = malloc (sizeof (struct user_data));
*_threadstore() = p;
þendexample

    To access a thread-specific variable, use _threadstore() to get
    the pointer to the memory object:

þexample
x = (*_threadstore)->myvar;
þendexample

þreturnvalue

    _threadstore() returns the address of a pointer located in the
    thread-specific data block of the emx C library.

þrestrictions

    _threadstore() is available only in the multithread libraries
    (-Zmt, -Zmts, or -Zmtd).

þseealso _beginthread() _gettid() _threadid


þfunction time()
þcompat C90
þheaders
#include <time.h>
þendheaders

þparam PTR
þprototype
time_t time (time_t *PTR);
þendprototype

    Return the number of seconds elapsed since 00:00:00 1-Jan-1970
    Coordinated Universal Time (UTC, GMT).  The system time is
    converted according to the local timezone.  If PTR is not NULL,
    the result is also stored to the variable pointed to by PTR.

þreturnvalue

    See above.

þseealso ftime() gettimeofday() gmtime() localtime() settimeofday()


þfunction times()
þcompat UNIX
þheaders
#include <time.h>
#include <sys/times.h>
#include <sys/param.h>  /* for HZ */
þendheaders

þparam BUFFER
þprototype
long times (struct tms *BUFFER);
þendprototype

    Return the current time in CLK_TCK fractions of a second since
    00:00:00 1-Jan-1970 Coordinated Universal Time (UTC, GMT).  Also
    sets the tms_utime field of BUFFER to the number of HZ fractions
    of a second the process has been running.  The other fields are
    set to 0.

þreturnvalue

    times() returns the current time in CLK_TCK fractions of a second
    since 00:00 1-Jan-1970 UTC.

þrestrictions

    The return value is unusable due to overflow.

þseealso clock() time()


þfunction _tmalloc()
þcompat OS/2
þheaders
#include <stdlib.h>
þendheaders

þparam SIZE
þprototype
void *_tmalloc (size_t SIZE);
þendprototype

    Allocate a block of memory big enough for holding SIZE bytes.  The
    block will not cross a 64 KByte boundary unless SIZE is greater
    than 65536.  If SIZE is greater than 65536, the block will be
    aligned on a 64 KByte boundary.  Therefore, blocks allocated with
    _tmalloc() can be used with 16-bit functions.  If there is an
    error, _tmalloc() returns NULL.  If SIZE is 0, zero bytes of
    memory are allocated, the return value will be unequal NULL.  Use
    _tfree() to deallocate a block of memory allocated by _tmalloc().

    As _tmalloc() causes additional heap fragmentation, you should not
    use _tmalloc() unless you need an aligned block.

þreturnvalue

    _tmalloc() returns a pointer to a newly allocated block of memory.
    On error, _tmalloc() returns NULL.

þrestrictions

    If you replace the emx malloc() implementation with a malloc()
    implementation (GNU malloc, for instance) that has not _tmalloc()
    etc. built in, you have to link with the þtt{tmalloc} library
    (-ltmalloc), which implements _tmalloc() etc. on top of malloc()
    etc.

þseealso malloc() _tcalloc() _tfree() _trealloc() _utdefault() _utmalloc()


þfunction tmpfile()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þprototype
FILE *tmpfile (void);
þendprototype

    Create and open a temporary file.  The file is opened in
    þtt{"w+b"} mode.  The file will automatically be deleted when the
    stream is closed with fclose() or at program termination.

þreturnvalue

    On success, tmpfile() returns a pointer to the stream associated
    with the temporary file.  If the file cannot be created, tmpfile()
    returns NULL.

þimplementation

    The name of the file is created as if tmpnam() were called.

    The temporary file will not be deleted if the program terminates
    abnormally.

þseealso fclose() _rmtmp() tmpnam()


þfunction tmpnam()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam STRING
þprototype
char *tmpnam (char *STRING);
þendprototype

    Create a unique file name and store it to the array pointed to by
    STRING.  tmpnam() generates a different file name each time it is
    called, up to TMP_MAX times.  If STRING is NULL, a static buffer
    is used which will be overwritten by subsequent calls.  If STRING
    is not NULL, it must point to an array of at least L_tmpnam
    characters.

þreturnvalue

    On success, tmpnam() returns a pointer to the new name.  On
    failure, tmpnam() returns NULL.

þimplementation

    The file name is the concatenation of P_tmpdir and a sequence of
    digits.

þhints

    Use tmpfile() if you need a temporary file but don't need the name
    of that file.  Note that tmpnam() is subject to a race condition:
    other processes may use the same temporary file name before you
    have a chance to create the temporary file.

þseealso tempnam() tmpfile() mktemp()


þfunction tolower() toupper()
þcompat C90
þheaders
#include <ctype.h>
þendheaders

þparam C
þprototype
int tolower (int C);
int toupper (int C);
þendprototype

    tolower() converts the character C to lower case, if it is an
    upper-case letter.  toupper() converts the character C to upper
    case, if it is a lower-case letter.

þreturnvalue

    If the argument of tolower() is a character for which isupper() is
    true and there is a corresponding character for which islower() is
    true, tolower() returns the corresponding character; otherwise
    tolower() returns the argument unchanged.

    If the argument of toupper() is a character for which islower() is
    true and there is a corresponding character for which isupper() is
    true, toupper() returns the corresponding character; otherwise
    toupper() returns the argument unchanged.

þrestrictions

    Currently, locale is ignored.

þseealso setlocale() stricmp() strlwr() strupr() _tolower() _toupper()


þfunction _tolower() _toupper()
þcompat UNIX
þheaders
#include <ctype.h>
þendheaders

þparam C
þprototype
int _tolower (int C);
int _toupper (int C);
þendprototype

    _tolower() converts the upper-case character C to lower case; C
    must be in the range þtt{'A'} through þtt{'Z'}.  _toupper()
    converts the lower-case character C to upper case; C must be in
    the range þtt{'a'} through þtt{'z'}.

þreturnvalue

    See above.

þseealso tolower() toupper()


þfunction _trealloc()
þcompat OS/2
þheaders
#include <stdlib.h>
þendheaders

þparam MEM SIZE
þprototype
void *_trealloc (void *MEM, size_t SIZE);
þendprototype

    Reallocate the block of memory pointed to by MEM, making it big
    enough to hold SIZE bytes.  The block will not cross a 64 KByte
    boundary unless SIZE is greater than 65536.  If SIZE is greater
    than 65536, the block will be aligned on a 64 KByte boundary.  If
    MEM is NULL, a new block of memory is allocated.  Otherwise, MEM
    must be a pointer returned by _tcalloc(), _tmalloc() or
    _trealloc(); the size of MEM is adjusted.  If MEM is non-þtt{NULL}
    and SIZE is zero, the block is freed and NULL is returned.  If MEM
    cannot be expanded in-place, it is moved.  A pointer to the new,
    resized block of memory is returned.  If there is not enough
    memory available, NULL is returned.

    MEM can also be a pointer to a block of memory freed by _tfree()
    as long as calloc(), malloc(), realloc(), _tcalloc(), _tmalloc()
    and _trealloc() have not been called since freeing the block.
    Using this feature is not recommended, it may get removed in
    future implementations of _trealloc().

þreturnvalue

    _trealloc() returns MEM (if the block could be resized without
    moving), a pointer to a newly allocated block of memory, or NULL
    (if there wasn't enough memory).

þrestrictions

    If you replace the emx malloc() implementation with a malloc()
    implementation (GNU malloc, for instance) that has not _tmalloc()
    etc. built in, you have to link with the þtt{tmalloc} library
    (-ltmalloc), which implements _tmalloc() etc. on top of malloc()
    etc.

þseealso realloc() _tmalloc() _utdefault()


þfunction trunc() truncl()
þcompat C9X
þheaders
#include <math.h>
þendheaders

þparam X
þprototype
double trunc (double X);
long double truncl (long double X);
þendprototype

    Return as floating-point number X chopped to an integer by
    truncating the fractional digits (rounding toward 0).

    truncl() uses the þtt{long double} format.

þreturnvalue

    See above.

þseealso ceil() floor() modf() rint()


þfunction truncate()
þcompat BSD
þheaders
#include <io.h>
þendheaders

þparam NAME LENGTH
þprototype
int truncate (char *NAME, long LENGTH);
þendprototype

    Truncate a file to at most LENGTH bytes.  NAME is a pointer to a
    string containing the name of the file.  If LENGTH is greater than
    the current length of the file, the length is not changed.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso chsize() ftruncate()


þfunction ttyname()
þcompat POSIX.1
þheaders
#include <unistd.h>
þendheaders

þparam HANDLE
þprototype
char *ttyname (int HANDLE);
þendprototype

    Return a pointer to a string containing the pathname of the device
    associated with file descriptor HANDLE.

    The pointer returned by ttyname() may point to a static buffer
    which is overwritten by each call of ttyname().

þreturnvalue

    If successful, ttyname() returns a pointer to a null-terminated
    string.  On error, ttyname() returns NULL.

þrestrictions

    ttyname() is not implemented for DOS.  ttyname() is not available
    with the system call library sys.lib (þhpt{-Zsys}).

    ttyname() is implemented for the following devices only:
    þtt{/dev/con}, þtt{/dev/nul}, þtt{/dev/clock$}, and the devices of
    Holger Veit's þtt{xf86sup.sys} device driver.

þseealso fstat() isatty()


þfunction tzset()
þcompat C90 VAC++
þheaders
#include <time.h>
þendheaders

þprototype
void tzset (void);
þendprototype

    Set timezone according to the TZ environment variable.  The
    following global variables are set by tzset(): þtt{daylight},
    þtt{timezone}, tzname.  The value of TZ has the following format:

þindent
    þsy{<TZ1>[<OFF>,[<TZ2>[,<SM>,<SW>,<SD>,<ST>,<EM>,<EW>,<ED>,<ET>,<SHIFT>]]]}
þendindent

    þsy{<TZ1>} is the three-letter name of the standard timezone.

    þsy{<OFF>} is the offset to Coordinated Universal Time; positive
    values are to the west of the Prime Meridian, negative values are
    to the east of the Prime Meridian.  The offset can be specified as
    hours, hours and minutes, or hours, minutes, and seconds.  Hours,
    minutes, and seconds are separated by colons.  If þsy{<OFF>} is
    not specified, an offset of 0 will be used (this may change in the
    future).

    þsy{<TZ2>} is the three-letter name of the summer timezone
    (daylight saving time).  If þsy{<TZ2>} is not specified, daylight
    saving time does not apply.  If þsy{<TZ2>} is specified, daylight
    saving time does apply; the remainder of the TZ's value specifies
    when and how to change to and back from daylight saving time.
    þsy{<SM>} through þsy{<ST>} define, in current local time, when to
    switch from standard time to daylight saving time, þsy{<EM>}
    through þsy{<ET>} define, in current local time, when to switch
    from daylight saving time to standard time.  (On the southern
    hemisphere, the end date precedes the start date.)  þsy{<SHIFT>} is
    the amount of change in seconds.

    þsy{<SM>} specifies the month (1 through 12) of the change.
    þsy{<SW>} specifies the week of the change; if this value is zero,
    þsy{<SD>} specifies the day of month (1 through 31).  If þsy{<SW>}
    is positive (1 through 4), the change occurs on weekday þsy{<SD>}
    (0=Sunday through 6=Saturday) of the þsy{<SW>}th week of the
    specified month.  The first week of a month starts on the first
    Sunday of the month.  If þsy{<SW>} is negative (-1 through -4),
    the change occurs on weekday þsy{<SD>} (0=Sunday through
    6=Saturday) of the -þsy{<SW>}th week of the specified month,
    counted from the end of the month (that is, -1 specifies the last
    week of the month).  The last week of a month starts on the last
    Sunday of the month.  þsy{<ST>} specifies the time of the change,
    in seconds.  Note that þsy{<ST>} is specified in local standard
    time and þsy{<ET>} is specified in local daylight saving time.
    Example:

þexample
CET-1CED,3,-1,0,7200,10,-1,0,10800,3600
þendexample

    In this example, the name of the standard time zone is þtt{CET},
    the name of the summer time zone is CED.  Daylight saving time
    starts at 2:00 on the last Sunday of March and ends at 3:00 on the
    last Sunday of October.  Time changes by one hour in daylight
    saving time.

    If no characters follow þsy{<TZ2>}, the rule
    `þtt{,4,1,0,3600,10,-1,0,7200,3600}' will be used: Daylight saving
    time starts at 1:00 on the first Sunday of April and ends at 2:00
    on the last Sunday of October.  Time changes by one hour in
    daylight saving time.

    If the value of TZ is invalid, tzset() does not have any effect.

þimplementation

    If TZ is not set, Coordinated Universal Time will be used.

    The three-character limit for timezone names and the weird and
    US-based definition of `first week' and `last week' are required
    for compatibility with applications compiled with VAC++.

þrestrictions

    After changing the value of TZ by modifying environ, you should
    call tzset().  That is not required when changing TZ with putenv().

þseealso environ putenv()


þfunction _uaddmem()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam H MEMORY SIZE CLEAN
þprototype
Heap_t _uaddmem (Heap_t H, void *MEMORY, size_t SIZE, int CLEAN);
þendprototype

    _uaddmem() adds memory to the heap H.  MEMORY points to the memory
    area to be added, SIZE is the size of the memory area in bytes.
    CLEAN should be _BLOCK_CLEAN if the memory area has been
    initialized to zeros; CLEAN should be þtt{!_BLOCK_CLEAN} if the
    memory area contains or may contain non-zero bytes.  If the heap
    is shared, MEMORY should point to shared memory.

    If the memory area added by _uaddmem() is adjacent to (the end of)
    one of the segments of the heap, that segment will be expanded.
    Otherwise, a new segment will be created and a number of bytes of
    the memory area will be used for storing control information.

þhints

    Add few large memory areas instead of many small memory areas to
    minimize the total overhead of the control information added to
    the segments.  Moreover, the size of the segments limits the size
    of the blocks which can be allocated from the heap.

    Memory allocated with DosAllocMem is initialized to zeros.

þreturnvalue

    _uaddmem() returns H if successful.  _uaddmem() returns NULL on
    error.

þseealso sbrk() _ucreate() _ucreate2() _udestroy()


þfunction _ucalloc()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam H ELEMENTS SIZE
þprototype
void *_ucalloc (Heap_t H, size_t ELEMENTS, size_t SIZE);
þendprototype

    Allocate from the heap H a block of memory big enough for holding
    ELEMENTS elements of SIZE bytes each.  _ucalloc() fills the block
    with zeros.  If there is an error, _ucalloc() returns NULL.

þimplementation

    If at least one argument is zero, _ucalloc() returns a non-NULL
    pointer if there's enough space left in the heap for a block of
    the minimum size.

þreturnvalue

    _ucalloc() returns a pointer to a newly allocated block of memory.
    On error, _ucalloc() returns NULL.

þseealso calloc() free() _msize() _udefault() _umalloc() _utcalloc()


þfunction _ucreate()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam MEMORY SIZE CLEAN TYPE ALLOC_FUN RELEASE_FUN
þprototype
Heap_t _ucreate (void *MEMORY, size_t SIZE, int CLEAN, unsigned TYPE,
                 void *(*ALLOC_FUN)(Heap_t, size_t *, int *),
                 void (*RELEASE_FUN)(Heap_t, void *, size_t));
þendprototype

    _ucreate() creates a heap in the memory area pointed to by MEMORY
    of size SIZE bytes.  SIZE must be at least _HEAP_MIN_SIZE.  CLEAN
    should be _BLOCK_CLEAN if the memory area has been initialized to
    zeros; CLEAN should be þtt{!_BLOCK_CLEAN} if the memory area
    contains or may contain non-zero bytes.  TYPE specifies the type
    of the heap: _HEAP_REGULAR (regular, not tiled) or _HEAP_TILED.
    All memory allocated from a tiled heap will be appropriately
    aligned (tiled) for 16-bit functions.  In addition to
    _HEAP_REGULAR or _HEAP_TILED, TYPE may include _HEAP_SHARED (using
    the þtt{|} operator) if MEMORY points to shared memory.  If
    _HEAP_SHARED is set, the heap can be shared between processes.
    The remaining two arguments are pointers to callback functions for
    allocating and releasing additional memory objects (segments) for
    the heap.  Any or all of these arguments may be NULL to indicate
    that no callback function is provided.  _ucreate() returns a
    pointer to the new heap or, on error, NULL.

    Before the new heap can be used, _uopen() must be called.  To
    destroy the heap, call _uclose() and _udestroy(), then deallocate
    the memory area pointed to by MEMORY if appropriate.  You can use
    the new heap as default heap by calling _udefault() or as tiled
    default heap by calling _utdefault().

    The function pointed to by ALLOC_FUN is called to allocate more
    memory for the heap.  See þhpt{_ucreate2()} for details.  If
    ALLOC_FUN is NULL, the size of the heap is fixed; if the initial
    size is exhausted, allocation will fail.

    The function pointed to by RELEASE_FUN is called to deallocate
    memory memory allocated by the function pointed to by ALLOC_FUN.
    See þhpt{_ucreate2()} for details.  If RELEASE_FUN is NULL,
    _udestroy() and _uheapmin() won't release memory.

    _ucreate2() is equivalent to _ucreate() with NULL passed for
    þpa{EXPAND_FUN} and þpa{SHRINK_FUN}.

þreturnvalue

    _ucreate() returns a pointer to the new heap if successful.
    _ucreate() returns NULL on error.

þseealso sbrk() _ucreate2() _udefault() _udestroy() _uheapchk() _umalloc() _uopen() _utdefault()

þsamplecode
#define INCL_DOSMEMMGR
#include <os2.h>
#include <umalloc.h>

Heap_t create_shared_heap (const char *name, size_t size)
{
  ULONG rc;
  void *mem;
  Heap_t h;

  rc = DosAllocSharedMem (&mem, name, size,
                          PAG_COMMIT | PAG_READ | PAG_WRITE);
  if (rc != 0)
    return NULL;
  h = _ucreate (mem, size, !_BLOCK_CLEAN, _HEAP_REGULAR | _HEAP_SHARED,
                NULL, NULL);
  if (h == NULL)
    DosFreeMem (mem);
  return h;
}
þendsamplecode


þfunction _ucreate2()
þcompat emx
þheaders
#include <umalloc.h>
þendheaders

þparam MEMORY SIZE CLEAN TYPE ALLOC_FUN RELEASE_FUN EXPAND_FUN SHRINK_FUN
þparam H PSIZE PCLEAN BASE OLD_SIZE PNEW_SIZE
þprototype
Heap_t _ucreate2 (void *MEMORY, size_t SIZE, int CLEAN, unsigned TYPE,
                  void *(*ALLOC_FUN)(Heap_t, size_t *, int *),
                  void (*RELEASE_FUN)(Heap_t, void *, size_t),
                  int (*EXPAND_FUN)(Heap_t, void *, size_t, size_t *, int *),
                  void (*SHRINK_FUN)(Heap_t, void *, size_t, size_t *));
þendprototype

    _ucreate2() creates a heap in the memory area pointed to by MEMORY
    of size SIZE bytes.  SIZE must be at least _HEAP_MIN_SIZE.  CLEAN
    should be _BLOCK_CLEAN if the memory area has been initialized to
    zeros; CLEAN should be þtt{!_BLOCK_CLEAN} if the memory area
    contains or may contain non-zero bytes.  TYPE specifies the type
    of the heap: _HEAP_REGULAR (regular, not tiled) or _HEAP_TILED.
    All memory allocated from a tiled heap will be appropriately
    aligned (tiled) for 16-bit functions.  In addition to
    _HEAP_REGULAR or _HEAP_TILED, TYPE may include _HEAP_SHARED (using
    the þtt{|} operator) if MEMORY points to shared memory.  If
    _HEAP_SHARED is set, the heap can be shared between processes.
    The remaining four arguments are pointers to callback functions
    for allocating, releasing, expanding, or shrinking additional
    memory objects (segments) for the heap.  Any or all of these
    arguments may be NULL to indicate that no callback function is
    provided.  _ucreate2() returns a pointer to the new heap or, on
    error, NULL.

    Before the new heap can be used, _uopen() must be called.  To
    destroy the heap, call _uclose() and _udestroy(), then deallocate
    the memory area pointed to by MEMORY if appropriate.  You can use
    the new heap as default heap by calling _udefault() or as tiled
    default heap by calling _utdefault().  You can add more memory to a
    heap with _uaddmem().

    The function pointed to by ALLOC_FUN is called to allocate more
    memory for the heap:

þindent
    þtt{void *my_alloc (Heap_t }Hþtt{, size_t *}PSIZEþtt{, int *}PCLEANþtt{);}
þendindent

    H points to the heap to be expanded.  Note that the heap is
    locked, so passing H to a heap-specific library function (except
    for _uheap_type()) will cause a deadlock.  If the heap is shared,
    the function shall allocate shared memory. The function can call
    _uheap_type() to query the type of memory required.  PSIZE points
    to an object containing the desired size of the memory area to be
    allocated.  The function may allocate more memory than requested;
    it's recommended to allocate a multiple of 65536 bytes.  The
    function may also allocate less memory than requested; however, it
    must not do so twice in a row.  This can be used to fill gaps
    caused by non-contiguous memory allocation.  The function shall
    store to the object pointed to by PSIZE the actual number of bytes
    allocated.  Moreover, the function shall store _BLOCK_CLEAN or
    þtt{!}_BLOCK_CLEAN to the object pointed to by PCLEAN depending on
    whether the memory area has been initialized to zeros or not,
    respectively.  The function shall return a pointer to the memory
    area it has allocated or NULL if the allocation request could not
    be satisfied.  If the function returns a pointer to a memory area
    adjacent to (the end of) another memory area of the heap, that
    memory area will be expanded, so that blocks spanning both memory
    areas can be allocated.

    If ALLOC_FUN is NULL, the size of the heap is fixed; if the
    initial size is exhausted, allocation will fail.  However, you can
    add more memory to a heap with þhpt{_uaddmem()}.

    The function pointed to by RELEASE_FUN is called to deallocate
    memory memory allocated by the function pointed to by ALLOC_FUN:

þindent
    þtt{void my_release (Heap_t }Hþtt{, void *}MEMORYþtt{, size_t }SIZEþtt{);}
þendindent

    H points to the heap for which the memory area has been allocated.
    Note that the heap is locked, so passing H to a heap-specific
    library function will cause a deadlock.  MEMORY points to the
    memory area to be deallocated; the memory area has been allocated
    by the function pointed to by ALLOC_FUN.  SIZE is the size of the
    memory area, as reported by the function pointed to by ALLOC_FUN.

    If RELEASE_FUN is NULL, _udestroy() and _uheapmin() won't release
    memory.

    The function pointed to by EXPAND_FUN is called to expand a memory
    area of the heap:

þindent
    þtt{int my_expand (Heap_t }Hþtt{, void *}BASEþtt{, size_t }OLD_SIZEþtt{,} þbreak
    þtt{               size_t *}PNEW_SIZEþtt{, int *}PCLEANþtt{);}
þendindent

    H points to the heap to be expanded.  Note that the heap is
    locked, so passing H to a heap-specific library function will
    cause a deadlock.  BASE points to the memory area to expand; it
    points either to the initial memory area for the heap (passed as
    MEMORY to _ucreate() or _ucreate2()) or to a memory area allocated
    by the function pointed to by ALLOC_FUN.  The memory area
    currently has a size of OLD_SIZE bytes (as passed as SIZE to
    _ucreate() or _ucreate2() or as reported by the function pointed
    to by ALLOC_FUN or EXPAND_FUN).  PNEW_SIZE points to an object
    containing the size to which the memory area should be expanded.
    The function may expand the memory area more than requested; it's
    recommended to expand to a multiple of 65536 bytes.  Expanding the
    memory area less than requested is also possible, but not
    recommended.  The function shall store the actual new size of the
    memory area to the object pointed to by PNEW_SIZE.  Moreover, the
    function shall store _BLOCK_CLEAN or þtt{!}_BLOCK_CLEAN to the
    object pointed to by PCLEAN depending on whether the additional
    memory has been initialized to zeros or not, respectively.  The
    function shall return a non-zero value if expansion succeeded, or
    0 if if the expansion request could not be satisfied.

    If EXPAND_FUN is NULL, _expand() and realloc() won't attempt to
    expand the heap to expand in place the last block of a heap
    segment.  Instead, the function pointed to by ALLOC_FUN might be
    called to expand the heap non-contiguously.

    The function pointed to by SHRINK_FUN is called to shrink a memory
    area of the heap:

þindent
    þtt{void my_shrink (Heap_t }Hþtt{, void *}MEMORYþtt{, size_t }OLD_SIZEþtt{,} þbreak
    þtt{                size_t *}PNEW_SIZEþtt{);}
þendindent

    H points to the heap to be shrunk.  Note that the heap is locked,
    so passing H to a heap-specific library function will cause a
    deadlock.  MEMORY points to the memory area to shrunk; it points
    to a memory area allocated by the function pointed to by
    ALLOC_FUN.  Note that the initial memory area is never shrunk
    below its initial size.  The memory area currently has a size of
    OLD_SIZE bytes (as reported by the function pointed to by
    ALLOC_FUN or EXPAND_FUN).  PNEW_SIZE points to an object
    containing the size to which the memory area should be shrunk;
    that size might be 0.  The function may shrink the memory area
    less than requested; it's recommended to shrink to a multiple of
    65536 bytes.  The function shall store the actual new size of the
    memory area to the object pointed to by PNEW_SIZE.  If the memory
    area cannot be shrunk, the function shall store OLD_SIZE to the
    object pointed to by PNEW_SIZE.

    If SHRINK_FUN is NULL, _uheapmin() won't attempt to shrink memory
    areas; however, it will still try to deallocate memory areas if
    RELEASE_FUN is not NULL.

þreturnvalue

    _ucreate2() returns a pointer to the new heap if successful.
    _ucreate2() returns NULL on error.

þimplementation

    If you need compatibility with VAC++, use _ucreate() instead of
    _ucreate2().  Note that VAC++ does not allow ALLOC_FUN to allocate
    less memory than requested.

þhints

    Memory allocated with DosAllocMem is initialized to zeros.

þseealso sbrk() _ucreate() _udefault() _udestroy() _uheapchk() _uheap_type() _umalloc() _uopen() _utdefault()


þfunction _uclose()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam H
þprototype
int _uclose (Heap_t H);
þendprototype

    Close the heap H.  Heaps should be closed before destruction with
    _udestroy().  Shared heaps should be closed when they are no
    longer used; they should be closed by all processes before
    destruction with _udestroy().  After closing a heap, all attempts
    to access the heap will invoke undefined behavior.  _uclose()
    fails if H is the runtime heap (_RUNTIME_HEAP) or the tiled
    runtime heap.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso _ucreate() _ucreate2() _udestroy() _uopen()


þfunction _udefault()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam H
þprototype
Heap_t _udefault (Heap_t H);
þendprototype

    The _udefault() function selects the heap pointed to by H as the
    default heap of the current thread unless H is NULL.  All
    non-tiled memory allocation functions such as malloc() which don't
    take a pointer to a heap will use the heap pointed to by H if
    called in the same thread.  If H is NULL, _udefault() won't set
    the default heap.

    Initially, the runtime heap, _RUNTIME_HEAP, is used as default
    heap for all threads.  You can make _RUNTIME_HEAP again the
    default heap of the current thread by calling
    þtt{_udefault(_RUNTIME_HEAP)}.

þreturnvalue

    _udefault() returns a pointer to the previous default heap of the
    current thread.  If the default heap has not yet been created,
    _udefault() will return NULL.

þhints

    You can use _udefault() to assign a unique heap to each thread or
    to share the default heap between multiple processes.

    To obtain a pointer to the default heap of the current thread
    without selecting a new heap, call þtt{_udefault(NULL)}.

þseealso _mheap() _ucreate() _ucreate2() _utdefault()

þsamplecode
Heap_t *my_heap, old_heap;

old_heap = _udefault (my_heap);
/*...*/
_udefault (old_heap);   /* Restore previous default heap */
þendsamplecode


þfunction _udestroy()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam H FORCE
þprototype
int _udestroy (Heap_t H, int FORCE);
þendprototype

    Destroy the heap H.  If there are any blocks of the heap in use
    (not freed) and FORCE is þtt{!_FORCE}, _udestroy() fails.  If
    FORCE is _FORCE, the heap will be destroyed even if there are
    blocks in use.

    The function passed to the þpa{RELEASE_FUN} argument (if not NULL)
    of þhpt{_ucreate()} and þhpt{_ucreate2()} is called to deallocate
    all segments added to the heap, that is, all memory assigned to
    the heap except for the initial memory area passed to _ucreate()
    or _ucreate2().

    _udestroy() fails if H is the runtime heap (_RUNTIME_HEAP) or the
    tiled runtime heap.  þhpt{_uclose()} should be called before
    _udestroy().  After destroying a heap, all attempts to access the
    heap will invoke undefined behavior.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso _uaddmem() _uclose() _ucreate() _ucreate2() _udefault() _uheapmin()


þfunction _uflags()
þcompat emx
þheaders
#include <sys/uflags.h>
þendheaders

þparam MASK NEW_BITS
þprototype
int _uflags (int MASK, int NEW_BITS);
þendprototype

    Set bits which control the behavior of the emx runtime library
    (emx.dll, emx.exe, or sys.lib).  Bits set in MASK are replaced
    with the matching bits of NEW_BITS:

þexample
bits = ((bits & ~mask) | (new_bits & mask));
þendexample

    If MASK is 0, the bits are not changed.  MASK should be one of the
    following symbols:
þdescription
þitem _UF_SIG_MODEL
    Signal processing model
þitem _UF_SBRK_MODEL
    Memory allocation model for sbrk()
þitem _UF_PTRACE_MODEL
    Debugging model for ptrace()
þenddescription
    If MASK includes _UF_SIG_MODEL, exactly one of the following
    symbols should be used in NEW_BITS:
þdescription
þitem _UF_SIG_EMX
    Select the emx signal processing model for signal() -- this is the
    default setting
þitem _UF_SIG_SYSV
    Select the System V signal processing model for signal().  The
    -Zsysv-signals option selects _UF_SIG_SYSV
þitem _UF_SIG_BSD
    Select the BSD and POSIX.1 signal processing model for signal().
    The -Zbsd-signals option selects _UF_SIG_BSD
þenddescription
    If MASK includes _UF_SBRK_MODEL, exactly one of the following
    symbols should be used in NEW_BITS:
þdescription
þitem _UF_SBRK_CONTIGUOUS
    sbrk() always allocates contiguous memory; the size of the heap is
    limited to the initial heap size.  This is the initial setting;
    however, the malloc() implementation of emx selects
    _UF_SBRK_ARBITRARY
þitem _UF_SBRK_MONOTONOUS
    sbrk() may allocate non-contiguous memory with increasing
    addresses; up to 16 memory objects can be used for the heap
þitem _UF_SBRK_ARBITRARY
    sbrk() may allocate non-contiguous memory with arbitrary
    addresses; up to 16 memory objects can be used for the heap.  The
    malloc() implementation of emx selects _UF_SBRK_ARBITRARY
þenddescription
    If MASK includes _UF_PTRACE_MODEL, exactly one of the following
    symbols should be used in NEW_BITS:
þdescription
þitem _UF_PTRACE_STANDARD
    ptrace() doesn't report creation and termination of threads and
    loading and freeing of modules (DLLs); moreover, ptrace() doesn't
    support multiple threads.  This is the initial setting.
þitem _UF_PTRACE_NOTIFY
    ptrace() may report creation and termination of threads and
    loading and freeing of modules (DLLs); ptrace() does not support
    multiple threads.
þitem _UF_PTRACE_MULTITHREAD
    ptrace() may report creation and termination of threads and
    loading and freeing of modules (DLLs); moreover, ptrace() does
    support multiple threads; this model also modifies the return
    values of wait() and waitpid() for processes being under control
    of ptrace().
þenddescription
    To pass multiple values, use the þtt{|} operator to combine the
    symbols.

    _uflags() should not be called by application programs.
    _UF_SBRK_MONOTONOUS and _UF_SBRK_ARBITRARY should not be selected
    unless all callers of sbrk() know how to cope with non-contiguous
    memory.

    The -Zsysv-signals and -Zbsd-signals options of GCC add startup
    code which calls _uflags().

þreturnvalue

    _uflags() returns the previous set of bits (ie, the set of bits
    which was in effect when _uflags() was called).

þrestrictions

    Under DOS, memory is always contiguous, _UF_SBRK_MONOTONOUS and
    _UF_SBRK_ARBITRARY are ignored.  _UF_SIG_SYSV and _UF_SIG_BSD are
    not supported with the system call library sys.lib (þhpt{-Zsys}).
    Under DOS, the _UF_PTRACE_MODEL settings are ignored.

þseealso brk() sbrk() sigaction() signal() ptrace() ulimit() wait()


þfunction _uheapchk()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam H
þprototype
int _uheapchk (Heap_t H);
þendprototype

    _uheapchk() checks the heap pointed to by H and all its blocks for
    consistency.  Note that _uheapchk() may crash if the heap is
    corrupted.  _uheapchk() can help debugging programs which
    experience heap problems.

    Use _heapchk() to check the default heap and the tiled default
    heap.

þreturnvalue

    _uheapchk() returns one of the following values:
þdescription
þitem _HEAPBADBEGIN
    The heap is corrupted.
þitem _HEAPBADEND
    The heap is corrupted.
þitem _HEAPBADNODE
    A block of the heap is damaged or the heap is corrupted.
þitem _HEAPEMPTY
    The heap has not been initialized.
þitem _HEAPOK
    The heap seems to be consistent.
þenddescription

þseealso _heapchk() _uheapset() _uheap_walk()


þfunction _uheapmin()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam H
þprototype
int _uheapmin (Heap_t H);
þendprototype

    The _uheapmin() function returns unused memory of the heap H to
    the operating system.  The heap is never made smaller than its
    initial size.  The function passed to the þpa{RELEASE_FUN} argument
    (if not NULL) of þhpt{_ucreate()} and þhpt{_ucreate2()} is called
    to deallocate segments of the heap which don't contain any
    allocated blocks.  The function pased to the þpa{SHRINK_FUN}
    argument (if not NULL) of _ucreate2() is called to shrink segments
    which have free space at the end (except for the initial memory
    area passed to _ucreate2()).

    You can use _heapmin() and _theapmin() to minimize the default
    regular heap and tiled default heap, respectively.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso brk() _heapmin() _uheapchk() sbrk() _theapmin() _ucreate() _ucreate2() _ustats()


þfunction _uheapset()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam H FILL
þprototype
int _uheapset (Heap_t H, unsigned FILL);
þendprototype

    _uheapset() fills all bytes of all unused blocks of the heap
    pointed to by H with FILL.  Note that _uheapset() may crash if the
    heap is corrupted.  _uheapset() can help debugging programs which
    erroneously depend on the contents of dynamically allocated
    blocks.  þhpt{_uheapchk()} checks the heap more thoroughly than
    _heapset().

    Use _heapset() to fill the default heap and the tiled default
    heap.

þreturnvalue

    _uheapset() returns one of the following values:
þdescription
þitem _HEAPBADBEGIN
    The heap is corrupted.
þitem _HEAPBADEND
    The heap is corrupted.
þitem _HEAPBADNODE
    A block of the heap is damaged or the heap is corrupted.
þitem _HEAPEMPTY
    The heap has not been initialized.
þitem _HEAPOK
    The heap seems to be consistent.
þenddescription

þseealso _heapset() _uheapchk() _uheap_walk()


þfunction _uheap_type()
þcompat emx
þheaders
#include <umalloc.h>
þendheaders

þparam H
þprototype
unsigned _uheap_type (Heap_t H);
þendprototype

    The _uheap_type() function returns the type of the heap H, as
    specified by the þpa{TYPE} argument of þhpt{_ucreate()} and
    þhpt{_ucreate2()}.

þreturnvalue

    The _uheap_type() function returns a combination of the
    _HEAP_REGULAR, _HEAP_TILED, and _HEAP_SHARED values.

þhints

    This function can be useful in allocation functions which are used
    for different heaps.

þseealso _uaddmem() _ucreate() _ucreate2()


þfunction _uheap_walk2()
þcompat emx
þheaders
#include <umalloc.h>
þendheaders

þparam H CALLBACK ARG
þparam BLOCK SIZE FLAG STATUS FNAME LINENO
þprototype
int _uheap_walk2 (Heap_t H,
                  int (*CALLBACK)(Heap_t, const void *, size_t, int, int,
                                  const char *, size_t, void *),
                  void *ARG);
þendprototype

    Apply the function pointed to by CALLBACK to all free and used
    blocks of the heap H.  Note that the heap is locked, so using the
    heap in the callback function will cause a deadlock.  ARG will be
    passed on to the callback function.

þindent
    þtt{int my_walker (Heap_t }Hþtt{, const void *}BLOCKþtt{, size_t }SIZEþtt{, int }FLAGþtt{,} þbreak
    þtt{               int }STATUSþtt{, const char *}FNAMEþtt{, size_t }LINENOþtt{,} þbreak
    þtt{               void *}ARGþtt{);}
þendindent

    H points to the heap being examined, it's the same value as passed
    to _uheap_walk2().  BLOCK points to a block of SIZE bytes.  FLAG
    is either _USEDENTRY (for a used block) or _FREEENTRY (for a free
    block).  STATUS is one of the following values, describing the
    status of the block:

þdescription
þitem _HEAPBADBEGIN
    The heap is corrupted.
þitem _HEAPBADEND
    The heap is corrupted.
þitem _HEAPBADNODE
    The block is damaged.
þitem _HEAPEMPTY
    The heap has not been initialized.
þitem _HEAPOK
    The heap seems to be consistent (_HEAPOK is 0).
þenddescription

    FNAME points to the file name of the source file in which the
    block has been allocated.  LINENO is the line number in which the
    block has been allocated.  FNAME is NULL if that information is
    not available, that is, if the object has not been allocated with
    a debugging heap function.  ARG is the same value as passed to
    _uheap_walk2().


þreturnvalue

    _uheap_walk2() returns the last status (see above for a list of
    values) unless the callback function returned a non-zero value.
    If the callback function returned a non-zero value, _uheap_walk2()
    returns that value.

þrestrictions

    FNAME is current always NULL as there are no debugging heap
    functions.

þimplementation

    If you need compatibility with VAC++, use _uheap_walk() instead of
    _uheap_walk2().

þhints

    Use an extra heap if you want to allocate memory in the callback
    function.

þseealso _heap_walk() _uheap_walk()


þfunction ulimit()
þcompat UNIX
þheaders
#include <ulimit.h>
þendheaders

þparam REQUEST
þprototype
long ulimit (int REQUEST, ...);
þendprototype

    Get or set process limits.  The following REQUEST codes are
    implemented:

þdescription
þitem UL_GFILLIM

    Return the maximum file size.  Always returns þtt{1 << 21}.

þitem UL_SFILLIM

    Set the maximum file size according to the second argument which
    is of type þtt{int}.  Ignored.  Returns the second argument.

þitem UL_GMEMLIM

    Return the greatest possible break value.

þitem UL_NOFILES

    Return the number of files that can be open simultaneously per
    process.  Always returns 40.

þitem UL_OBJREST

    Return the number of bytes remaining in the current heap object.
    Let þpa{N} be the return value of þtt{ulimit(UL_OBJREST)}.  If
    allocation of non-contiguous memory is disabled, up to þpa{N}
    bytes can be allocated with brk() or sbrk().  Attempts to allocate
    more than þpa{N} bytes will fail.  If allocation of
    non-contiguous memory has been enabled with _uflags(), requests
    for up to þpa{N} bytes will yield contiguous memory; calling
    sbrk() with an argument greater than þpa{N} will create a new heap
    object, leaving a gap between the previous heap object and the new
    one.

þenddescription

þreturnvalue

    See above.

þimplementation

    UL_GFILLIM and UL_NOFILES return dummy values.  UL_SFILLIM is
    ignored.  UL_OBJREST is an emx extension.

þseealso brk() sbrk() _uflags()


þfunction _umalloc()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam H SIZE
þprototype
void *_umalloc (Heap_t H, size_t SIZE);
þendprototype

    Allocate from the heap H a block of memory big enough for holding
    SIZE bytes.  If there is an error, _umalloc() returns NULL.  If
    SIZE is 0, zero bytes of memory are allocated, the return value
    will be unequal NULL.

þreturnvalue

    _umalloc() returns a pointer to a newly allocated block of memory.
    On error, _umalloc() returns NULL.

þimplementation

    þtt{_umalloc(0)} returns a non-NULL pointer if there's enough
    space left in the heap for a block of the minimum size.

þseealso free() malloc() _msize() realloc() _ucalloc() _utmalloc()


þfunction umask()
þcompat UNIX
þheaders
#include <io.h>
þendheaders

þparam PMODE
þprototype
int umask (int PMODE);
þendprototype

    Set the file-permission mask of the current process to PMODE.
    Only the S_IWRITE bit is used.  Either specify
    þtt{S_IREAD|S_IWRITE} or þtt{S_IREAD} for PMODE.

þreturnvalue

    umask() returns the previous file-permission mask.

þrestrictions

    The current file-permission mask is inherited by emx programs
    spawned under DOS.  Under OS/2, the file-permission mask is not
    yet inherited.  When spawning a non-emx program (such as
    command.com, see þhpt{system()}) which spawns an emx program, that
    program won't inherit the file-permission mask.

þseealso fopen() open()


þfunction uname()
þcompat UNIX
þheaders
#include <sys/utsname.h>
þendheaders

þparam NAME
þprototype
int uname (struct utsname *NAME);
þendprototype

    Store information identifying the current system to the structure
    pointed to by NAME.

þreturnvalue

    uname() always returns 0 (always successful).

þfunction ungetc()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam C STREAM
þprototype
int ungetc (int C, FILE *STREAM);
þendprototype

    Push back the character C onto STREAM and clear the end-of-file
    indicator.  STREAM must be open for reading.  The next read
    operation on STREAM starts with C.  If C is EOF, nothing is done.
    Only one character can be pushed onto a stream.  fflush(),
    fseek(), fsetpos() and rewind() undo ungetc().  After a successful
    ungetc(), the value of the file pointer is undefined until the
    character has been read.

þreturnvalue

    On success, ungetc() returns the character C.  On failure,
    ungetc() returns EOF.

þseealso fgetc() fflush()


þfunction unlink()
þcompat UNIX

þheaders
#include <unistd.h>     /* use this */
#include <io.h>         /* or this */
þendheaders

þparam NAME
þprototype
int unlink (const char *NAME);
þendprototype

    Delete a file.  NAME is a pointer to a string containing the name
    of the file to be deleted.  Under OS/2 and DOS, unlink() and
    remove() are equivalent.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þimplementation

    If the read-only attribute of the file is set, unlink() sets errno
    to EPERM and returns -1.

    If the file is open in any process, unlink() sets errno to EACCES
    and returns -1.

þseealso remove()


þfunction _uopen()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam H
þprototype
int _uopen (Heap_t H);
þendprototype

    Open the heap H.  Before a heap created with _ucreate() or
    _ucreate2() can be used, it must be opened.  A shared heap must be
    opened by all processes which want to access the heap.  All
    attempts to access a heap before it has been opened will invoke
    undefined behavior.

    _uopen() fails if H is the runtime heap (_RUNTIME_HEAP) or the
    tiled runtime heap.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso _uclose() _ucreate() _ucreate2()


þfunction _ustats()
þcompat VAC++
þheaders
#include <umalloc.h>
þendheaders

þparam H PSTATS
þprototype
int _ustats (Heap_t H, _HEAPSTATS *PSTATS);
þendprototype

    _ustats() computes statistics on the heap pointed to by H and fills
    in the structure pointed to by PSTATS.  The structure has the
    following members:

þdescription
þitem þtt{_provided}
    Total number of bytes provided by the heap, including used and
    free blocks, excluding overhead for control structures
þitem þtt{_used}
    Total number of bytes in used blocks
þitem þtt{_tiled}
    1 if the heap is tiled (_HEAP_TILED), 0 if the heap is not tiled
þitem þtt{_shared}
    1 if the heap is shared (_HEAP_SHARED), 0 if the heap is not shared
þitem þtt{_max_free}
    Number of bytes in the biggest free block
þitem þtt{_segments}
    Number of segments
þitem þtt{_crates}
    Number of blocks allocated internally for allocation of small user
    blocks
þenddescription

þreturnvalue

    _ustats() returns 0 if successful.  _ustats() returns a non-zero
    value on error.

þimplementation

    The þtt{_segments} and þtt{_crates} members are an emx extension.

þhints

    Use þhpt{_udefault()} to obtain a pointer to the default heap if
    you want to apply _ustats() to the default heap.

þseealso _uaddmem() _udefault() _uheapmin() _uheap_walk()


þfunction _utcalloc()
þcompat emx
þheaders
#include <umalloc.h>
þendheaders

þparam H ELEMENTS SIZE
þprototype
void *_utcalloc (Heap_t H, size_t ELEMENTS, size_t SIZE);
þendprototype

    Allocate from the heap pointed to by H a block of memory big
    enough for holding ELEMENTS elements of SIZE bytes each.  The
    block will not cross a 64 KByte boundary unless SIZE is greater
    than 65536.  If SIZE is greater than 65536, the block will be
    aligned on a 64 KByte boundary.  _utcalloc() fills the block with
    zeros.  If there is an error, _utcalloc() returns NULL.

þreturnvalue

    _utcalloc() returns a pointer to a newly allocated block of
    memory.  On error, _utcalloc() returns NULL.

þseealso calloc() free() realloc() _tcalloc() _utmalloc()


þfunction _utdefault()
þcompat emx
þheaders
#include <umalloc.h>
þendheaders

þparam H
þprototype
Heap_t _utdefault (Heap_t H);
þendprototype

    The _utdefault() function selects the heap pointed to by H as the
    tiled default heap of the current thread unless H is NULL.  All
    tiled memory allocation functions such as _tmalloc() which don't
    take a pointer to a heap will use the heap pointed to by H if
    called in the same thread.  If H is NULL, _utdefault() won't set
    the tiled default heap.

    Initially, the tiled runtime heap is used as tiled default heap
    for all threads.

þreturnvalue

    _utdefault() returns a pointer to the previous tiled default heap
    of the current thread.  If the tiled default heap has not yet been
    created, _utdefault() will return NULL.

þhints

    To obtain a pointer to the tiled default heap of the current
    thread without selecting a new heap, call þtt{_utdefault(NULL)}.

þseealso _mheap() _ucreate() _ucreate2() _udefault()


þfunction utime()
þcompat SysV
þheaders
#include <utime.h>
þendheaders

þparam NAME TIMES
þprototype
int utime (const char *NAME, const struct utimbuf *TIMES);
þendprototype

    Set the time stamp of a file to the access time and modification
    time in the structure pointed to by TIMES.  NAME points to a
    string containing the name of the file.  If TIMES is NULL, both
    the access time and the modification time are set to the current
    time.

    The þtt{utimbuf} structure is defined as follows:

þexample
struct utimbuf
{
  time_t actime;
  time_t modtime;
};
þendexample

    þtt{actime} is the time of the last access, þtt{modtime} is the
    time of the last modification.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso stat() utimes()


þfunction utimes()
þcompat BSD
þheaders
#include <sys/time.h>
þendheaders

þparam NAME TVP
þprototype
int utimes (const char *NAME, const struct timeval *TVP);
þendprototype

    Set the time stamp of a file to the access time in
    þpa{TVP}þtt{[0]} and the modification time in þpa{TVP}þtt{[1]}.
    NAME points to a string containing the file name.  If TVP is NULL,
    both the access time and the modification time are set to the
    current time.

    The þtt{timeval} structure is defined as follows:

þexample
struct timeval
{
  long tv_sec;
  long tv_usec;
};
þendexample

    þtt{tv_sec} and þtt{tv_usec} are the number of seconds and
    microseconds, respectively, elapsed since 00:00:00 1-Jan-1970 UTC.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription
þseealso stat() utime()


þfunction _utmalloc()
þcompat emx
þheaders
#include <umalloc.h>
þendheaders

þparam H SIZE
þprototype
void *_utmalloc (Heap_t H, size_t SIZE);
þendprototype

    Allocate from the heap pointed to by H a block of memory big
    enough for holding SIZE bytes.  The block will not cross a 64
    KByte boundary unless SIZE is greater than 65536.  If SIZE is
    greater than 65536, the block will be aligned on a 64 KByte
    boundary.  Therefore, blocks allocated with _utmalloc() can be
    used with 16-bit functions.  If there is an error, _utmalloc()
    returns NULL.  If SIZE is 0, zero bytes of memory are allocated,
    the return value will be unequal NULL.  Use free() to deallocate a
    block of memory allocated by _utmalloc().

    As _utmalloc() causes additional heap fragmentation, you should
    not use _utmalloc() unless you need an aligned block.

þreturnvalue

    _utmalloc() returns a pointer to a newly allocated block of
    memory.  On error, _utmalloc() returns NULL.

þseealso free() realloc() _tmalloc() _umalloc() _utcalloc()


þfunction v_attrib()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam A
þprototype
void v_attrib (int A);
þendprototype

    Set the attributes (colors etc.) used by video library functions
    to A.  You can make A by using the binary OR operator and the
    þtt{F_}þsl{whatever}, þtt{B_}þsl{whatever}, INTENSITY and BLINK
    constants.

þseealso v_init() v_putc()


þfunction v_backsp()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam COUNT
þprototype
void v_backsp (int COUNT);
þendprototype

    Backspace the cursor.  The cursor is moved left by COUNT
    characters.  If the cursor leaves the screen at the left edge, it
    is moved to the end of the previous line.  The cursor cannot leave
    the screen at the top edge.

þseealso v_putc()


þfunction v_clear()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þprototype
void v_clear (void);
þendprototype

    Clear the screen using the current attributes.

þseealso v_attrib() v_clreol()


þfunction v_clreol()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þprototype
void v_clreol (void);
þendprototype

    Clear the line from the current cursor position to the end of the
    current line using the current attributes.

þseealso v_attrib() v_clear()


þfunction v_ctype()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam START END
þprototype
void v_ctype (int START, int END);
þendprototype

    Set the cursor type.  START is the first row of the cursor, END is
    the last row of the cursor.  Both values are zero-based. Use
    v_hardware() to determine the size of the character box.

    Note that cmd.exe resets the cursor type.

þseealso v_getctype() v_hardware() v_hidecursor()


þfunction v_delline()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam COUNT
þprototype
void v_delline (int COUNT);
þendprototype

    Delete COUNT lines at the current cursor position by moving up the
    lines below the current line.  The current attributes are used for
    filling lines becoming empty at the bottom of the screen.

þseealso v_attrib() v_insline() v_scroll()


þfunction v_dimen()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam WIDTH HEIGHT
þprototype
void v_dimen (int *WIDTH, int *HEIGHT);
þendprototype

    Store the screen width (columns) to WIDTH, the screen height
    (lines) to HEIGHT.

þseealso _scrsize()


þfunction v_fclose()
þcompat emx
þheaders
#include <stdio.h>
#include <sys/video.h>
þendheaders

þparam STREAM
þprototype
int v_fclose (FILE *STREAM);
þendprototype

    Close a video file created by v_fopen().

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription

þseealso v_fopen()


þfunction v_fopen()
þcompat emx
þheaders
#include <stdio.h>
#include <sys/video.h>
þendheaders

þprototype
FILE *v_fopen (void);
þendprototype

    Open a video file.  All output to a video file goes to the screen,
    using video library functions such as v_puts().  The stream
    returned by v_fopen() can be used with fprintf(), fputc() and
    fwrite().  On error, v_fopen() returns NULL.  Do not use fclose()
    on a stream created by v_fopen(), use v_fclose() instead.  Do not
    read from a stream created by v_fopen().

þreturnvalue

    See above.

þseealso _fassign() fopen() v_fclose() v_printf()

þsamplefile /emx/test/vftest.c


þfunction v_getattr()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þprototype
int v_getattr (void);
þendprototype

    Return the current attributes.

þreturnvalue

    See above.

þseealso v_attrib()


þfunction v_getctype()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam START END
þprototype
void v_getctype (int *START, int *END);
þendprototype

    Store the current cursor start and end rows to START and END.

þseealso v_ctype()


þfunction v_getline()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam DST X Y COUNT
þprototype
void v_getline (char *DST, int X, int Y, int COUNT);
þendprototype

    Copy COUNT character/attributes pairs from the screen at position
    (X,Y) to the array pointed to by DST.  2*þpa{COUNT} bytes are
    copied.  The cursor is not moved.

þseealso v_putline()


þfunction v_getxy()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam X Y
þprototype
void v_getxy (int *X, int *Y);
þendprototype

    Store the current cursor position to X (column) and Y (line).

þseealso v_gotoxy()


þfunction v_gotoxy()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam X Y
þprototype
void v_gotoxy (int X, int Y);
þendprototype

    Move the cursor to line Y, column X.  Both values are zero-based.
    Line 0 is the top line, column 0 is the left-most column.

þseealso v_getxy()


þfunction v_hardware()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þprototype
int v_hardware (void);
þendprototype

    Get the display adapter type.

þreturnvalue

þdescription

þitem V_MONOCHROME

    Monochrome display adapter

þitem V_COLOR_8

    Color display adapter, the character box height is 8 scan lines

þitem V_COLOR_12

    Color display adapter, the character box height is 12 scan lines

þenddescription

þseealso v_ctype()


þfunction v_hidecursor()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þprototype
void v_hidecursor (void);
þendprototype

    Turn off the cursor.  Use v_ctype() to turn the cursor on.

þseealso v_ctype()


þfunction v_init()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þprototype
int v_init (void);
þendprototype

    Initialize video library.  You must call this function before
    calling any other video library function.  The attributes are set
    to þtt{F_WHITE|B_BLACK}.

    General information about the video library: The video library
    implements text-mode output to the screen.  You have to link with
    -lvideo.  Under DOS, emx option -acm is required, see `þhpt{Using
    emx options}'.  See þhpt{wm_init()} for a higher-level interface.

þreturnvalue

    v_init() always returns 1.

þseealso v_attrib()

þsamplefile /emx/test/video.c


þfunction v_insline()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam COUNT
þprototype
void v_insline (int COUNT);
þendprototype

    Insert COUNT empty lines at the current cursor position by moving
    down the line at the current cursor position and all lines below
    that line.  The current attributes are used for filling the empty
    lines.

þseealso v_attrib() v_delline() v_scroll()


þfunction v_printf()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam FMT
þprototype
int v_printf (const char *FMT, ...);
þendprototype

    Formatted output to the screen at the current cursor position.
    The cursor is moved.  See þhpt{printf()} for details on the format
    string pointed to by FMT.

þreturnvalue

    v_printf() returns the number of output characters.

þseealso v_attrib() v_fopen() v_putc() v_puts() v_vprintf()


þfunction v_putc()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam C
þprototype
void v_putc (char C);
þendprototype

    Display character C on the screen at the current cursor position,
    using the current attributes.  The cursor is moved.  If the cursor
    leaves the screen at the right edge, it will be moved to the start
    of the next line.  If C is þtt{'\n'}, the cursor is moved to the
    start of the next line.  If the cursor leaves the screen at the
    bottom edge, the screen is scrolled up.

þseealso v_attrib() v_puts() v_scrollup()


þfunction v_putline()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam SRC X Y COUNT
þprototype
void v_putline (const char *SRC, int X, int Y, int COUNT);
þendprototype

    Copy COUNT character/attributes pairs from the array pointed to by
    SRC to the screen at position (X,Y).  2*þpa{COUNT} bytes are
    copied.  The cursor is not moved.

þseealso v_getline() v_putmask() v_putn()


þfunction v_putm()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam STR LEN
þprototype
void v_putm (const char *STR, int LEN);
þendprototype

    Display LEN characters of the string pointed to by STR at the
    current cursor position using the current attributes.  The cursor
    is not moved.

þseealso v_putline() v_putn() v_puts()


þfunction v_putmask()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam SRC MASK X Y COUNT
þprototype
void v_putmask (const char *SRC, const char *MASK, int X, int Y, int COUNT);
þendprototype

    Copy COUNT character/attributes pairs from the array pointed to by
    SRC to the screen.  A character/attributes pair at
    þpa{SRC}þtt{[2*i]} and þpa{SRC}þtt{[2*i+1]}, is copied only if
    þpa{MASK}þtt{[i]} is non-zero.  The cursor is not moved.

þseealso v_putline()


þfunction v_putn()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam C COUNT
þprototype
void v_putn (char C, int COUNT);
þendprototype

    Display character C at the current cursor position using the
    current attributes.  COUNT is the number of times to display the
    character.  The cursor is not moved.

þseealso v_attrib() v_putc()


þfunction v_puts()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam STR
þprototype
void v_puts (const char *STR);
þendprototype

    Display the string pointed to by STR at the current cursor
    position using the current attributes.  The þtt{'\n'} character
    moves the cursor to the start of the next line.  Scrolling is
    performed when the cursor leaves the screen at the bottom edge.

þseealso v_attrib() v_printf() v_putc() v_putm()


þfunction v_scroll()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam TL_X TL_Y BR_X BR_Y COUNT FLAG
þprototype
void v_scroll (int TL_X, int TL_Y, int BR_X, int BR_Y, int COUNT, int FLAG);
þendprototype

    Scroll a rectangle of the screen by COUNT lines.  The top left
    character cell is at (TL_X,TL_Y), the bottom right character cell
    is at (BR_X,BR_Y).  If FLAG is V_SCROLL_UP, the rectangle is
    scrolled up, if FLAG is V_SCROLL_DOWN, the rectangle is scrolled
    down.  If FLAG is V_SCROLL_CLEAR, the rectangle is filled with
    blanks.  Lines becoming empty are filled with blanks using the
    current attributes.

þseealso v_attrib() v_scrollup()


þfunction v_scrollup()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þprototype
void v_scrollup (void);
þendprototype

    Scroll screen up by one line.  The bottom line is filled with
    blanks, using the current attributes.

þseealso v_attrib() v_putc()


þfunction v_vprintf()
þcompat emx
þheaders
#include <sys/video.h>
þendheaders

þparam FMT ARG_PTR
þprototype
int v_vprintf (const char *FMT, va_list ARG_PTR);
þendprototype

    Formatted output to the screen.  Instead of a list of arguments,
    this function takes a pointer to the list of arguments.  See
    v_printf() for details.

þreturnvalue

    v_vprintf() returns the number of output characters.

þseealso v_printf() va_arg()


þfunction va_arg() va_end() va_start()
þcompat C90
þheaders
#include <stdarg.h>
þendheaders

þparam ARG_PTR TYPE PREV_ARG
þprototype
type va_arg (va_list ARG_PTR, TYPE);
void va_end (va_list ARG_PTR);
void va_start (va_list ARG_PTR, TYPE PREV_ARG);
þendprototype

    Access arguments of a function with variable number of arguments.
    You have to declare a variable of type va_list, for instance
    ARG_PTR.  Use

þtypewriter
  va_start (ARG_PTR, PREV_ARG)
þendtypewriter

    where PREV_ARG is the argument preceding the variable arguments,
    to initialize ARG_PTR.  Use

þtypewriter
  va_arg (ARG_PTR, TYPE)
þendtypewriter

    to get the next argument, which is of type TYPE.  Use

þtypewriter
  va_end (ARG_PTR)
þendtypewriter

    when you no longer need ARG_PTR.

þreturnvalue

    See above.

þrestrictions

    PREV_ARG must not be declared þtt{register}, must not be of
    function or array type, and the type must be compatible to the
    type that results from promotion.  For instance, PREV_ARG must not
    be of type þtt{char} or þtt{float}.

    TYPE must be compatible to the type that results from promotion.
    For instance, TYPE must not be þtt{unsigned char} or þtt{float}
    (instead, use þtt{unsigned int} and þtt{double}, respectively).

þseealso vprintf()

þsamplefile /emx/samples/stdarg.c


þfunction vprintf() vfprintf() vsprintf()
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þparam FORMAT ARG_PTR STREAM BUFFER
þprototype
int vprintf (const char *FORMAT, va_list ARG_PTR);
int vfprintf (FILE *STREAM, const char *FORMAT, va_list ARG_PTR);
int vsprintf (char *BUFFER, const char *FORMAT, va_list ARG_PTR);
þendprototype

    Formatted output to stdout, to the stream STREAM or to the string
    pointed to by BUFFER, respectively.  Instead of a list of
    arguments, these functions take a pointer to the list of
    arguments.  See þhpt{printf()} for details.

þreturnvalue

    vprintf(), vfprintf() and vsprintf() return the number of
    output characters.  On error, these functions return EOF.

þseealso printf() va_arg() vsnprintf()


þfunction vscanf() vfscanf() vsscanf()
þcompat emx
þheaders
#include <stdio.h>
þendheaders

þparam FORMAT ARG_PTR STREAM BUFFER
þprototype
int vscanf (const char *FORMAT, va_list ARG_PTR);
int vfscanf (FILE *STREAM, const char *FORMAT, va_list ARG_PTR);
int vsscanf (const char *BUFFER, const char *FORMAT, va_list ARG_PTR);
þendprototype

    Parse input from stdin, STREAM or the string pointed to by BUFFER,
    respectively.  Instead of a list of arguments, these functions
    take a pointer to the list of arguments.  See þhpt{scanf()} for
    details.

þreturnvalue

    If successful, vscanf(), vfscanf() and vsscanf() return the number
    of fields converted.  On error, these functions return EOF.

þseealso scanf() va_arg()


þfunction vsnprintf()
þcompat BSD
þheaders
#include <stdio.h>
þendheaders

þparam BUFFER N FORMAT ARG_PTR
þprototype
int vsnprintf (char *BUFFER, size_t N, const char *FORMAT, va_list ARG_PTR);
þendprototype

    Formatted output to the string pointed to by BUFFER.  If N is
    zero, BUFFER may be NULL and nothing is written.  Otherwise, up to
    þpa{N}-1 characters and a terminating null character will be
    written to BUFFER.  If formatting yields more than þpa{N}-1
    characters, output will be truncated.  The terminating null
    character will be put into BUFFER even if output is truncated.

    Instead of a list of arguments, this function takes a pointer to
    the list of arguments.  See þhpt{printf()} for details.

þreturnvalue

    On success, vsnprintf() returns the number of characters
    (excluding the terminating null character) that would have been
    written to BUFFER if N had been sufficiently large.  That is,
    output is truncated iff the returned value is greater than or
    equal to N.  On error, vsnprintf() returns EOF.

þseealso printf() snprintf() va_arg() vsprintf()


þfunction wait()
þcompat POSIX.1

þheaders
#include <sys/types.h>
#include <sys/wait.h>
þendheaders

þparam STAT_LOC STAT_VAL
þprototype
int wait (int *STAT_LOC);
þendprototype

    Obtain status information about a child process.  wait() suspends
    the process until status information for a child process is
    available or until a signal occurs.

    If status information is available, wait() returns immediately.
    This happens if a child process terminated before wait() is
    called, or if status information about a debuggee is available,
    that is, after calling ptrace() with requests PTRACE_RESUME or
    PTRACE_STEP.

    If there are no child processes, wait() returns immediately,
    setting errno to ECHILD and returning -1.  If STAT_LOC is not
    NULL, the return code and the termination status are stored to the
    location pointed to by STAT_LOC.

    You can use the following macros for determining the type of
    status (STAT_VAL is the value pointed to by STAT_LOC):

þlist
þitem þtt{WIFEXITED (}STAT_VALþtt{)}

    This macro returns a non-zero value if the process for which
    STAT_VAL was returned terminated normally.

þitem þtt{WIFSIGNALED (}STAT_VALþtt{)}

    This macro returns a non-zero value if the process for which
    STAT_VAL was returned terminated due to a signal which was not
    caught.

þitem þtt{WIFSTOPPED (}STAT_VALþtt{)}

    This macro returns a non-zero value if the process for which
    STAT_VAL was returned is stopped.  This occurs only if the child
    process is being debugged.

þendlist

    Depending on the type of status indicated by the above macros, you
    can use exactly one of the following macro to obtain additional
    information:

þlist
þitem þtt{WEXITSTATUS (}STAT_VALþtt{)}

    If þtt{WIFEXITED(}STAT_VALþtt{)} is non-zero, this macro returns
    the return code of the child process (passed to exit(), _exit(),
    or returned from main()).

þitem þtt{WTERMSIG (}STAT_VALþtt{)}

    If þtt{WIFSIGNALED(}STAT_VALþtt{)} is non-zero, this macro returns
    the number of the signal by which the child process was terminated.

þitem þtt{WSTOPSIG (}STAT_VALþtt{)}

    If þtt{WIFSTOPPED(}STAT_VALþtt{)} is non-zero, this macro returns
    the number of the signal by which the child process was stopped.

þendlist


þreturnvalue

    wait() returns the process ID of the child process.  If
    _UF_PTRACE_MULTITHREAD has been set with _uflags(), the return value
    of wait() contains both the thread ID and the process ID; use the
    PTRACE_GETPID and PTRACE_GETTID macros of <sys/ptrace.h> to
    extract the process ID and the thread ID.  If an error occurs,
    wait() sets errno and returns -1.

þrestrictions

    Under DOS, wait() is currently implemented only for processes
    being debugged and for synchronous processes started with
    P_NOWAIT; see þhpt{ptrace()} and þhpt{spawn*()}.  Under DOS, the
    termination status of only one process is kept for wait().  If you
    run another process before calling wait(), the termination status
    will be overwritten.

    Under OS/2, wait() works only for processes started with spawn*()
    or þhpt{exec*()}.  It does not work for processes started with
    DosExecPgm or DosStartSession.  If the processes found by wait()
    has been started as a session, only the return code is available,
    not the signal number.

    wait() is interrupted by signals which are ignored (SIG_IGN) and
    by signals which are blocked.

þseealso exit() fork() main() ptrace() sigaction() signal() sigprocmask() spawn*() _uflags() waitpid()

þsamplecode
int tc, pid;

pid = wait (&tc);
if (pid >= 0)
  {
    if (WIFEXITED (tc))
      printf ("Normal process termination, rc=%d\n", WEXITSTATUS (tc));
    else if (WIFSIGNALED (tc))
      printf ("Process terminated by signal %d\n", WTERMSIG (tc));
    else
      printf ("Process stopped by signal %d\n", WSTOPSIG (tc));
  }
þendsamplecode


þfunction _wait0() _wait1() _wait01() _wait10()
þcompat emx *
þheaders
#include <sys/hw.h>
þendheaders

þparam PORT MASK
þprototype
void _wait0 (unsigned PORT, unsigned MASK);
void _wait1 (unsigned PORT, unsigned MASK);
void _wait01 (unsigned PORT, unsigned MASK);
void _wait10 (unsigned PORT, unsigned MASK);
þendprototype

    The _wait0() and _wait1() functions wait for the bit indicated by
    MASK of the 8-bit hardware port PORT being 0 or 1, respectively.

    The _wait01() and _wait10() functions wait for a 0->1 or 1->0
    transition, respectively, of the bit indicated by MASK of the
    8-bit hardware port PORT.

    If there are multiple bits set in MASK, 0 means all bits
    cleared, 1 means at least one bit set.

    You have to call _portaccess() first to enable access to a range
    of ports.  To make your program work under DOS, you have to use
    emx option -ai, see `þhpt{Using emx options}'.  Under OS/2, your
    program requires emxio.dll in a directory listed in LIBPATH.

    Note that these functions eat a lot of CPU time.

þseealso _portaccess() _inp8()


þfunction waitpid()
þcompat POSIX.1
þheaders
#include <sys/types.h>
#include <sys/wait.h>
þendheaders

þparam PID STAT_LOC OPTIONS
þprototype
int waitpid (int PID, int *STAT_LOC, int OPTIONS);
þendprototype

    Wait until status information for the child process PID is
    available or until a signal occurs.  If PID is -1, waitpid() waits
    for any child process, as does wait().  If there is no child
    process with process ID PID (or if PID is -1 and there is no child
    process), errno is set to ESRCH and -1 is returned.  On success,
    the process ID is returned.  If STAT_LOC is not NULL, the return
    code and the termination status are stored to the location pointed
    to by STAT_LOC, see þhpt{wait()} for details.

    OPTIONS is the bitwise OR of zero or more of the following flags:

þdescription

þitem WNOHANG

    Don't wait if no status information is currently available.  If
    WNOHANG is set, and there are any child processes matching PID,
    and no status available for any child process matching PID, 0 is
    returned.

þitem WUNTRACED

    Not implemented.

þenddescription

þreturnvalue
þdescription
þitem -1
    error or interrupted (errno set to ECHILD, EINVAL, or EINTR)
þitem >0
    process ID.  If _UF_PTRACE_MULTITHREAD has been set with _uflags(),
    the return value of waitpid() contains both the thread ID and the
    process ID; use the PTRACE_GETPID and PTRACE_GETTID macros of
    <sys/ptrace.h> to extract the process ID and the thread ID
þitem 0
    WNOHANG is set in OPTIONS, and there are child processes matching
    PID, and no status available for any child process matching PID
þenddescription

þrestrictions

    waitpid() is not implemented for negative values of PID.
    WUNTRACED in OPTIONS is ignored.  waitpid() is not implemented
    under DOS.  waitpid() is interrupted by signals which are ignored
    (SIG_IGN) and by signals which are blocked.

þseealso fork() ptrace() sigaction() signal() sigprocmask() spawn*() _uflags() wait()


þfunction _wildcard()
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þparam ARGCP ARGVP
þprototype
void _wildcard (int *ARGCP, char ***ARGVP);
þendprototype

    Expand wildcards.  If you want wildcards on the command line to be
    expanded, call

þexample
_wildcard (&argc, &argv);
þendexample

    at the beginning of main().  Wildcard arguments enclosed in double
    quotes won't be expanded.  If the expansion of a wildcard argument
    is empty, the wildcard argument is kept unchanged.  Directories
    are included in the expansion.  Hidden and system files are
    omitted.

    _fnlwr() is used to convert file names to lower case on
    upper-case-only file systems.

    _wildcard() properly handles DBCS characters.

þseealso _envargs() _fnexplode() main() _nls_init() _response()


þfunction wcstombs()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam S PWCS N
þprototype
size_t wcstombs (char *S, const wchar_t *PWCS, size_t N);
þendprototype

    Convert the zero-terminated sequence of wchar_t codes at PWCS to a
    multibyte character sequence beginning at S.  The multibyte
    character sequence starts in the initial shift state.  At most N
    bytes are stored.  S will be terminated with a null character if N
    is big enough.

    The shift state of wctomb() is not affected.

þreturnvalue

    wcstombs() returns the number of bytes stored to S (excluding the
    terminating null character) or þtt{(size_t_t)-1} if a code could
    not be counverted.

þseealso mbstowcs() setlocale() wctomb()


þfunction wctomb()
þcompat C90
þheaders
#include <stdlib.h>
þendheaders

þparam S WCHAR
þprototype
int wctomb (char *S, wchar_t WCHAR);
þendprototype

    Convert the wchar_t code WCHAR to a multibyte character sequence
    pointed to by S.  At most MB_CUR_MAX bytes are stored.  If S is
    NULL, the shift state is reset to the initial state.  If WCHAR is
    zero, the shift state is the initial state after return from
    wctomb().

    In programs linked with the multithread libraries, each thread has
    its own shift state for wctomb().

þreturnvalue

    If S is NULL, wctomb() returns a non-zero value (if
    state-dependent encoding is used) or a zero value (if
    state-dependent encoding is not used).  If S is not NULL, wctomb()
    returns 0 (if WCHAR is zero), the number of bytes comprising the
    multibyte character stored to S (if conversion is successful), or
    -1 (if WCHAR could not be converted).

þseealso mbtowc() setlocale() wcstombs()


þfunction wm_attrib()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH A
þprototype
void wm_attrib (wm_handle WH, int A);
þendprototype

    Set the default attributes of window WH to A.

þseealso wm_create() wm_get_attrib() wm_putc()


þfunction wm_attrib_all()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH A
þprototype
void wm_attrib_all (wm_handle WH, int A);
þendprototype

    Change the attributes of all characters of window WH (except of
    the border) to A.  The character codes are not changed.

þseealso wm_attrib() wm_clear() wm_create()


þfunction wm_backsp()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH COUNT
þprototype
void wm_backsp (wm_handle WH, int COUNT);
þendprototype

    Backspace the cursor of window WH.  The cursor is moved left by
    COUNT characters.  If the cursor leaves the window at the left
    edge, it is moved to the end of the previous line.  The cursor
    cannot leave the window at the top edge.

þseealso wm_putc()


þfunction wm_border()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH BFLAG BATTR TITLE TFLAG TATTR
þprototype
void wm_border (wm_handle WH, int BFLAG, int BATTR, const char *TITLE,
                int TFLAG, int TATTR);
þendprototype

    Change the border of window WH.  The border type is set to BFLAG:
    0 turns the border off, 1 uses a single line, 2 uses a double
    line, 3 and 4 use both single and double lines -- which is not
    recommended as most code pages do not contain the necessary
    symbols.  All other values are used as characters for drawing the
    border.  The attributes BATTR are used for drawing the border.
    The string pointed to by TITLE is displayed centered in the top
    line of the border.  If TFLAG is non-zero, vertical bars are used
    to separate the title text from the border.  The attributes TATTR
    are used for displaying the title text.

þseealso wm_create()


þfunction wm_bottom()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH
þprototype
void wm_bottom (wm_handle WH);
þendprototype

    Move window WH to the bottom of the window stack, that is, it will
    be moved below all other windows.

þseealso wm_top() wm_up()


þfunction wm_chide()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam FLAG
þprototype
void wm_chide (int FLAG);
þendprototype

    Set the cursor hide mode.  If FLAG is non-zero, the cursor is
    hidden if the current cursor position is hidden by another window.
    If FLAG is zero, the cursor is visible even if the cursor position
    is hidden by another window.  The initial value is non-zero.

þseealso wm_ctype() wm_cursor()


þfunction wm_clear()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH
þprototype
void wm_clear (wm_handle WH);
þendprototype

    Clear window WH by filling WH with blanks using the current
    attributes.

þseealso wm_attrib() wm_attrib_all()


þfunction wm_close()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH
þprototype
void wm_close (wm_handle WH);
þendprototype

    Close the window WH.  After closing the window, it still exists
    but is not visible.

þseealso wm_open()


þfunction wm_close_all()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þprototype
void wm_close_all (void);
þendprototype

   Close all the windows.  wm_close_all() restores the original screen
   contents.

þseealso wm_close() wm_open()


þfunction wm_clr_eol()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y
þprototype
void wm_clr_eol (wm_handle WH, int X, int Y);
þendprototype

    Clear from position (X,Y) of window WH to the end of that line of
    that window by displaying blanks.  The current attributes are
    used.

þseealso wm_clear()


þfunction wm_create()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam X0 Y0 X1 Y1 BORDER BATTR WATTR
þprototype
wm_handle wm_create (int X0, int Y0, int X1, int Y1, int BORDER, int BATTR,
                     int WATTR);
þendprototype

    Create a window.  The upper left character of the window interior
    is at (X0,Y0), the bottom right character of the window interior
    is at (X1,Y1).  A window may be larger than the screen or
    partially or completely outside the screen.  BORDER specifies the
    border type: 0 doesn't draw a border, 1 uses a single line, 2 uses
    a double line, 3 and 4 use both single and double lines -- which
    is not recommended as most code pages do not contain the necessary
    symbols.  All other values are used as characters for drawing the
    border.  The attributes BATTR are used for drawing the border.
    The attributes for displaying text in the window are set to WATTR.
    After creating a window, it is invisible.  Use wm_open() to show
    the window.

þreturnvalue

    wm_create() returns the handle of the window if successful.
    Otherwise, NULL is returned.

þseealso wm_attrib() wm_border() wm_delete() wm_open()


þfunction wm_ctype()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH START END
þprototype
void wm_ctype (wm_handle WH, int START, int END);
þendprototype

    Set the cursor type of window WH.  START is the first row of the
    cursor, END is the last row of the cursor.  Both values are
    zero-based.  The cursor type set by wm_ctype() is used for
    displaying the cursor if it is connected to window WH.  Use
    v_hardware() to determine the size of the character box.

þseealso v_hardware() wm_chide() wm_cursor()


þfunction wm_cursor()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH
þprototype
void wm_cursor (wm_handle WH);
þendprototype

    Connect the screen cursor with the cursor of window WH.  The
    cursor is displayed at the cursor position of window WH, using the
    cursor type of window WH.  If WH is NULL, the screen cursor is not
    connected to any window and is invisible.  Initially, the screen
    cursor is not connected to any window.

þseealso wm_chide() wm_ctype() wm_cvis()


þfunction wm_cvis()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH FLAG
þprototype
void wm_cvis (wm_handle WH, int FLAG);
þendprototype

    Set the cursor status of window WH.  If FLAG is non-zero, the
    cursor is enabled, if FLAG is zero, the cursor is disabled.

þseealso wm_chide() wm_cursor()


þfunction wm_del_char()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y COUNT
þprototype
void wm_del_char (wm_handle WH, int X, int Y, int COUNT);
þendprototype

    Delete COUNT characters at position (X,Y) of window WH.
    Characters to the right of that position are moved left, the
    positions becoming vacant at the right edge of the window are
    filled with blanks using the current attributes.

þseealso wm_attrib() wm_del_line() wm_ins_char()


þfunction wm_del_line()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH Y COUNT
þprototype
void wm_del_line (wm_handle WH, int Y, int COUNT);
þendprototype

    Delete COUNT lines at line Y of window WH by moving up the
    lines below that line.  The current attributes are used for
    filling lines becoming empty at the bottom of the window.

þseealso wm_attrib() wm_del_char() wm_ins_line() wm_scroll()


þfunction wm_delete()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH
þprototype
void wm_delete (wm_handle WH);
þendprototype

    Destroy the window WH.  After calling wm_delete(), the window
    handle WH must no longer be used.  The window is not closed.

þseealso wm_close() wm_create()


þfunction wm_dimen()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH WIDTH HEIGHT
þprototype
void wm_dimen (wm_handle WH, int *WIDTH, int *HEIGHT);
þendprototype

    Store the width of the window WH (columns) to WIDTH, the height
    (lines) to HEIGHT.

þseealso wm_create()


þfunction wm_down()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH
þprototype
void wm_down (wm_handle WH);
þendprototype

    Move window WH down the window stack, that is, it will be covered
    by an additional window unless WH is already the bottom window.

þseealso wm_bottom() wm_top() wm_up()


þfunction wm_exit()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þprototype
void wm_exit (void);
þendprototype

    Quit the window manager and release all memory allocated by the
    window manager.  All window handles become invalid.  The windows
    are not closed.

þseealso wm_close() wm_delete()


þfunction wm_fclose()
þcompat emx
þheaders
#include <stdio.h>
#include <sys/winmgr.h>
þendheaders

þparam STREAM
þprototype
int wm_fclose (FILE *STREAM);
þendprototype

    Close a window manager file.

þreturnvalue
þdescription
þitem 0
    success
þitem -1
    error
þenddescription


þseealso wm_fopen()


þfunction wm_find()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam X Y
þprototype
wm_handle wm_find (int X, int Y);
þendprototype

    Find the window which is visible at position (X,Y) of the screen.

þreturnvalue

    wm_find() returns the window handle if such a window exists.
    Otherwise, wm_find() returns NULL.


þfunction wm_fopen()
þcompat emx
þheaders
#include <stdio.h>
#include <sys/winmgr.h>
þendheaders

þparam WH
þprototype
FILE *wm_fopen (wm_handle WH);
þendprototype

    Open a window manager file.  All output to a video file goes to
    the window WH, using window manager library functions such as
    wm_puts().  The stream returned by wm_fopen() can be used with
    fprintf(), fputc() and fwrite().  On error, wm_fopen() returns
    NULL.  Do not use fclose() on a stream created by v_fopen(), use
    wm_fclose() instead.  Do not read from a stream created by
    wm_fopen().

þreturnvalue

    See above.

þseealso _fassign() fopen() wm_printf()


þfunction wm_get_attrib()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH
þprototype
int wm_get_attrib (wm_handle WH);
þendprototype

    Return the current attributes of window WH.

þreturnvalue

    See above.

þseealso wm_attrib()


þfunction wm_get_cursor()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þprototype
wm_handle wm_get_cursor (void);
þendprototype

    Get the window to which the screen cursor is connected.

þreturnvalue

    wm_get_cursor() returns the window handle of the window to which
    the screen cursor is connected.  If the cursor is not connected to
    any window, wm_get_cursor() returns NULL.

þseealso wm_cursor()


þfunction wm_get_pos()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y
þprototype
void wm_get_pos (wm_handle WH, int *X, int *Y);
þendprototype

    Store the screen coordinates of the upper left character of the
    interior of window WH to X and Y.

þseealso wm_create() wm_move()


þfunction wm_getxy() wm_getx() wm_gety()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y
þprototype
void wm_getxy (wm_handle WH, int *X, int *Y);
int wm_getx (wm_handle WH);
int wm_gety (wm_handle WH);
þendprototype

    wm_getxy() stores the cursor coordinates of window WH to X and Y.
    wm_getx() returns the horizontal position (column) of the cursor
    of window WH.  wm_gety() returns the vertical position (line) of
    the cursor of window WH.  The coordinates are zero-based and are
    relative to the upper left character of the interior of window WH.

þreturnvalue

    See above.

þseealso wm_gotoxy()


þfunction wm_gotoxy()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y
þprototype
void wm_gotoxy (wm_handle WH, int X, int Y);
þendprototype

    Move the cursor of window WH to (X,Y).  The coordinates are
    zero-based and are relative to the upper left character of the
    interior of window WH.  If the screen cursor is connected to the
    cursor of window WH, the screen cursor is moved.

þseealso wm_cursor() wm_getxy()


þfunction wm_ins_char()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y COUNT
þprototype
void wm_ins_char (wm_handle WH, int X, int Y, int COUNT);
þendprototype

    Insert COUNT blank characters at position (X,Y) of window WH.
    Characters to the right of that position are moved right.  The
    current attributes are used for displaying the blank characters.

þseealso wm_attrib() wm_del_char() wm_ins_line()


þfunction wm_ins_line()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH Y COUNT
þprototype
void wm_ins_line (wm_handle WH, int Y, int COUNT);
þendprototype

    Insert COUNT empty lines at line Y of window WH by moving down
    that line and all lines below that line.  The current attributes
    are used for filling the empty lines.

þseealso wm_attrib() wm_del_line() wm_scroll()


þfunction wm_init()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam N
þprototype
int wm_init (int N);
þendprototype

    Initialize the window manager and allocate memory for N windows.
    You must call this function before calling any other window
    manager function.

    General information about window manager functions: The window
    manager functions implement text-mode output to windows on the
    screen.  You have to link with -lvideo.  Under DOS, emx option
    -acm is required, see `þhpt{Using emx options}'.

þreturnvalue
þdescription
þitem 1
    success
þitem 0
    error
þenddescription

þseealso wm_exit()

þsamplefile /emx/samples/wm_demo.c, /emx/samples/wm_hello.c


þfunction wm_move()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y
þprototype
void wm_move (wm_handle WH, int X, int Y);
þendprototype

    Move the window WH.  The upper left character of the interior of
    the window will be at screen coordinates (X,Y).

þseealso wm_get_pos()


þfunction wm_open()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH
þprototype
void wm_open (wm_handle WH);
þendprototype

    Open the window WH.  The window will be showed on the screen
    unless it is covered by other windows or outside the screen.

þseealso wm_close()


þfunction wm_printf()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH FMT
þprototype
int wm_printf (wm_handle WH, const char *FMT, ...);
þendprototype

    Formatted output to window WH at the current cursor position of
    that window.  The cursor is moved.  See þhpt{printf()} for details
    on the format string pointed to by FMT.

þreturnvalue

    wm_printf() returns the number of output characters.

þseealso wm_attrib() wm_fopen() wm_putc() wm_puts() wm_vprintf()


þfunction wm_puta_at()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y A COUNT
þprototype
void wm_puta_at (wm_handle WH, int X, int Y, int A, int COUNT);
þendprototype

    Change to A the attributes of COUNT characters at position (X,Y)
    of window WH.  All COUNT characters must be in one line of the
    window.

þseealso wm_attrib() wm_putsa_at()


þfunction wm_putc()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH C
þprototype
void wm_putc (wm_handle WH, char C);
þendprototype

    Display character C in window WH at the current cursor position of
    that window, using the current attributes of that window.  The
    cursor of that window is moved.  If the cursor leaves the window
    at the right edge, it will be moved to the start of the next
    line.  If C is þtt{'\n'}, the cursor is moved to the start of the
    next line.  If the cursor leaves the window at the bottom edge,
    the window is scrolled up.

þseealso wm_attrib() wm_putc_at() wm_putca() wm_scroll() wm_wrap()


þfunction wm_putc_at()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y C
þprototype
void wm_putc_at (wm_handle WH, int X, int Y, char C);
þendprototype

    Display character C at position (X,Y) of window WH using the
    current attributes of that window.  The cursor is not moved.

þseealso wm_attrib() wm_gotoxy()


þfunction wm_putca()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH C A
þprototype
void wm_putca (wm_handle WH, char C, int A);
þendprototype

    Display character C in window WH at the current cursor position of
    that window, using the attributes A.  The cursor of that window is
    moved.  If the cursor leaves the window at the right edge, it will
    be moved to the start of the next line.  If C is þtt{'\n'}, the
    cursor is moved to the start of the next line.  If the cursor
    leaves the window at the bottom edge, the window is scrolled up.

þseealso wm_putc() wm_putca_at() wm_scroll() wm_wrap()


þfunction wm_putca_at()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y C A
þprototype
void wm_putca_at (wm_handle WH, int X, int Y, char C, int A);
þendprototype

    Display character C at position (X,Y) of window WH using the
    attributes A.  The cursor is not moved.


þfunction wm_puts()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH STR
þprototype
void wm_puts (wm_handle WH, const char *STR);
þendprototype

    Display the string pointed to by STR in window WH at the current
    cursor position of that window using the current attributes of
    that window.  The þtt{'\n'} character moves the cursor to the
    start of the next line.  Scrolling is performed when the cursor
    leaves the window at the bottom edge.

þseealso wm_attrib() wm_putc() wm_putsa() wm_scroll() wm_wrap()


þfunction wm_puts_at()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y STR
þprototype
void wm_puts_at (wm_handle WH, int X, int Y, const char *STR);
þendprototype

    Display the string pointed to by STR in window WH at position
    (X,Y) using the current attributes of that window.  The þtt{'\n'}
    character is not interpreted, the cursor is not moved.

þseealso wm_attrib() wm_puts()


þfunction wm_putsa()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH STR LEN
þprototype
void wm_putsa (wm_handle WH, const char *STR, int LEN);
þendprototype

    Display LEN characters with attributes in window WH at the current
    cursor position of that window.  STR points to an array of
    character and attributes pairs.  There are 2*þpa{LEN} bytes at
    STR.

þseealso wm_putca() wm_puts() wm_scroll() wm_wrap()


þfunction wm_putsa_at()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH X Y STR LEN
þprototype
void wm_putsa_at (wm_handle WH, int X, int Y, const char *STR, int LEN);
þendprototype

    Display LEN characters with attributes in window WH at position
    (X,Y).  STR points to an array of character and attributes pairs.
    There are 2*þpa{LEN} bytes at STR.

þseealso wm_putsa()


þfunction wm_scroll()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH COUNT
þprototype
void wm_scroll (wm_handle WH, int COUNT);
þendprototype

    Scroll the interior of window WH up by one line.  The bottom line
    is filled with blanks, using the current attributes.

þseealso wm_attrib() wm_del_line() wm_ins_line() wm_putc()


þfunction wm_top()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH
þprototype
void wm_top (wm_handle WH);
þendprototype

    Move window WH to the top of the window stack, that is, it will
    cover all other windows.

þseealso wm_bottom() wm_down()


þfunction wm_up()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH
þprototype
void wm_up (wm_handle WH);
þendprototype

    Move window WH up the window stack, that is, it will cover an
    additional window unless WH is already the top window.

þseealso wm_bottom() wm_down() wm_top()


þfunction wm_update()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH FLAG
þprototype
void wm_update (wm_handle WH, int FLAG);
þendprototype

    Set the update mode of window WH.  If FLAG is non-zero (which is
    the default), the screen is updated immediately if window WH is
    changed.  If FLAG is zero, changes to window WH are done in memory
    only.  This can be done to improve speed.  Each call to
    wm_update() copies the window to the screen, regardless of the
    FLAG argument.


þfunction wm_vprintf()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH FMT ARG_PTR
þprototype
int wm_vprintf (wm_handle WH, const char *FMT, va_list ARG_PTR);
þendprototype

    Formatted output to window WH.  Instead of a list of arguments,
    this function takes a pointer to the list of arguments.  See
    wm_printf() for details.

þreturnvalue

    wm_vprintf() returns the number of output characters.

þseealso wm_printf() va_arg()


þfunction wm_wrap()
þcompat emx
þheaders
#include <sys/winmgr.h>
þendheaders

þparam WH WRAP_FLAG
þprototype
void wm_wrap (wm_handle WH, int WRAP_FLAG);
þendprototype

    Set the end-of-line wrap mode of window WH.  If WRAP_FLAG is
    non-zero (which is the default), the cursor is moved to the next
    line if it reaches the end of a line.  If WRAP_FLAG is zero, the
    cursor stays at the end of the line.  wm_wrap() applies to
    wm_putc(), wm_puts(), wm_printf(), etcþ.

þseealso wm_putc()


þfunction write()
þcompat POSIX.1
þheaders
#include <io.h>
þendheaders

þparam HANDLE BUF NBYTE
þprototype
int write (int HANDLE, const void *BUF, size_t NBYTE);
þendprototype

    Write NBYTE characters from the buffer BUF to the file HANDLE.
    Writing 0 characters is allowed -- the request will be ignored.
    In text mode, newline characters are translated to CR/LF pairs.

þreturnvalue

    write() returns the number of characters written.  If there is an
    error, write() returns -1.  Text mode translation does not affect
    the return value.

þerrors
þdescription
þitem EAGAIN

    The O_NONBLOCK (alias O_NDELAY) flag is set for HANDLE and the
    process would be suspended in the write operation.

þitem EBADF

    The HANDLE argument is not a valid file descriptor.

þitem EINTR

    The write operation was interrupted by a caught signal.

þitem EIO

    An I/O error occured.  Use _syserrno() for getting the system
    error code.

þitem ENOSPC

    There is no free space remaining on the device containing the file.

þitem EPIPE

    An attempt is made to write to a pipe or named pipe that is not
    open for reading by any process.  A SIGPIPE signal is sent to the
    process.  This error is returned if the signal does not terminate
    the process.

þenddescription

þrestrictions

    In binary mode, partial transfers to disk files (due to lack of
    disk space) do not occur.  In text mode, partial transfers may
    occur if the actual number of bytes (with newline translated to
    CR/LF) written exceeds 1024.

    PIPE_BUF is ignored: Write operations are atomic for any value of
    NBYTE in blocking mode; write operations may be non-atomic for any
    value of NBYTE in non-blocking mode.

    O_APPEND is subject to race conditions.

þseealso open() setmode() read() sigaction() signal()


þh1 Variable reference
þi1 Variables

  The variables are listed almost alphabetically.


þfunction daylight
þheaders
#include <time.h>
þendheaders

þprototype
int daylight;
þendprototype

    This variable is zero if standard time is in effect.  It is
    non-zero if daylight saving time is in effect.

þseealso timezone tzname tzset()


þfunction _emx_env
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þprototype
const unsigned int _emx_env;
þendprototype

    This variable contains bits describing the environment your
    program is running in:

þdescription

þitem 0x0001

    Running under VCPI

þitem 0x0002

    Running under XMS

þitem 0x0004

    VDISK 3.3 detected

þitem 0x0008

    Running under DESQview

þitem 0x0010

    287 coprocessor present

þitem 0x0020

    387 coprocessor present

þitem 0x0200

    Running under OS/2 2.x

þitem 0x0400

    File names are truncated (-t option)

þitem 0x0800

    Data and stack executable (-ac option under DOS)

þitem 0x1000

    Running under RSX

þenddescription

    You should check the 0x0200 bit before calling an OS/2 API
    function.  You should check the 0x0400 bit when comparing file
    names.

þseealso _osmode


þfunction _emx_rev
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þprototype
const unsigned int _emx_rev;
þendprototype

    This variable contains the emx revision index.  The revision index
    is a number that is incremented everytime a new emx revision is
    released.  When the emx version number changes, the revision index
    is not reset to zero.  If _emx_rev is zero, the revision index is
    not available because the emx version being in use is too old or
    the system call library is used.

þseealso _emx_vcmp _emx_vprt


þfunction _emx_vcmp
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þprototype
const unsigned int _emx_vcmp;
þendprototype

    This variable contains the emx version number, suitable for
    comparing.

þseealso _emx_rev _emx_vprt

þsamplecode
if (_emx_vcmp > 0x302e3861)             /* > 0.8a */
  {
    ...
  }
þendsamplecode


þfunction _emx_vprt
þcompat emx
þheaders
#include <stdlib.h>
þendheaders

þprototype
const char _emx_vprt[5];
þendprototype

    This variable contains the emx version number, suitable for
    printing.

þseealso _emx_rev _emx_vcmp

þsamplecode
printf ("emx version: %s\n", _emx_vprt);
þendsamplecode


þfunction environ
þcompat POSIX.1

þprototype
char **environ;
þendprototype

    A pointer to the current environment of the process.  environ
    points to an array of pointers to strings.  The array is
    terminated by a NULL pointer.  After changing the environment with
    putenv(), you should use this variable instead of the þpa{ENVP}
    parameter of main().

þimplementation

    environ is declared in <stdlib.h>.

þrestrictions

    After changing the value of TZ, you should call tzset().

þseealso main() putenv() tzset()


þfunction errno
þcompat C90
þheaders
#include <errno.h>
þendheaders

þprototype
int errno;
þendprototype

    When a library function call fails, errno is usually set to a
    positive value indicating the type of error.  On success, errno is
    usually not changed.  Note that no library function sets errno to
    zero.

þimplementation

    The following errno values are supported:

þexample
Name            ³ Value ³ Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
EPERM           ³  1    ³ Operation not permitted
ENOENT          ³  2    ³ No such file or directory
ESRCH           ³  3    ³ No such process
EINTR           ³  4    ³ Interrupted system call
EIO             ³  5    ³ I/O error
ENXIO           ³  6    ³ No such device or address
E2BIG           ³  7    ³ Arguments or environment too big
ENOEXEC         ³  8    ³ Invalid executable file format
EBADF           ³  9    ³ Bad file number
ECHILD          ³  10   ³ No children
EAGAIN          ³  11   ³ Resource temporarily unavailable
ENOMEM          ³  12   ³ Not enough memory
EACCES          ³  13   ³ Permission denied
EFAULT          ³  14   ³ Bad address
ENOLCK          ³  15   ³ No locks available
EBUSY           ³  16   ³ Resource busy
EEXIST          ³  17   ³ File exists
EXDEV           ³  18   ³ Cross-device link
ENODEV          ³  19   ³ No such device
ENOTDIR         ³  20   ³ Not a directory
EISDIR          ³  21   ³ Is a directory
EINVAL          ³  22   ³ Invalid argument
ENFILE          ³  23   ³ Too many open files in system
EMFILE          ³  24   ³ Too many open files
ENOTTY          ³  25   ³ Inappropriate ioctl
EDEADLK         ³  26   ³ Resource deadlock avoided
EFBIG           ³  27   ³ File too large
ENOSPC          ³  28   ³ Disk full
ESPIPE          ³  29   ³ Illegal seek
EROFS           ³  30   ³ Read-only file system
EMLINK          ³  31   ³ Too many links
EPIPE           ³  32   ³ Broken pipe
EDOM            ³  33   ³ Domain error
ERANGE          ³  34   ³ Result too large
ENOTEMPTY       ³  35   ³ Directory not empty
EINPROGRESS     ³  36   ³ Operation now in progress
ENOSYS          ³  37   ³ Function not implemented
ENAMETOOLONG    ³  38   ³ File name too long
EDESTADDRREQ    ³  39   ³ Destination address required
EMSGSIZE        ³  40   ³ Message too long
EPROTOTYPE      ³  41   ³ Protocol wrong type for socket
ENOPROTOOPT     ³  42   ³ Option not supported by protocol
EPROTONOSUPPORT ³  43   ³ tocol not supported
ESOCKTNOSUPPORT ³  44   ³ ket type not supported
EOPNOTSUPP      ³  45   ³ Operation not supported on socket
EPFNOSUPPORT    ³  46   ³ Protocol family not supported
EAFNOSUPPORT    ³  47   ³ Address family not supported by
                ³       ³ protocol family
EADDRINUSE      ³  48   ³ Address already in use
EADDRNOTAVAIL   ³  49   ³ an't assigned requested address
ENETDOWN        ³  50   ³ Network is down
ENETUNREACH     ³  51   ³ Network is unreachable
ENETRESET       ³  52   ³ Network dropped connection on reset
ECONNABORTED    ³  53   ³ Software caused connection abort
ECONNRESET      ³  54   ³ Connection reset by peer
ENOBUFS         ³  55   ³ No buffer space available
EISCONN         ³  56   ³ Socket is already connected
ENOTCONN        ³  57   ³ Socket is not connected
ESHUTDOWN       ³  58   ³ Can't send after socket shutdown
ETOOMANYREFS    ³  59   ³ Too many references: can't splice
ETIMEDOUT       ³  60   ³ Connection timed out
ECONNREFUSED    ³  61   ³ Connection refused
ELOOP           ³  62   ³ Too many levels of symbolic links
ENOTSOCK        ³  63   ³ Socket operation on non-socket
EHOSTDOWN       ³  64   ³ Host is down
EHOSTUNREACH    ³  65   ³ No route to host
EALREADY        ³  66   ³ Operation already in progress
þendexample

    In multithread programs (-Zmt, -Zmts, or -Zmtd), errno is not a
    global variable; it is an lvalue that depends on the thread
    number; each thread has its own errno object.

    To create a library which can be linked to both single-thread and
    multithread programs, use the option

þexample
-D__ST_MT_ERRNO__
þendexample

    on the GCC command line to define errno to call _errno().

þseealso _beginthread() _errno() _gettid() perror() strerror() _syserrno() sys_errlist _threadid _threadstore()


þfunction g_xsize g_ysize g_colors
þcompat emx
þheaders
#include <graph.h>
þendheaders

þprototype
int g_xsize;
int g_ysize;
int g_colors;
þendprototype

    These variables describe the graphics mode selected by g_mode() or
    g_modeset().  g_xsize is the horizontal resolution (width),
    g_ysize is the vertical resolution (height), g_colors is the
    number of distinct colors that can be displayed at a time.

þseealso g_mode() g_modeset()


þfunction _osminor _osmajor
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þprototype
const unsigned char _osminor;
const unsigned char _osmajor;
þendprototype

    These variables contain the minor and major version numbers of the
    operating system.  For DOS 3.30, _osmajor is 3 and _osminor is
    30.  For OS/2 2.0, _osmajor is 20, _osminor is 0.  For OS/2 2.1,
    _osmajor is 20, _osminor is 10.

þseealso _emx_env _osmode

þsamplecode
printf ("OS version: %d.%d\n", _osmajor, _osminor);
þendsamplecode


þfunction _osmode
þcompat PC
þheaders
#include <stdlib.h>
þendheaders

þprototype
const unsigned char _osmode;
þendprototype

    This variable contains DOS_MODE if your program is running under
    DOS or OS2_MODE if your program is running under OS/2.

þseealso _emx_env


þfunction stderr stdin stdout
þcompat C90
þheaders
#include <stdio.h>
þendheaders

þprototype
FILE *stderr;
FILE *stdin;
FILE *stdout;
þendprototype

    stderr, stdin, and stdout are expressions of type `þtt{FILE *}'
    pointing to the þtt{FILE} objects associated with the
    standard error, standard input, and standard output streams,
    respectively.

þhints

    Note that stderr, stdin, and stdout need not be variables, that
    is, you cannot use them in initializers and you cannot assign to
    them.  Use freopen() to associate another stream with stderr,
    stdin, or stdout.

þseealso freopen()


þfunction sys_errlist sys_nerr
þheaders
#include <stdlib.h>
þendheaders

þprototype
const char * const sys_errlist[];
const int sys_nerr;
þendprototype

    sys_errlist is an array of error messages indexed by errno values.
    sys_nerr is the number of elements in the sys_errlist array.

þseealso errno perror() strerror()


þfunction _threadid
þcompat OS/2
þheaders
#include <stddef.h>
þendheaders

þprototype
unsigned *_threadid;
þendprototype

    _threadid is an lvalue which points to the thread identification
    number of the current thread as contained in the þtt{TIB2}
    structure.  _threadid must not be used under DOS.

þseealso _beginthread() _gettid() _threadstore()


þfunction timezone
þheaders
#include <time.h>
þendheaders

þprototype
long timezone;
þendprototype

    Seconds west of the Prime Meridian.  This variable is set by tzset().

þseealso daylight tzname tzset()


þfunction tzname
þheaders
#include <time.h>
þendheaders

þprototype
char *tzname[2];
þendprototype

    The first pointer points to the name of the local standard
    timezone.  The second pointer points to the name of the local
    summer timezone.  This variable is set by tzset().

þseealso daylight timezone tzset()

þfunction basename
þheaders
#include <string.h>
þendheaders

þprototype
char *basename (const char *fname);
þendprototype

    This function is compatible with the GNU version of the "basename"
    function. It returns the last component of the path. This function
    is the preferred usage, since it does not modify the argument, and
    respects trailing slashes. If you include libgen.h, you get the XPG
    version.

þseealso dirname()

þfunction basename
þheaders
#include <libgen.h>
þendheaders

þprototype
char *basename (char *path);
þendprototype

    This function returns a pointer to the last component of a pathname.
    If the path ends with a trailing backslash, it is removed, and the
    pointer returned points to the beginning of last path component.
    If the pathname consists entirely of '/' characters, then a pointer
    to "/" is returned. If path is NULL or a empty string, "." is returned.

þseealso dirname()

þfunction dirname
þheaders
#include <libgen.h>
þendheaders

þprototype
char *dirname (char *path);
þendprototype

    This function complements the XPG basename() function. If path is
    NULL, a empty string, or does not contain slashes (forward or backward),
    "." is returned. Otherwise it returns a pointer to the directory part
    of the pathname; the last slash in the pathname is replaced with zero.

þseealso basename()

þh1 System calls

  System calls are documented in þtt{/emx/doc/system.doc}.

  All system calls are declared in <emx/syscalls.h>.  Interface
  routines are in the emx.a and emx.lib libraries.  System call
  emulation routines are in the sys.lib libraries.  Please do not use
  system calls from application programs -- always use C library
  functions.  If you need a system call, put a function into the
  library which issues the system call.

  Do not use INT 21H: the function numbers and the parameter passing
  conventions are subject to change.  Similarities to DOS function
  numbers are just coincidence and will probably disappear.  Moreover,
  INT 21H, like any software interrupt, cannot be used under OS/2.
  The goal is to have Unix-like system calls.

þtext

--------------------------- END OF EMXLIB.DOC ------------------------------
þendtext
